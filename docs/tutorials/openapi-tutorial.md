---
sidebar_position: 20
title: OpenAPI Support
description: Learn how to automatically generate clients for Operon applications.
---

[Operon CLI](../api-reference/cli.md) v0.6 adds the `openapi` command that generates an [OpenAPI 3.0.x](https://www.openapis.org/) definition file for a Operon application.
This definition file can be used to automatically generate strongly typed client code to invoke Operon application endpoints.

### Generate OpenAPI Definition File

To generate a OpenAPI definition file for an Operon application, run the following `operon` cli command:

```shell
npx dbos-sdk openapi src/operations.ts
```

This command takes a single required argument - the path to the Operon application's TypeScript entrypoint file.
For Operon applications generated by [`dbos-sdk init`](../api-reference/cli.md#npx-operon-init), the entrypoint will be `src/operations.ts`.

The `operon openapi` command generates an OpenAPI definition file `openapi.yaml` in the same folder as the entrypoint file.

::::info
This entrypoint argument is slightly different from the [`runtimeConfig.entrypoint`](../api-reference/configuration.md#runtime) config setting.
The `operon openapi` argument references the TypeScript entrypoint file.
The `runtimeConfig.entrypoint` setting references the JavaScript file generated from the TypeScript entrypoint file.
::::

### Generate Client Code From OpenAPI Definition

Multiple vendors provide OpenAPI client generators that will work with an Operon OpenAPI declaration file.
Each of these vendors have tools and documentation for generating client code for a variety of languages and runtimes.
Some of these tools include:

* [Microsoft Kiota](https://learn.microsoft.com/en-us/openapi/kiota/overview)
* [OpenAPI Generator](https://openapi-generator.tech/)
* [Swagger CodeGen](https://swagger.io/tools/swagger-codegen/) and [Online Editor](https://editor.swagger.io/)
* [openapi-typescript](https://openapi-ts.pages.dev/)
* [oazapfts](https://github.com/oazapfts/oazapfts)
* [OpenAPI Typescript Codegen](https://github.com/ferdikoomen/openapi-typescript-codegen)

We can't provide tutorials for all of these OpenAPI generator tools, but the Swagger Editor runs in the browser so is straightforward to use for a simple tutorial

First, you need to run `npx dbos-sdk openapi` against your Operon application entrypoint as described above.

::::info
Note, the shop and payment backend applications from the [Operon E-Commerce demo app](./demo-apps.md#e-commerce)  
include generated OpenApi definition files if you want to try this without creating your own application.
::::

Then, copy and paste the contents of the generated `openapi.yaml` file into [Swagger Editor](https://editor.swagger.io/).
Swagger Editor will validate the OpenAPI definitions and render a documentation page for the api.

::::info
Note, the Swagger Editor generated documentation includes tooling to trigger OpenAPI endpoints from directly in the web page. 
This tooling will not work as the OpenAPI definition generated by Operon does not include server URL information.
::::

At the top of the Swagger Editor, there is a "Generate Client" dropdown menu. Select typescript-axios from the menu. 
This will download a zip file containing a TypeScript package with the code generated from the OpenAPI definition.

The `typescript-axios` Swagger generator generates a full TypeScript package that supports `npm install` and `npm run build`.
Typically, you would incorporate the generated code into an existing client projects that needs to call into the Operon project.

Here is some example code using the `typescript-axios` Swagger generator and the OpenAPI definition for the [E-Commerce Demo Shop Operon application](https://github.com/dbos-inc/dbos-demo-apps/tree/main/e-commerce/shop-backend).


```ts
import { Configuration, DefaultApi } from "./index";

const config = new Configuration({
    basePath: "http://localhost:8082"
});

const api = new DefaultApi(config);

async function main() {
    const response = await api.getProducts();
    for (const product of response.data) {
        console.log(product.description);
    }
}

main();
```

::::info
As mentioned earlier, the OpenAPI definition file generated for an Operon application does not include server URL information.
The server `basePath` must be included programmatically as in the code snippet above, regardless of the OpenAPI generator you choose to use.
::::

### Specify OpenAPI Security Scheme and Requirements

Operon [handlers](http://localhost:3000/tutorials/http-serving-tutorial#handlers) (i.e. methods with `@GetApi` or `@PostApi`) 
are mapped to OpenAPI [path items](https://spec.openapis.org/oas/v3.0.3#path-item-object).
Path item operations optionally include security requirements, which map to security schemes defined in the 
`components.securitySchemes` section of the  OpenAPI definition file.
Some OpenAPI generators use this information to automatically manage user credentials in the generated client code. 

[Authentication](./authentication-authorization.md) in Operon is done via the middleware function passed to `@Authentication`.
Parsing the authentication logic to determine the OpenAPI security scheme information is not feasible.
To include authentication information in the OpenAPI file, declare the security scheme via the `@OpenApiSecurityScheme` class decorator.

```typescript
@Authentication(authMiddleware)
@OpenApiSecurityScheme({ type: 'http', scheme: 'bearer' })
export class Operations {
  @GetApi("/post/:id")
  @RequiredRoles(['user'])
  static async getPost(ctx: TransactionContext, @ArgSource(ArgSources.URL) id: string) {
    ...
  }
}
```

The `@OpenApiSecurityScheme` decorator takes a single parameter, matching a supported security scheme
[from the OpenAPI spec](https://spec.openapis.org/oas/v3.0.3#security-scheme-object). 

::::info
Operon does not support the `oauth2` OpenAPI security scheme at this time.
::::

All handler methods on an Operon class use the same `@OpenApiSecurityScheme` in the generated OpenAPI definition,
except for methods that have no specified [`@RequiredRoles`](./authentication-authorization#authorization-decorators).
Operon does not check authentication or authorization info for methods without any required roles.
Methods without any required roles do not emit security requirements in the generated OpenAPI definition file.


```typescript
@Authentication(authMiddleware)
@DefaultRequiredRoles(['user'])
@OpenApiSecurityScheme({ type: 'http', scheme: 'bearer' })
export class Operations {
  @PostApi('/api/login')
  @RequiredRoles([])
  static async login(ctx: HandlerContext, username: string, password: string) {
    ...
  }
}
```

This allows a developer to have authenticated and non authenticated methods within a single Operon class.
If you need to support different security schemes for different Operon methods, those need to be separated into separate classes.

