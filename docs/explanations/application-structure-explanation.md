---
sidebar_position: 1
title: Application Structure
description: Learn about the structure of an Operon application
---

In this guide, you'll learn about the structure of an Operon application.

### Directory Structure

When you initialize an Operon project with `npx operon init`, it has the following structure:

```bash
operon-hello-app/
├── README.md
├── knexfile.ts
├── migrations/
├── node_modules/
├── operon-config.yaml
├── package-lock.json
├── package.json
├── src/
│   └── operations.ts
├── start_postgres_docker.sh
└── tsconfig.json
```

The two most important files in an Operon project are `operon-config.yaml` and `src/operations.ts`.

`operon-config.yaml` defines the configuration of an Operon project, including database connection information, ORM configuration, and global logging configuration.
All options are documented in our [configuration reference](..).

`src/operations.ts` is where Operon looks for your code.
At startup, the Operon runtime automatically loads all classes exported from this file, serving their endpoints and registering their transactions and workflows.
If you're writing a small application, you can write all your code directly in this file.
In a larger application, you can write your code wherever you want, but should use `src/operations.ts` as an index file, exporting code written elsewhere.

As for the rest of the directory:

- `knexfile.ts` is a configuration file for [Knex](https://knexjs.org), which we use as a query builder and migration tool.
- `migrations` is initialized with a Knex database migration used in the [quickstart guide](../getting-started/quickstart).  If you're using Knex for schema management, you can create your own migrations here.
- `node_modules`, `package-lock.json`, `package.json`, and `tsconfig.json` are needed by all Node/Typescript projects.
- `start_postgres_docker.sh` is a convenience script that initializes a Docker-hosted Postgres database for use in the [quickstart](../getting-started/quickstart).  You can modify this script if you want to use Docker-hosted Postgres for local development.

### Code Structure

Here's the initial source code generated by `npx operon init` (in `src/operations.ts`):

```javascript
import { TransactionContext, OperonTransaction, GetApi, HandlerContext } from '@dbos-inc/operon'
import { Knex } from 'knex';

type KnexTransactionContext = TransactionContext<Knex>;

export interface operon_hello {
  name: string;
  greet_count: number;
}

export class Hello {

  @OperonTransaction()
  static async helloTransaction(txnCtxt: KnexTransactionContext, name: string) {
    // Look up greet_count.
    let greet_count = await txnCtxt.client<operon_hello>("operon_hello")
      .select("greet_count")
      .where({ name: name })
      .first()
      .then(row => row?.greet_count);
    if (greet_count) {
      // If greet_count is set, increment it.
      greet_count++;
      await txnCtxt.client<operon_hello>("operon_hello")
        .where({ name: name })
        .increment('greet_count', 1);
    } else {
      // If greet_count is not set, set it to 1.
      greet_count = 1;
      await txnCtxt.client<operon_hello>("operon_hello")
        .insert({ name: name, greet_count: 1 })
    }
    return `Hello, ${name}! You have been greeted ${greet_count} times.\n`;
  }

  @GetApi('/greeting/:name')
  static async helloHandler(handlerCtxt: HandlerContext, name: string) {
    return handlerCtxt.invoke(Hello).helloTransaction(name);
  }
}

```
An Operon application like this one is made up of classes encapsulating _functions_, written as decorated static class methods.
There are four basic types of functions.
This example contains two of them:

- [**Transactions**](../tutorials/transaction-tutorial), like `helloTransaction` perform database operations.
- [**Handlers**](../tutorials/http-serving-tutorial), like `helloHandler`, serve HTTP requests.

There are two more:

- [**Communicators**](../tutorials/communicator-tutorial) manage communication with external services and APIs.
- [**Workflows**](../tutorials/workflow-tutorial) reliably orchestrate other functions.

A function needs to follow a few rules:

- It must be a static class method.  For Operon to find it, that class must be exported from `src/operations.ts`.
- It must have a decorator telling Operon what kind of function it is: [`@OperonTransaction`](../api-reference/decorators#operontransaction) for transactions, [`@OperonCommunicator`](../api-reference/decorators#operoncommunicator) for communicators, [`@OperonWorkflow`](../api-reference/decorators#operonworkflow) for workflows, or [`GetApi`](../api-reference/decorators#getapi) or [`PostApi`](../api-reference/decorators#postapi) for handlers.
- Its first argument must be the appropriate kind of [Operon context](../api-reference/contexts). Contexts provide functions with useful methods, such as access to a database client for transactions.
- Its input and return types must be serializable to JSON.

Once you've written your functions, there are two basic ways to call them:

1.  Any function (not just handlers) can be called from HTTP if it's annotated with the [`GetApi`](../api-reference/decorators#getapi) or [`PostApi`](../api-reference/decorators#postapi) decorators.  See our [HTTP serving tutorial](../tutorials/http-serving-tutorial.md) for details.
2. Handlers and workflows can invoke other functions via their contexts' [invoke](..) method.

To learn more about each individual type of function and what it can do, see our [tutorials](../category/tutorials/).
