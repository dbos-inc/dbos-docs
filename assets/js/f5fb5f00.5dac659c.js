"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[5277],{8187:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"typescript/reference/datasource","title":"Transactions & Datasources","description":"Introduction To Transactions And Datasources","source":"@site/docs/typescript/reference/datasource.md","sourceDirName":"typescript/reference","slug":"/typescript/reference/datasource","permalink":"/typescript/reference/datasource","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":45,"frontMatter":{"sidebar_position":45,"title":"Transactions & Datasources"},"sidebar":"tutorialSidebar","previous":{"title":"Queues","permalink":"/typescript/reference/queues"},"next":{"title":"DBOS Client","permalink":"/typescript/reference/client"}}');var s=a(4848),r=a(8453);const i={sidebar_position:45,title:"Transactions & Datasources"},o=void 0,c={},l=[{value:"Introduction To Transactions And Datasources",id:"introduction-to-transactions-and-datasources",level:2},{value:"Setting Up Data Sources",id:"setting-up-data-sources",level:2},{value:"Instantiating Datasources",id:"instantiating-datasources",level:3},{value:"Installing the DBOS Schema",id:"installing-the-dbos-schema",level:3},{value:"Running Transactions",id:"running-transactions",level:2},{value:"dataSource.runTransaction()",id:"datasourceruntransaction",level:3},{value:"dataSource.registerTransaction()",id:"datasourceregistertransaction",level:3},{value:"dataSource.transaction() Decorators",id:"datasourcetransaction-decorators",level:3},{value:"Transaction Configuration",id:"transaction-configuration",level:2}];function d(n){const e={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h2,{id:"introduction-to-transactions-and-datasources",children:"Introduction To Transactions And Datasources"}),"\n",(0,s.jsxs)(e.p,{children:["DBOS ",(0,s.jsx)(e.a,{href:"/typescript/reference/workflows-steps#workflows",children:"workflows"})," reliably execute a sequence of ",(0,s.jsx)(e.a,{href:"/typescript/reference/workflows-steps#steps",children:"steps"}),".  A ",(0,s.jsx)(e.em,{children:"DBOS transaction"})," is a special kind of step that runs a function within a database transaction and records its return value within that transaction.   This guarantees that the transaction is executed exactly once, even in the face of retries or failures."]}),"\n",(0,s.jsxs)(e.p,{children:["Different JavaScript libraries have different mechanisms for starting transactions and accessing the database. The ",(0,s.jsx)(e.em,{children:"DBOS datasource"})," layer provides plugin packages for popular libraries, offering:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Native access to each library\u2019s database APIs"}),"\n",(0,s.jsx)(e.li,{children:"A consistent transaction control interface"}),"\n",(0,s.jsx)(e.li,{children:"Compile-time type safety"}),"\n",(0,s.jsx)(e.li,{children:"Correct runtime behavior across all supported environments"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"setting-up-data-sources",children:"Setting Up Data Sources"}),"\n",(0,s.jsx)(e.p,{children:"Each data source is implemented in a separate package.\nThis package, along with its underlying database libraries, should be installed before use."}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://www.npmjs.com/package/@dbos-inc/drizzle-datasource",children:"@dbos-inc/drizzle-datasource"}),": ",(0,s.jsx)(e.a,{href:"https://orm.drizzle.team/",children:"drizzle"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://www.npmjs.com/package/@dbos-inc/knex-datasource",children:"@dbos-inc/knex-datasource"}),": ",(0,s.jsx)(e.a,{href:"https://knexjs.org/",children:"Knex.js"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://www.npmjs.com/package/@dbos-inc/nodepg-datasource",children:"@dbos-inc/nodepg-datasource"}),": ",(0,s.jsx)(e.a,{href:"https://github.com/brianc/node-postgres",children:"node-postgres"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://www.npmjs.com/package/@dbos-inc/postgres-datasource",children:"@dbos-inc/postgres-datasource"}),": ",(0,s.jsx)(e.a,{href:"https://github.com/porsager/postgres",children:"Postgres.js"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://www.npmjs.com/package/@dbos-inc/prisma-datasource",children:"@dbos-inc/prisma-datasource"}),": ",(0,s.jsx)(e.a,{href:"https://www.prisma.io/",children:"Prisma"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://www.npmjs.com/package/@dbos-inc/typeorm-datasource",children:"@dbos-inc/typeorm-datasource"}),": ",(0,s.jsx)(e.a,{href:"https://typeorm.io/",children:"TypeORM"})]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"instantiating-datasources",children:"Instantiating Datasources"}),"\n",(0,s.jsx)(e.p,{children:"In general, datasources should be configured and constructed during program load, noting that they will not open any database connections until later in the initialization process.  This allows the datasource objects to be used to register transaction functions."}),"\n",(0,s.jsx)(e.p,{children:"Configuration details vary slightly depending on the package used; Knex is shown in the example below:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"class KnexDataSource {\n  /**\n   * @param name - A unique name for the datasource.\n   * @param config - A Knex configuration for the datasource. Passed directly into the Knex pool object.\n   */\n  constructor(name: string, config: Knex.Config)  \n}\n\nconst config = {client: 'pg', connection: process.env.DBOS_DATABASE_URL}\nconst dataSource = new KnexDataSource('knex-ds', config);\n"})}),"\n",(0,s.jsxs)(e.p,{children:["Note that each datasource is given a ",(0,s.jsx)(e.code,{children:"name"})," upon construction.  These names are used internally within DBOS and must be unique."]}),"\n",(0,s.jsxs)(e.p,{children:["To support operation in DBOS Cloud, ",(0,s.jsx)(e.code,{children:"DBOS_DATABASE_URL"})," environment varialbe should be checked within configuration to connect to the primary application database."]}),"\n",(0,s.jsx)(e.h3,{id:"installing-the-dbos-schema",children:"Installing the DBOS Schema"}),"\n",(0,s.jsxs)(e.p,{children:["DBOS datasources require an additional ",(0,s.jsx)(e.code,{children:"transaction_completion"})," table within the ",(0,s.jsx)(e.code,{children:"dbos"})," schema.  This table is used for recordkeeping, ensuring that each transaction is run exactly once."]}),"\n",(0,s.jsxs)(e.p,{children:["This table can be installed by running the ",(0,s.jsx)(e.code,{children:"initializeDBOSSchema"})," method of your datasource. You may do this as part of database schema migrations or at app startup. For example, here is a Knex migration file that installs the DBOS schema in Knex:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const {\n  KnexDataSource\n} = require('@dbos-inc/knex-datasource');\n\nexports.up = async function(knex) {\n  await KnexDataSource.initializeDBOSSchema(knex);\n};\n\nexports.down = async function(knex) {\n  await KnexDataSource.uninitializeDBOSSchema(knex);\n};\n"})}),"\n",(0,s.jsx)(e.h2,{id:"running-transactions",children:"Running Transactions"}),"\n",(0,s.jsx)(e.p,{children:"DBOS datasource transactions may be run using one of the following mechanisms:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Directly inline in the code path, using ",(0,s.jsx)(e.a,{href:"#datasourceruntransaction",children:(0,s.jsx)(e.code,{children:"runTransaction"})})]}),"\n",(0,s.jsxs)(e.li,{children:["Using a function wrapper returned from ",(0,s.jsx)(e.a,{href:"#datasourceregistertransaction",children:(0,s.jsx)(e.code,{children:"registerTransaction"})})]}),"\n",(0,s.jsxs)(e.li,{children:["Using a ",(0,s.jsx)(e.a,{href:"#datasourcetransaction-decorators",children:(0,s.jsx)(e.code,{children:"@transaction"})})," decorator on a class method"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"While datasource transactions are generally run inside workflows, this is not strictly necessary.  Outside of a workflow, the transaction function will still execute, but execution guarantees are not provided."}),"\n",(0,s.jsx)(e.h3,{id:"datasourceruntransaction",children:"dataSource.runTransaction()"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"runTransaction"}),' allows code to be run "in line" within a datasource transaction, without pulling the code out into a separate named function.']}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"runTransaction<T>(\n  func: () => Promise<T>,\n  config?: TransactionConfig & {name?: string}\n)\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"func"}),": The function to run as a transaction."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"config"}),": The transaction config, described below."]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Knex Example:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"async function workflowFunction() {\n  await dataSource.runTransaction(async () => {\n    await dataSource.client.raw('INSERT INTO example_table (name) VALUES (?)', ['dbos']);\n  }, {name: \"insertRow\"});\n\n  return await dataSource.runTransaction(async () => {\n      const result = await dataSource.client.raw('SELECT COUNT(*) as count FROM example_table');\n      const count = result.rows[0].count;\n      return count;\n    },\n    {name: \"countRows\", readOnly: true}\n  );\n}\nconst workflow = DBOS.registerWorkflow(workflowFunction, \"workflow\");\n"})}),"\n",(0,s.jsx)(e.h3,{id:"datasourceregistertransaction",children:"dataSource.registerTransaction()"}),"\n",(0,s.jsx)(e.p,{children:"A transaction function may be registered, returning a wrapper function that remembers the associated datasource and transaction configuration.  The returned function takes the same argument as the provided function, making it transparent to the caller."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"registerTransaction<This, Args extends unknown[], Return>(\n  func: (this: This, ...args: Args) => Promise<Return>,\n  config?: TransactionConfig & {name?: string},\n): (this: This, ...args: Args) => Promise<Return>\n"})}),"\n",(0,s.jsx)(e.p,{children:"Wrap a function in a tranasction.\nReturns the wrapped function."}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"func"}),": The function to be wrapped in a transaction."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"config"}),": The transaction config, documented below.  The exact configuration type may vary depending on the datasource."]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Knex Example:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"async function insertRowFunction() {\n  await dataSource.client.raw('INSERT INTO example_table (name) VALUES (?)', ['dbos']);\n}\nconst insertRowTransaction = dataSource.registerTransaction(insertRowFunction);\n\nasync function countRowsFunction() {\n  const result = await dataSource.client.raw('SELECT COUNT(*) as count FROM example_table');\n  const count = result.rows[0].count;\n}\nconst countRowsTransaction = dataSource.registerTransaction(countRowsFunction);\n\nasync function workflowFunction() {\n  await insertRowTransaction();\n  await countRowsTransaction();\n}\nconst workflow = DBOS.registerWorkflow(workflowFunction, \"workflow\")\n"})}),"\n",(0,s.jsx)(e.h3,{id:"datasourcetransaction-decorators",children:"dataSource.transaction() Decorators"}),"\n",(0,s.jsx)(e.p,{children:"Decorators can be used on class methods to mark them as transactional steps within a workflow."}),"\n",(0,s.jsxs)(e.p,{children:["Each datasource provides a ",(0,s.jsx)(e.code,{children:"transaction"})," decorator that accepts a ",(0,s.jsx)(e.code,{children:"TransactionConfig"})," appropriate to the datasource."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"dataSource.transaction(\n    config?: TransactionConfig\n)\n"})}),"\n",(0,s.jsxs)(e.p,{children:["For example, the Knex ",(0,s.jsx)(e.code,{children:"TransactionConfig"})," is:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"interface TransactionConfig {\n  isolationLevel?: Knex.IsolationLevels;\n  readOnly?: boolean;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"config"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"isolationLevel"}),": The Postgres isolation level of the transaction. Must be one of ",(0,s.jsx)(e.code,{children:"read committed"}),", ",(0,s.jsx)(e.code,{children:"repeatable read"}),", or ",(0,s.jsx)(e.code,{children:"serializable"}),". Default is ",(0,s.jsx)(e.code,{children:"serializable"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"readOnly"}),": Whether this transaction only performs reads. Optimizes checkpointing if so."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Example:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"@dataSource.transaction()\n  static async insertRow() {\n  await dataSource.client.raw('INSERT INTO example_table (name) VALUES (?)', ['dbos']);\n}\n\n@dataSource.transaction()\nstatic async countRows() {\n  const result = await dataSource.client.raw('SELECT COUNT(*) as count FROM example_table');\n  const count = result.rows[0].count;\n}\n\n@DBOS.workflow()\nstatic async transactionWorkflow() {\n  await Toolbox.insertRow()\n  await Toolbox.countRows()\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"transaction-configuration",children:"Transaction Configuration"}),"\n",(0,s.jsx)(e.p,{children:"Transaction configuration varies depending on the underlying datasource package in use.  Generally, fields similar to the following are supported:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"name"}),": Provides a name for the function, which will be recorded in the DBOS step record.  If not specified, the ",(0,s.jsx)(e.code,{children:"name"})," will be taken from the transactions ",(0,s.jsx)(e.code,{children:"function"})," object."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"isolationLevel?: 'read uncommitted' | 'read committed' | 'repeatable read' | 'serializable'"}),": Allows the transaction isolation level to be set."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"accessMode?: 'read only' | 'read write'"})," or ",(0,s.jsx)(e.code,{children:"readOnly?: boolean"}),": Allows a read-only transaction to be requested.  Read-only transactions involve no writes to the underlying application database, but the result will be stored in the DBOS system database to allow for correct workflow behavior."]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>i,x:()=>o});var t=a(6540);const s={},r=t.createContext(s);function i(n){const e=t.useContext(r);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:i(n.components),t.createElement(r.Provider,{value:e},n.children)}}}]);