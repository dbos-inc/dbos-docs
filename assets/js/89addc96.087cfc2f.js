"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[6819],{4318:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"typescript/tutorials/workflow-tutorial","title":"Workflows","description":"Workflows provide durable execution so you can write programs that are resilient to any failure.","source":"@site/docs/typescript/tutorials/workflow-tutorial.md","sourceDirName":"typescript/tutorials","slug":"/typescript/tutorials/workflow-tutorial","permalink":"/typescript/tutorials/workflow-tutorial","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"title":"Workflows","toc_max_heading_level":3},"sidebar":"tutorialSidebar","previous":{"title":"AI Model Prompting","permalink":"/typescript/prompting"},"next":{"title":"Steps","permalink":"/typescript/tutorials/step-tutorial"}}');var r=t(4848),s=t(8453);const i={sidebar_position:10,title:"Workflows",toc_max_heading_level:3},a=void 0,l={},c=[{value:"Starting Workflows In The Background",id:"starting-workflows-in-the-background",level:2},{value:"Workflow IDs and Idempotency",id:"workflow-ids-and-idempotency",level:2},{value:"Determinism",id:"determinism",level:2},{value:"Running Steps In Parallel",id:"running-steps-in-parallel",level:3},{value:"Workflow Timeouts",id:"workflow-timeouts",level:2},{value:"Durable Sleep",id:"durable-sleep",level:2},{value:"Debouncing Workflows",id:"debouncing-workflows",level:2},{value:"Workflow Guarantees",id:"workflow-guarantees",level:2},{value:"Workflow Versioning and Recovery",id:"workflow-versioning-and-recovery",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Workflows provide ",(0,r.jsx)(n.strong,{children:"durable execution"})," so you can write programs that are ",(0,r.jsx)(n.strong,{children:"resilient to any failure"}),".\nWorkflows are comprised of ",(0,r.jsx)(n.a,{href:"/typescript/tutorials/step-tutorial",children:"steps"}),", which wrap ordinary TypeScript (or JavaScript) functions.\nIf a workflow is interrupted for any reason (e.g., an executor restarts or crashes), when your program restarts the workflow automatically resumes execution from the last completed step."]}),"\n",(0,r.jsxs)(n.p,{children:["To write a workflow, register a TypeScript function with ",(0,r.jsx)(n.code,{children:"DBOS.registerWorkflow"}),".\nThe function's inputs and outputs must be serializable to JSON.\nFor example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'async function stepOne() {\n  DBOS.logger.info("Step one completed!");\n}\n\nasync function stepTwo() {\n  DBOS.logger.info("Step two completed!");\n}\n\nasync function workflowFunction() {\n  await DBOS.runStep(() => stepOne(), {name: "stepOne"});\n  await DBOS.runStep(() => stepTwo(), {name: "stepTwo"});\n}\nconst workflow = DBOS.registerWorkflow(workflowFunction)\n\nawait workflow();\n'})}),"\n",(0,r.jsx)(n.p,{children:"Alternatively, you can register workflows and steps with decorators:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'export class Example {\n  @DBOS.step()\n  static async stepOne() {\n    DBOS.logger.info("Step one completed!");\n  }\n\n  @DBOS.step()\n  static async stepTwo() {\n    DBOS.logger.info("Step two completed!");\n  }\n\n  // Call steps from workflows\n  @DBOS.workflow()\n  static async exampleWorkflow() {\n    await Toolbox.stepOne();\n    await Toolbox.stepTwo();\n  }\n}\n\nawait Example.exampleWorkflow();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"starting-workflows-in-the-background",children:"Starting Workflows In The Background"}),"\n",(0,r.jsxs)(n.p,{children:["One common use-case for workflows is building reliable background tasks that keep running even when your program is interrupted, restarted, or crashes.\nYou can use ",(0,r.jsx)(n.a,{href:"/typescript/reference/methods#dbosstartworkflow",children:(0,r.jsx)(n.code,{children:"DBOS.startWorkflow"})})," to start a workflow in the background.\nIf you start a workflow this way, it returns a ",(0,r.jsx)(n.a,{href:"/typescript/reference/methods#workflow-handles",children:"workflow handle"}),", from which you can access information about the workflow or wait for it to complete and retrieve its result."]}),"\n",(0,r.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'class Example {\n    @DBOS.workflow()\n    static async exampleWorkflow(var1: string, var2: string) {\n        return var1 + var2;\n    }\n}\n\nasync function main() {\n    // Start exampleWorkflow in the background\n    const handle = await DBOS.startWorkflow(Example).exampleWorkflow("one", "two");\n    // Wait for the workflow to complete and return its results\n    const result = await handle.getResult();\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["After starting a workflow in the background, you can use ",(0,r.jsx)(n.a,{href:"/typescript/reference/methods#dbosretrieveworkflow",children:(0,r.jsx)(n.code,{children:"DBOS.retrieveWorkflow"})})," to retrieve a workflow's handle from its ID.\nYou can also retrieve a workflow's handle from outside of your DBOS application with ",(0,r.jsx)(n.a,{href:"/typescript/reference/client#retrieveworkflow",children:"'DBOSClient.retrieveWorkflow`"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If you need to run many workflows in the background and manage their concurrency or flow control, you can also use ",(0,r.jsx)(n.a,{href:"/typescript/tutorials/queue-tutorial",children:"DBOS queues"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"workflow-ids-and-idempotency",children:"Workflow IDs and Idempotency"}),"\n",(0,r.jsxs)(n.p,{children:["Every time you execute a workflow, that execution is assigned a unique ID, by default a ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Universally_unique_identifier",children:"UUID"}),".\nYou can access this ID through the ",(0,r.jsx)(n.code,{children:"DBOS.workflowID"})," context variable.\nWorkflow IDs are useful for communicating with workflows and developing interactive workflows."]}),"\n",(0,r.jsxs)(n.p,{children:["You can set the workflow ID of a workflow as an argument to ",(0,r.jsx)(n.code,{children:"DBOS.startWorkflow()"}),".\nWorkflow IDs must be ",(0,r.jsx)(n.strong,{children:"globally unique"})," for your application.\nAn assigned workflow ID acts as an idempotency key: if a workflow is called multiple times with the same ID, it executes only once.\nThis is useful if your operations have side effects like making a payment or sending an email.\nWorkflow IDs are also useful for communicating with workflows and developing interactive workflows - see ",(0,r.jsx)(n.a,{href:"/typescript/tutorials/workflow-communication",children:"Communicating with Workflows"})," for more details."]}),"\n",(0,r.jsx)(n.p,{children:"For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'class Example {\n    @DBOS.workflow()\n    static async exampleWorkflow(var1: string, var2: string) {\n        // ...\n    }\n}\n\nasync function main() {\n    const myID: string = ...\n    const handle = await DBOS.startWorkflow(Example, {workflowID: myID}).exampleWorkflow("one", "two");\n    const result = await handle.getResult();\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"determinism",children:"Determinism"}),"\n",(0,r.jsxs)(n.p,{children:["Workflows are in most respects normal TypeScript functions.\nThey can have loops, branches, conditionals, and so on.\nHowever, a workflow function must be ",(0,r.jsx)(n.strong,{children:"deterministic"}),": if called multiple times with the same inputs, it should invoke the same steps with the same inputs in the same order (given the same return values from those steps).\nIf you need to perform a non-deterministic operation like accessing the database, calling a third-party API, generating a random number, or getting the local time, you shouldn't do it directly in a workflow function.\nInstead, you should do all database operations in ",(0,r.jsx)(n.a,{href:"./transaction-tutorial",children:"transactions"})," and all other non-deterministic operations in ",(0,r.jsx)(n.a,{href:"/typescript/tutorials/step-tutorial",children:"steps"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, ",(0,r.jsx)(n.strong,{children:"don't do this"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'class Example {\n    @DBOS.workflow()\n    static async exampleWorkflow() {\n        // Don\'t make an HTTP request in a workflow function\n        const body = await fetch("https://example.com").then(r => r.text()); \n        await Example.exampleTransaction(body);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Instead, do this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'class Example {\n    @DBOS.workflow()\n    static async exampleWorkflow() {\n        // Don\'t make an HTTP request in a workflow function\n        const body = await DBOS.runStep(\n          async ()=>{return await fetch("https://example.com").then(r => r.text())},\n          {name: "fetchBody"}\n        );\n        await Example.exampleTransaction(body);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Or this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'class Example {\n    @DBOS.step()\n    static async fetchBody() {\n      // Instead, make HTTP requests in steps\n      return await fetch("https://example.com").then(r => r.text());\n    }\n\n    @DBOS.workflow()\n    static async exampleWorkflow() {\n        const body = await Example.fetchBody();\n        await Example.exampleTransaction(body);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"running-steps-in-parallel",children:"Running Steps In Parallel"}),"\n",(0,r.jsxs)(n.p,{children:["Initiating several concurrent steps in a workflow, followed by awaiting them with ",(0,r.jsx)(n.code,{children:"Promise.allSettled"}),", is valid as long as the steps are started in a deterministic order.  For example the following is allowed:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const results = await Promise.allSettled([\n  step1("arg1"),\n  step2("arg2"),\n  step3("arg3"),\n  step4("arg4"),\n])\n'})}),"\n",(0,r.jsx)(n.p,{children:"This is allowed because each step is started in a well-defined sequence before awaiting."}),"\n",(0,r.jsx)(n.p,{children:"By contrast, the following is not allowed:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const results = await Promise.allSettled([\n  async () => { await step1("arg1"); await step2("arg3"); },\n  async () => { await step3("arg2"); await step4("arg4"); },\n]);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Here, ",(0,r.jsx)(n.code,{children:"step2"})," and ",(0,r.jsx)(n.code,{children:"step4"})," may be started in either order since their execution depends on the relative time taken by ",(0,r.jsx)(n.code,{children:"step1"})," and ",(0,r.jsx)(n.code,{children:"step3"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If you need to run sequences of operations concurrently, start child workflows with ",(0,r.jsx)(n.a,{href:"#starting-workflows-in-the-background",children:(0,r.jsx)(n.code,{children:"startWorkflow"})})," and await the results from their ",(0,r.jsx)(n.code,{children:"WorkflowHandle"}),"s."]}),"\n",(0,r.jsxs)(n.p,{children:["Avoid using ",(0,r.jsx)(n.code,{children:"Promise.all"})," because of how it handles errors and rejections.  When any promise rejects, ",(0,r.jsx)(n.code,{children:"Promise.all"})," immediately fails, leaving the other promises unresolved.  If one of those later throws an unhandled exception, it can crash your Node.js process.  Instead, prefer ",(0,r.jsx)(n.code,{children:"Promise.allSettled"}),", which safely waits for all promises to complete and reports their outcomes."]}),"\n",(0,r.jsx)(n.h2,{id:"workflow-timeouts",children:"Workflow Timeouts"}),"\n",(0,r.jsxs)(n.p,{children:["You can set a timeout for a workflow by passing a ",(0,r.jsx)(n.code,{children:"timeoutMS"})," argument to ",(0,r.jsx)(n.code,{children:"DBOS.startWorkflow"}),".\nWhen the timeout expires, the workflow ",(0,r.jsx)(n.strong,{children:"and all its children"})," are cancelled.\nCancelling a workflow sets its status to ",(0,r.jsx)(n.code,{children:"CANCELLED"})," and preempts its execution at the beginning of its next step."]}),"\n",(0,r.jsxs)(n.p,{children:["Timeouts are ",(0,r.jsx)(n.strong,{children:"start-to-completion"}),": a workflow's timeout does not begin until the workflow starts execution.\nAlso, timeouts are ",(0,r.jsx)(n.strong,{children:"durable"}),": they are stored in the database and persist across restarts, so workflows can have very long timeouts."]}),"\n",(0,r.jsx)(n.p,{children:"Example syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"async function taskFunction(task) {\n    // ...\n}\nconst taskWorkflow = DBOS.registerWorkflow(taskFunction);\n\nasync function main() {\n  const task = ...\n  const timeout = ... // Timeout in milliseconds\n  const handle = await DBOS.startWorkflow(taskWorkflow, {timeoutMS: timeout})(task);\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"durable-sleep",children:"Durable Sleep"}),"\n",(0,r.jsxs)(n.p,{children:["You can use ",(0,r.jsx)(n.a,{href:"/typescript/reference/methods#dbossleep",children:(0,r.jsx)(n.code,{children:"DBOS.sleep()"})})," to put your workflow to sleep for any period of time.\nThis sleep is ",(0,r.jsx)(n.strong,{children:"durable"}),"\u2014DBOS saves the wakeup time in the database so that even if the workflow is interrupted and restarted multiple times while sleeping, it still wakes up on schedule."]}),"\n",(0,r.jsx)(n.p,{children:"Sleeping is useful for scheduling a workflow to run in the future (even days, weeks, or months from now).\nFor example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"@DBOS.workflow()\nstatic async exampleWorkflow(timeToSleep, task) {\n    await DBOS.sleep(timeToSleep);\n    await runTask(task);\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"debouncing-workflows",children:"Debouncing Workflows"}),"\n",(0,r.jsx)(n.p,{children:"You can debounce workflows to delay their execution until some time has passed since the workflow has last been called.\nThis is useful for preventing wasted work when a workflow may be triggered multiple times in quick succession.\nFor example, if a user is editing an input field, you can debounce their changes to execute a processing workflow only after they haven't edited the field for some time:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"async function processInput(userInput: string) {\n  ...\n}\nconst processInputWorkflow = DBOS.registerWorkflow(processInput);\n\n// Each time a user submits a new input, debounce the processInput workflow.\n// The workflow will wait until 60 seconds after the user stops submitting new inputs,\n// then process the last input submitted.\nconst debouncer = new Debouncer({\n  workflow: processInputWorkflow,\n});\n\nasync function onUserInputSubmit(userId: string, userInput: string) {\n  const debounceKey = userId;\n  const debouncePeriodMs = 60000; // 60 seconds\n  await debouncer.debounce(debounceKey, debouncePeriodMs, userInput);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["See the ",(0,r.jsx)(n.a,{href:"/typescript/reference/methods#debouncing",children:"debouncing reference"})," for more details."]}),"\n",(0,r.jsx)(n.h2,{id:"workflow-guarantees",children:"Workflow Guarantees"}),"\n",(0,r.jsx)(n.p,{children:"Workflows provide the following reliability guarantees.\nThese guarantees assume that the application and database may crash and go offline at any point in time, but are always restarted and return online."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Workflows always run to completion.  If a DBOS process is interrupted while executing a workflow and restarts, it resumes the workflow from the last completed step."}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/typescript/tutorials/step-tutorial",children:"Steps"})," are tried ",(0,r.jsx)(n.em,{children:"at least once"})," but are never re-executed after they complete.  If a failure occurs inside a step, the step may be retried, but once a step has completed (returned a value or thrown an exception to the calling workflow), it will never be re-executed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/typescript/tutorials/transaction-tutorial",children:"Transactions"})," commit ",(0,r.jsx)(n.em,{children:"exactly once"}),".  Once a workflow commits a transaction, it will never retry that transaction."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If an exception is thrown from a workflow, the workflow ",(0,r.jsx)(n.strong,{children:"terminates"}),"\u2014DBOS records the exception, sets the workflow status to ",(0,r.jsx)(n.code,{children:"ERROR"}),", and ",(0,r.jsx)(n.strong,{children:"does not recover the workflow"}),".\nThis is because uncaught exceptions are assumed to be nonrecoverable.\nIf your workflow performs operations that may transiently fail (for example, sending HTTP requests to unreliable services), those should be performed in ",(0,r.jsx)(n.a,{href:"/typescript/tutorials/step-tutorial#configurable-retries",children:"steps with configured retries"}),".\nDBOS provides ",(0,r.jsx)(n.a,{href:"/typescript/tutorials/workflow-management",children:"tooling"})," to help you identify failed workflows and examine the specific uncaught exceptions."]}),"\n",(0,r.jsx)(n.h2,{id:"workflow-versioning-and-recovery",children:"Workflow Versioning and Recovery"}),"\n",(0,r.jsxs)(n.p,{children:["DBOS ",(0,r.jsx)(n.strong,{children:"versions"})," applications and workflows.\nAll workflows are tagged with the application version on which they started.\nBy default, application version is automatically computed from a hash of workflow source code.\nHowever, you can set your own version through configuration."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"DBOS.setConfig({\n  name: 'dbos-app',\n  systemDatabaseUrl: process.env.DBOS_SYSTEM_DATABASE_URL,\n  applicationVersion: '1.0.0',\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"When DBOS tries to recover workflows, it only recovers workflows whose version matches the current application version.\nThis prevents unsafe recovery of workflows that depend on different code."}),"\n",(0,r.jsxs)(n.p,{children:["When using versioning, we recommend ",(0,r.jsx)(n.strong,{children:"blue-green"}),' code upgrades.\nWhen deploying a new version of your code, launch new processes running your new code version, but retain some processes running your old code version.\nDirect new traffic to your new processes while your old processes "drain" and complete all workflows of the old code version.\nThen, once all workflows of the old version are complete (you can use ',(0,r.jsx)(n.a,{href:"/typescript/reference/methods#dboslistworkflows",children:(0,r.jsx)(n.code,{children:"DBOS.listWorkflows"})})," to check), you can retire the old code version."]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(6540);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);