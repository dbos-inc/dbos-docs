"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[944],{3282:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var t=o(5893),r=o(1151);const i={sidebar_position:4,title:"Workflows",description:"Learn how to make applications reliable using workflows."},a=void 0,s={id:"tutorials/workflow-tutorial",title:"Workflows",description:"Learn how to make applications reliable using workflows.",source:"@site/docs/tutorials/workflow-tutorial.md",sourceDirName:"tutorials",slug:"/tutorials/workflow-tutorial",permalink:"/tutorials/workflow-tutorial",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Workflows",description:"Learn how to make applications reliable using workflows."},sidebar:"tutorialSidebar",previous:{title:"Communicators",permalink:"/tutorials/communicator-tutorial"},next:{title:"Idempotency",permalink:"/tutorials/idempotency-tutorial"}},l={},c=[{value:"Invoking Functions from Workflows",id:"invoking-functions-from-workflows",level:3},{value:"Reliability Guarantees",id:"reliability-guarantees",level:3},{value:"Determinism",id:"determinism",level:3},{value:"Workflow Identity",id:"workflow-identity",level:3},{value:"Asynchronous Workflows",id:"asynchronous-workflows",level:3},{value:"Further Reading",id:"further-reading",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In this guide, you'll learn how to make your applications reliable using workflows."}),"\n",(0,t.jsxs)(n.p,{children:["Workflows orchestrate the execution of other functions, like transactions and communicators.\nWorkflows are ",(0,t.jsx)(n.em,{children:"reliable"}),": if their execution is interrupted for any reason (e.g., an executor is restarted or crashes), DBOS automatically resumes them from where they left off, running them to completion without re-executing any operation that already finished.\nYou can use workflows to coordinate multiple operations that must all complete for a program to be correct.\nFor example, in our ",(0,t.jsx)(n.a,{href:"https://github.com/dbos-inc/dbos-demo-apps/tree/main/e-commerce",children:"e-commerce demo"}),", we use a workflow for payment processing."]}),"\n",(0,t.jsxs)(n.p,{children:["Workflows must be annotated with the ",(0,t.jsx)(n.a,{href:"../api-reference/decorators#workflow",children:(0,t.jsx)(n.code,{children:"@Workflow"})})," decorator and must have a ",(0,t.jsx)(n.a,{href:"../api-reference/contexts#workflowcontext",children:(0,t.jsx)(n.code,{children:"WorkflowContext"})})," as their first argument.\nLike for other functions, inputs and outputs must be serializable to JSON.\nAdditionally, workflows must be ",(0,t.jsx)(n.a,{href:"#determinism",children:"deterministic"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Here's an example workflow (from the ",(0,t.jsx)(n.a,{href:"/getting-started/quickstart-programming",children:"programming quickstart"}),") sending an email then recording it in the database.\nBy using a workflow, we guarantee that every email is recorded in the database, even if execution is interrupted."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'class Greetings {\n\n  // Other function implementations\n\n    @Workflow()\n    @GetApi("/greeting/:friend")\n    static async GreetingWorkflow(ctxt: WorkflowContext, friend: string) {\n        const noteContent = `Thank you for being awesome, ${friend}!`;\n        await ctxt.invoke(Greetings).SendGreetingEmail(friend, noteContent);\n        await ctxt.invoke(Greetings).InsertGreeting(friend, noteContent);\n        ctxt.logger.info(`Greeting sent to ${friend}!`);\n        return noteContent;\n    }\n\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"invoking-functions-from-workflows",children:"Invoking Functions from Workflows"}),"\n",(0,t.jsxs)(n.p,{children:["Workflows can invoke transactions and communicators using their ",(0,t.jsx)(n.a,{href:"../api-reference/contexts#workflowctxtinvoke",children:(0,t.jsx)(n.code,{children:"ctxt.invoke()"})})," method.\nFor example, this line from our above example invokes the transaction ",(0,t.jsx)(n.code,{children:"InsertGreeting"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"await ctxt.invoke(Greetings).InsertGreeting(friend, noteContent);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The syntax for invoking function ",(0,t.jsx)(n.code,{children:"fn(args)"})," in class ",(0,t.jsx)(n.code,{children:"Cls"})," is ",(0,t.jsx)(n.code,{children:"ctxt.invoke(Cls).fn(args)"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["You can also invoke other workflows with the ",(0,t.jsx)(n.a,{href:"../api-reference/contexts#workflowctxtinvokechildworkflow",children:(0,t.jsx)(n.code,{children:"ctxt.invokeChildWorkflow()"})})," method.\nThe syntax for invoking child workflow ",(0,t.jsx)(n.code,{children:"wf"})," in class ",(0,t.jsx)(n.code,{children:"Cls"})," with argument ",(0,t.jsx)(n.code,{children:"arg"})," is:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const output = await ctxt.invokeChildWorkflow(Cls.wf, arg);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"reliability-guarantees",children:"Reliability Guarantees"}),"\n",(0,t.jsx)(n.p,{children:"Workflows provide the following reliability guaranteees:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"They always run to completion.  If execution of a workflow is interrupted, DBOS resumes it from where it left off."}),"\n",(0,t.jsxs)(n.li,{children:["Transactions execute ",(0,t.jsx)(n.em,{children:"exactly once"}),".  Regardless of what failures occur during a workflow's execution, it executes each of its transactions once and only once."]}),"\n",(0,t.jsxs)(n.li,{children:["Communicators execute ",(0,t.jsx)(n.em,{children:"at least once"})," but are never re-executed after they successfully complete.  If a failure occurs inside a communicator, the communicator may be retried, but once a communicator has completed, it will never be re-executed."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"determinism",children:"Determinism"}),"\n",(0,t.jsxs)(n.p,{children:["Workflows must be deterministic: if called multiple times with the same inputs, they should always do the same thing.\nIf you need to perform a non-deterministic operation like accessing the database, calling a third-party API, generating a random number, or getting the local time, you shouldn't do it directly in a workflow function.\nInstead, you should do all database operations in ",(0,t.jsx)(n.a,{href:"./transaction-tutorial",children:"transactions"})," and all other non-deterministic operations in ",(0,t.jsx)(n.a,{href:"./communicator-tutorial",children:"communicators"}),".\nYou can safely ",(0,t.jsx)(n.a,{href:"/api-reference/contexts#workflowctxtinvoke",children:"invoke"})," these methods from a workflow."]}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["It's important to call non-deterministic operations (particularly third-party APIs) from ",(0,t.jsx)(n.a,{href:"./communicator-tutorial",children:"communicators"})," so DBOS knows to retry them safely."]})}),"\n",(0,t.jsx)(n.h3,{id:"workflow-identity",children:"Workflow Identity"}),"\n",(0,t.jsxs)(n.p,{children:["Every time you execute a workflow, that execution is assigned a unique identity, represented as a ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Universally_unique_identifier",children:"UUID"}),".\nYou can access this UUID through the ",(0,t.jsx)(n.code,{children:"context.workflowUUID"})," field.\nWorkflow identities are important for communicating with workflows and developing interactive workflows.\nThey are also used to uniquely identify an execution to ",(0,t.jsx)(n.a,{href:"/cloud-tutorials/timetravel-debugging",children:"time travel debug"})," it.\nFor more information on workflow communication, see ",(0,t.jsx)(n.a,{href:"/tutorials/workflow-communication-tutorial",children:"our guide"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"asynchronous-workflows",children:"Asynchronous Workflows"}),"\n",(0,t.jsxs)(n.p,{children:["Because workflows are often long-running, DBOS supports starting workflows asynchronously without waiting for them to complete.\nWhen you start a workflow from a handler or another workflow with ",(0,t.jsx)(n.a,{href:"/api-reference/contexts#handlerctxtstartworkflow",children:(0,t.jsx)(n.code,{children:"handlerCtxt.startWorkflow"})})," or ",(0,t.jsx)(n.a,{href:"/api-reference/contexts#workflowctxtstartchildworkflow",children:(0,t.jsx)(n.code,{children:"workflowCtxt.startChildWorkflow"})}),", the invocation returns a ",(0,t.jsx)(n.a,{href:"../api-reference/workflow-handles",children:"workflow handle"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"  @GetApi(...)\n  static async exampleHandler(handlerCtxt: HandlerContext, ...) {\n    const handle = await handlerCtxt.startWorkflow(Class).workflow(...);\n  }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Calls to start a workflow resolve as soon as the handle is safely created; at this point the workflow is guaranteed to ",(0,t.jsx)(n.a,{href:"/tutorials/workflow-tutorial#reliability-guarantees",children:"run to completion"}),".\nThis behavior is useful if you need to quickly acknowledge receipt of an event then process it asynchronously (for example, in a webhook)."]}),"\n",(0,t.jsx)(n.p,{children:"You can also retrieve another workflow's handle using its identity:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"  @GetApi(...)\n  static async exampleHandler(ctxt: HandlerContext, workflowIdentity: string, ...) {\n    const handle = await ctxt.retrieveWorkflow(workflowIdentity);\n  }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To wait for a workflow to complete and retrieve its result, await ",(0,t.jsx)(n.code,{children:"handle.getResult()"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const handle = await ctxt.retrieveWorkflow(workflowIdentity)\nconst result = await handle.getResult();\n"})}),"\n",(0,t.jsxs)(n.p,{children:["For more information on workflow handles, see ",(0,t.jsx)(n.a,{href:"../api-reference/workflow-handles",children:"their reference page"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(n.p,{children:["To learn how to make workflows (or other functions) idempotent, see ",(0,t.jsx)(n.a,{href:"./idempotency-tutorial",children:"our idempotency guide"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["To learn how to make workflows interactive (for example, to handle user input), see our ",(0,t.jsx)(n.a,{href:"./workflow-communication-tutorial",children:"workflow communication guide"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},1151:(e,n,o)=>{o.d(n,{Z:()=>s,a:()=>a});var t=o(7294);const r={},i=t.createContext(r);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);