"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[1455],{2452:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>w,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var o=r(4848),n=r(8453);const s={sidebar_position:6,title:"Workflow Handles",description:"API reference for workflow handles"},i=void 0,l={id:"typescript/reference/workflow-handles",title:"Workflow Handles",description:"API reference for workflow handles",source:"@site/docs/typescript/reference/workflow-handles.md",sourceDirName:"typescript/reference",slug:"/typescript/reference/workflow-handles",permalink:"/typescript/reference/workflow-handles",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"Workflow Handles",description:"API reference for workflow handles"},sidebar:"tutorialSidebar",previous:{title:"Testing Runtime",permalink:"/typescript/reference/testing-runtime"},next:{title:"Package Library",permalink:"/typescript/reference/communicatorlib"}},a={},d=[{value:"Methods",id:"methods",level:3},{value:"<code>getStatus(): Promise&lt;WorkflowStatus&gt;</code>",id:"getstatus-promiseworkflowstatus",level:4},{value:"<code>getResult(): Promise&lt;R&gt;</code>",id:"getresult-promiser",level:4},{value:"<code>getWorkflowUUID(): string</code>",id:"getworkflowuuid-string",level:4},{value:"<code>getWorkflowInputs&lt;T extends any []&gt;(): Promise&lt;T&gt;</code>",id:"getworkflowinputst-extends-any--promiset",level:4}];function c(e){const t={a:"a",code:"code",h3:"h3",h4:"h4",hr:"hr",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["A workflow handle represents the state of a particular active or completed workflow execution.\nA workflow handle is obtained when a handler ",(0,o.jsx)(t.a,{href:"../tutorials/workflow-tutorial#asynchronous-workflows",children:"starts a workflow"})," with ",(0,o.jsx)(t.a,{href:"/typescript/reference/contexts#handlerctxtstartworkflow",children:(0,o.jsx)(t.code,{children:"handlerCtxt.startWorkflow"})})," or a workflow starts a child workflow with ",(0,o.jsx)(t.a,{href:"/typescript/reference/contexts#workflowctxtstartworkflow",children:(0,o.jsx)(t.code,{children:"workflowCtxt.startWorkflow"})}),".\nAdditionally, a handler or workflow can retrieve a workflow handle by calling ",(0,o.jsx)(t.a,{href:"./contexts#handlerctxtretrieveworkflow",children:(0,o.jsx)(t.code,{children:"ctxt.retrieveWorkflow"})})," with the workflow's ",(0,o.jsx)(t.a,{href:"../tutorials/workflow-tutorial#workflow-identity",children:"identity UUID"}),"."]}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsx)(t.h3,{id:"methods",children:"Methods"}),"\n",(0,o.jsx)(t.h4,{id:"getstatus-promiseworkflowstatus",children:(0,o.jsx)(t.code,{children:"getStatus(): Promise<WorkflowStatus>"})}),"\n",(0,o.jsx)(t.p,{children:"Retrieves the status of a workflow with the following structure:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"export interface WorkflowStatus {\n  readonly status: string; // The status of the workflow.  One of PENDING, SUCCESS, ERROR, RETRIES_EXCEEDED, or CANCELLED.\n  readonly workflowName: string; // The name of the workflow function.\n  readonly authenticatedUser: string; // The user who ran the workflow. Empty string if not set.\n  readonly assumedRole: string; // The role used to run this workflow.  Empty string if authorization is not required.\n  readonly authenticatedRoles: string[]; // All roles the authenticated user has, if any.\n  readonly request: HTTPRequest; // The parent request for this workflow, if any.\n}\n"})}),"\n",(0,o.jsx)(t.h4,{id:"getresult-promiser",children:(0,o.jsx)(t.code,{children:"getResult(): Promise<R>"})}),"\n",(0,o.jsx)(t.p,{children:"Waits for the workflow to complete then returns its output."}),"\n",(0,o.jsx)(t.h4,{id:"getworkflowuuid-string",children:(0,o.jsx)(t.code,{children:"getWorkflowUUID(): string"})}),"\n",(0,o.jsxs)(t.p,{children:["Retrieves the workflow's ",(0,o.jsx)(t.a,{href:"../tutorials/workflow-tutorial#workflow-identity",children:"identity UUID"}),", a string that uniquely identifies this workflow's execution."]}),"\n",(0,o.jsx)(t.h4,{id:"getworkflowinputst-extends-any--promiset",children:(0,o.jsx)(t.code,{children:"getWorkflowInputs<T extends any []>(): Promise<T>"})}),"\n",(0,o.jsx)(t.p,{children:"Retrieves the worklow's input argument array."})]})}function w(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>l});var o=r(6540);const n={},s=o.createContext(n);function i(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);