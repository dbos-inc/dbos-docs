"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[8933],{7742:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"typescript/prompting","title":"AI Model Prompting","description":"You may want assistance from an AI model in building a DBOS application.","source":"@site/docs/typescript/prompting.md","sourceDirName":"typescript","slug":"/typescript/prompting","permalink":"/typescript/prompting","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":30,"frontMatter":{"sidebar_position":30,"title":"AI Model Prompting"},"sidebar":"tutorialSidebar","previous":{"title":"Add DBOS To Your App","permalink":"/typescript/integrating-dbos"},"next":{"title":"Workflows","permalink":"/typescript/tutorials/workflow-tutorial"}}');var s=t(4848),a=t(8453);const r={sidebar_position:30,title:"AI Model Prompting"},i=void 0,c={},l=[{value:"How To Use",id:"how-to-use",level:2},{value:"Prompt",id:"prompt",level:2}];function u(n){const e={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.p,{children:"You may want assistance from an AI model in building a DBOS application.\nTo make sure your model has the latest information on how to use DBOS, provide it with this prompt."}),"\n",(0,s.jsx)(e.h2,{id:"how-to-use",children:"How To Use"}),"\n",(0,s.jsx)(e.p,{children:"First, use the click-to-copy button in the top right of the code block to copy the full prompt to your clipboard.\nThen, paste into your AI tool of choice (for example OpenAI's ChatGPT or Anthropic's Claude).\nThis adds the prompt to your AI model's context, giving it up-to-date instructions on how to build an application with DBOS."}),"\n",(0,s.jsx)(e.p,{children:"If you are using an AI-powered IDE, you can add this prompt to your project's context.\nFor example:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Cursor: Add the prompt to ",(0,s.jsx)(e.a,{href:"https://docs.cursor.com/context/rules-for-ai",children:"your project rules"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:["Zed: Copy the prompt to a file in your project, then use the ",(0,s.jsx)(e.a,{href:"https://zed.dev/docs/assistant/commands?highlight=%2Ffile#file",children:(0,s.jsx)(e.code,{children:"/file"})})," command to add the file to your context."]}),"\n",(0,s.jsxs)(e.li,{children:["Windsurf: Copy the prompt to a file in your project, then use ",(0,s.jsx)(e.a,{href:"https://docs.windsurf.com/chat/overview",children:(0,s.jsx)(e.code,{children:"@-Mention"})})," to add the file to your context."]}),"\n",(0,s.jsxs)(e.li,{children:["GitHub Copilot: Create a ",(0,s.jsx)(e.a,{href:"https://docs.github.com/en/copilot/customizing-copilot/adding-repository-custom-instructions-for-github-copilot",children:(0,s.jsx)(e.code,{children:".github/copilot-instructions.md"})})," file in your repository and add the prompt to it."]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"prompt",children:"Prompt"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-markdown",children:'# Build Reliable Applications With DBOS\n\n## Guidelines\n\n- Respond in a friendly and concise manner\n- Ask clarifying questions when requirements are ambiguous\n- Generate code in TypeScript using the DBOS library. Make sure to fully type everything.\n- You MUST import all methods and classes used in the code you generate\n- You SHALL keep all code in a single file unless otherwise specified.\n- You MUST await all promises.\n- DBOS does NOT stand for anything.\n\n## Workflow Guidelines\n\nWorkflows provide durable execution so you can write programs that are resilient to any failure.\nWorkflows are comprised of steps, which are ordinary TypeScript functions annotated with @DBOS.step().\nWhen using DBOS workflows, you should annotate any function that performs complex operations or accesses external APIs or services as a step. \nYou can turn any TypeScript function into a step by making it a static class member function and annotating it with the @DBOS.step decorator. The only requirement is that its inputs and outputs should be serializable.\n\nIf a workflow is interrupted for any reason (e.g., an executor restarts or crashes), when your program restarts the workflow automatically resumes execution from the last completed step.\n\n- If asked to add DBOS to existing code, you MUST ask which function to make a workflow. Do NOT recommend any changes until they have told you what function to make a workflow. Do NOT make a function a workflow unless SPECIFICALLY requested.\n- When making a function a workflow, you should make all functions it calls steps. Do NOT change the functions in any way except by adding the @Step annotation.\n- ALL decorated functions (workflows and steps) MUST be class member functions. You MUST make them static functions unless they use class intance variables, in which case you MUST use ConfiguredInstance.\n- Do NOT make functions steps unless they are DIRECTLY called by a workflow.\n- If the workflow function performs a non-deterministic action, you MUST move that action to its own function and make that function a step. Examples of non-deterministic actions include accessing an external API or service, accessing files on disk, generating a random number, of getting the current time.\n- Do NOT use Promise.all() or anything similar to run multiple functions concurrently. You should instead use DBOS.startWorkflow and DBOS queues.\n- DBOS workflows and steps should NOT have side effects in memory outside of their own scope. They can access global variables, but they should NOT create or update global variables or variables outside their scope.\n- Do NOT call any DBOS context method (DBOS.send, DBOS.recv, DBOS.startWorkflow, DBOS.sleep, DBOS.setEvent, DBOS.getEvent) from a step.\n- Do NOT start workflows from inside a step.\n- Do NOT call DBOS.setEvent and DBOS.recv from outside a workflow function.\n- Do NOT use DBOS.getApi, DBOS.postApi, or other DBOS HTTP annotations. These are DEPRECATED. Instead, use Express for HTTP serving by default, unless another web framework is specified.\n\n## DBOS Lifecycle Guidelines\n\nFor a DBOS program to compile, you MUST enable TypeScript decorators in your tsconfig.json file.\nYou MUST recommend this when adding DBOS to a new program or if they encounter compilation issues related to decorators.\n\n```json\n  "compilerOptions": {\n    "experimentalDecorators": true,\n  }\n```\n\nAny DBOS program MUST call DBOS.setConfig and DBOS.launch in its main function, like so.\nYou MUST use this default configuration (changing the name as appropriate) unless otherwise specified.\n\n```javascript\nDBOS.setConfig({\n    "name": "dbos-starter",\n    "databaseUrl": process.env.DBOS_DATABASE_URL\n});\nawait DBOS.launch();\n```\n\nHere is an example main function using Express:\n\n```javascript\nimport { DBOS } from "@dbos-inc/dbos-sdk";\n\nasync function main() {\n  DBOS.setConfig({\n    "name": "dbos-starter",\n    "databaseUrl": process.env.DBOS_DATABASE_URL\n  });\n  await DBOS.launch({ expressApp: app });\n  const PORT = 3000;\n  app.listen(PORT, () => {\n    console.log(`\ud83d\ude80 Server is running on http://localhost:${PORT}`);\n  });\n}\n\nmain().catch(console.log);\n```\n\n## Workflow and Steps Examples\n\nSimple example:\n\n\n```javascript\nimport { DBOS } from "@dbos-inc/dbos-sdk";\n\nexport class Example {\n\n  @DBOS.step()\n  static async stepOne() {\n    DBOS.logger.info("Step one completed!");\n  }\n\n  @DBOS.step()\n  static async stepTwo() {\n    DBOS.logger.info("Step two completed!");\n  }\n\n  @DBOS.workflow()\n  static async exampleWorkflow() {\n    await Example.stepOne();\n    await Example.stepTwo();\n  }\n}\n\nasync function main() {\n  DBOS.setConfig({\n    "name": "dbos-starter",\n    "databaseUrl": process.env.DBOS_DATABASE_URL\n  });\n  await DBOS.launch();\n  await Example.exampleWorkflow();\n  await DBOS.shutdown();\n}\n\nmain().catch(console.log)\n```\n\nExample with Express:\n\n```javascript\nimport { DBOS } from "@dbos-inc/dbos-sdk";\nimport express from "express";\n\nexport const app = express();\napp.use(express.json());\n\nexport class Example {\n\n  @DBOS.step()\n  static async stepOne() {\n    DBOS.logger.info("Step one completed!");\n  }\n\n  @DBOS.step()\n  static async stepTwo() {\n    DBOS.logger.info("Step two completed!");\n  }\n\n  @DBOS.workflow()\n  static async exampleWorkflow() {\n    await Example.stepOne();\n    await Example.stepTwo();\n  }\n}\n\napp.get("/", async (req, res) => {\n  await Example.exampleWorkflow();\n  res.send();\n});\n\nasync function main() {\n  DBOS.setConfig({\n    "name": "dbos-starter",\n    "databaseUrl": process.env.DBOS_DATABASE_URL\n  });\n  await DBOS.launch({ expressApp: app });\n  const PORT = 3000;\n  app.listen(PORT, () => {\n    console.log(`\ud83d\ude80 Server is running on http://localhost:${PORT}`);\n  });\n}\n\nmain().catch(console.log);\n```\n\nExample with queues:\n\n```javascript\nimport { DBOS, WorkflowQueue } from "@dbos-inc/dbos-sdk";\nimport express from "express";\n\nexport const app = express();\napp.use(express.json());\n\nconst queue = new WorkflowQueue("example_queue");\n\nexport class Example {\n\n  @DBOS.step()\n  static async taskStep(n: number) {\n    await DBOS.sleep(5000);\n    DBOS.logger.info(`Task ${n} completed!`)\n  }\n\n  @DBOS.workflow()\n  static async queueWorkflow() {\n    DBOS.logger.info("Enqueueing tasks!")\n    const handles = []\n    for (let i = 0; i < 10; i++) {\n      handles.push(await DBOS.startWorkflow(Example, { queueName: queue.name }).taskStep(i))\n    }\n    const results = []\n    for (const h of handles) {\n      results.push(await h.getResult())\n    }\n    DBOS.logger.info(`Successfully completed ${results.length} tasks`)\n  }\n}\n\napp.get("/", async (req, res) => {\n  await Example.queueWorkflow();\n  res.send();\n});\n\nasync function main() {\n  DBOS.setConfig({\n    "name": "dbos-starter",\n    "databaseUrl": process.env.DBOS_DATABASE_URL\n  });\n  await DBOS.launch({ expressApp: app });\n  const PORT = 3000;\n  app.listen(PORT, () => {\n    console.log(`\ud83d\ude80 Server is running on http://localhost:${PORT}`);\n  });\n}\n\nmain().catch(console.log);\n```\n\n#### Scheduled Workflow\n\nYou can schedule DBOS workflows to run exactly once per time interval. To do this, annotate the workflow with the @DBOS.scheduled decorator and specify the schedule in crontab syntax. For example:\n\n- A scheduled workflow MUST specify a crontab schedule.\n- It MUST take in two arguments, scheduled and actual time. Both are Date of when the workflow started.\n\n```javascript\n@DBOS.scheduled({ crontab: "* * * * *" })\n@DBOS.workflow()\nstatic async runEveryMinute(scheduledTime: Date, startTime: Date) {\n  DBOS.logger.info(`I am a scheduled workflow. It is currently ${scheduledTime}.`)\n}\n```\n\n\n## Workflow Documentation:\n\nIf an exception is thrown from a workflow, the workflow TERMINATES.\nDBOS records the exception, sets the workflow status to `ERROR`, and does not recover the workflow.\n\n## Workflow IDs\n\nEvery time you execute a workflow, that execution is assigned a unique ID, by default a UUID.\nYou can access this ID through the `DBOS.workflowID` context variable.\n\nSet the workflow ID of a workflow with `DBOS.withNextWorkflowID`.\nIf a workflow is called multiple times with the same ID, it executes ONLY ONCE.\n\n```javascript\nclass Example {\n  @DBOS.workflow()\n  static async exampleWorkflow(var1: string, var2: string) {\n      return var1 + var2;\n  }\n}\n\nconst workflowID = "my-workflow-id"\n\nawait DBOS.withNextWorkflowID(workflowID, async () => {\n  return await Example.exampleWorkflow("one", "two");\n});\n```\n\nYou can use `DBOS.startWorkflow` to start a workflow in the background without waiting for it to complete.\nThis is useful for long-running or interactive workflows.\n\n`startWorkflow` returns a workflow handle, from which you can access information about the workflow or wait for it to complete and retrieve its result.\nThe `startWorkflow` method resolves after the handle is durably created; at this point the workflow is guaranteed to run to completion even if the app is interrupted.\n\nNEVER start a workflow from inside a step.\n\nHere\'s an example:\n\n```javascript\nclass Example {\n    @DBOS.workflow()\n    static async exampleWorkflow(var1: string, var2: string) {\n        return var1 + var2;\n    }\n}\n\nasync function main() {\n    // Start exampleWorkflow in the background\n    const handle = await DBOS.startWorkflow(Example).exampleWorkflow("one", "two");\n    // Wait for the workflow to complete and return its results\n    const result = await handle.getResult();\n}\n```\n\nYou can also use DBOS.retrieveWorkflow to retrieve a workflow\'s handle from its ID.\n\n## Workflow Events\n\nWorkflows can emit _events_, which are key-value pairs associated with the workflow\'s ID.\nThey are useful for publishing information about the state of an active workflow, for example to transmit information to the workflow\'s caller.\n\n#### setEvent\n\nAny workflow can call `DBOS.setEvent` to publish a key-value pair, or update its value if has already been published.\nONLY call this from a workflow function, NEVER from a step.\n\n```typescript\nDBOS.setEvent<T>(key: string, value: T): Promise<void>\n```\n#### getEvent\n\nYou can call `DBOS.getEvent` to retrieve the value published by a particular workflow identity for a particular key.\nIf the event does not yet exist, this call waits for it to be published, returning `None` if the wait times out.\nNEVER call this from inside a step.\n\n```typescript\nDBOS.getEvent<T>(workflowID: string, key: string, timeoutSeconds?: number): Promise<T | null>\n```\n\n#### Events Example\n\nEvents are especially useful for writing interactive workflows that communicate information to their caller.\nFor example, in one demo, the checkout workflow, after validating an order, needs to send the customer a unique payment ID.\nTo communicate the payment ID to the customer, it uses events.\n\nThe payments workflow emits the payment ID using `setEvent()`:\n\n```javascript\n  @DBOS.workflow()\n  static async checkoutWorkflow(...): Promise<void> {\n    ...\n    const paymentsURL = ...\n    await DBOS.setEvent(PAYMENT_URL, paymentsURL);\n    ... \n  }\n```\n\nThe Express handler that originally started the workflow uses `getEvent()` to await this payment ID, then returns it:\n\n```javascript\nstatic async webCheckout(...): Promise<void> {\nconst handle = await DBOS.startWorkflow(Shop).checkoutWorkflow(...);\nconst paymentID = await DBOS.getEvent<string>(handle.workflowID, PAYMENT_ID_EVENT);\n  if (paymentID === null) {\n    DBOS.logger.error(\'checkout failed\');\n    return reply.code(500).send(\'Error starting checkout\');\n  }\n  return paymentID;\n}\n```\n\n## Workflow Messaging and Notifications\nYou can send messages to a specific workflow ID.\nThis is useful for sending notifications to an active workflow.\n\n#### Send\n\nYou can call `DBOS.send()` to send a message to a workflow.\nMessages can optionally be associated with a topic and are queued on the receiver per topic.\nNEVER call this from a step.\n\n```typescript\nDBOS.send<T>(destinationID: string, message: T, topic?: string): Promise<void>;\n```\n\n#### Recv\n\nWorkflows can call `DBOS.recv()` to receive messages sent to them, optionally for a particular topic.\nEach call to `recv()` waits for and consumes the next message to arrive in the queue for the specified topic, returning `None` if the wait times out.\nIf the topic is not specified, this method only receives messages sent without a topic.\nONLY call this from inside a workflow function, NEVER from a step.\n\n```typescript\nDBOS.recv<T>(topic?: string, timeoutSeconds?: number): Promise<T | null>\n```\n\n#### Messages Example\n\nMessages are especially useful for sending notifications to a workflow.\nFor example, in one demo, the checkout workflow, after redirecting customers to a payments page, must wait for a notification that the user has paid.\n\nTo wait for this notification, the payments workflow uses `recv()`, executing failure-handling code if the notification doesn\'t arrive in time:\n\n```javascript\n@DBOS.workflow()\nstatic async checkoutWorkflow(...): Promise<void> {\n  ...\n  const notification = await DBOS.recv<string>(PAYMENT_STATUS, timeout);\n  if (notification) {\n      ... // Handle the notification.\n  } else {\n      ... // Handle a timeout.\n  }\n}\n```\n\nAn endpoint waits for the payment processor to send the notification, then uses `send()` to forward it to the workflow:\n\n```javascript\n@DBOS.postApi(\'/payment_webhook\')\nstatic async paymentWebhook(): Promise<void> {\n  const notificationMessage = ... // Parse the notification.\n  const workflowID = ... // Retrieve the workflow ID from notification metadata.\n  await DBOS.send(workflow_id, notificationMessage, PAYMENT_STATUS);\n}\n```\n\n### Durable Sleep\n\nWithin a DBOS workflow, waiting or sleeping should not be done using standard system functions, as these will not be skipped on workflow replay.  Instead, the "durable sleep" functions below should be used.  The wakeup time will be stored in the database when the function is first called, and if the workflow is re-executed, it will not oversleep.\n\n```typescript\nDBOS.sleep(durationMS: number): Promise<void>\n```\n\n* DBOS.sleep: sleep for `durationMS` milliseconds.\n\nThese functions work in any context, and will use the system sleep if no workflow is in progress.\n\n### Configurable Retries\n\nYou can optionally configure a step to automatically retry any exception a set number of times with exponential backoff.\nThis is useful for automatically handling transient failures, like making requests to unreliable APIs.\nRetries are configurable through arguments to the step decorator:\n\n```typescript\nexport interface StepConfig {\n  retriesAllowed?: boolean; // Should failures be retried? (default false)\n  intervalSeconds?: number; // Seconds to wait before the first retry attempt (default 1).\n  maxAttempts?: number;     // Maximum number of retry attempts (default 3). If errors occur more times than this, throw an exception.\n  backoffRate?: number;     // Multiplier by which the retry interval increases after a retry attempt (default 2).\n}\n```\n\nFor example, let\'s configure this step to retry exceptions (such as if `example.com` is temporarily down) up to 10 times:\n\n```javascript\n  @DBOS.step({retriesAllowed=true, maxAttempts: 10})\n  static async exampleStep() {\n    return await fetch("https://example.com").then(r => r.text());\n  }\n```\n\n### DBOS Queues\n\n\nQueues allow you to run functions with managed concurrency.\nThey are useful for controlling the number of functions run in parallel, or the rate at which functions are started.\n\nTo create a queue, specify its name:\n\n```javascript\nimport { DBOS, WorkflowQueue } from "@dbos-inc/dbos-sdk";\n\nconst queue = new WorkflowQueue("example_queue");\n```\n\nYou can then enqueue any DBOS workflow, step, or transaction.\nEnqueuing a function submits it for execution and returns a handle to it.\nQueued tasks are started in first-in, first-out (FIFO) order.\n\n```javascript\nconst queue = new WorkflowQueue("example_queue");\n\nclass Tasks {\n  @DBOS.workflow()\n  static async processTask(task) {\n    // ...\n  }\n}\n\nasync function main() {\n  const task = ...\n  const handle = await DBOS.startWorkflow(Tasks, {queueName: queue.name}).processTask(task)\n}\n```\n\n### Queue Example\n\nHere\'s an example of a workflow using a queue to process tasks concurrently:\n\n```javascript\nconst queue = new WorkflowQueue("example_queue");\n\nclass Tasks {\n  @DBOS.workflow()\n  static async processTask(task) {\n    // ...\n  }\n\n  @DBOS.workflow()\n  static async processTasks(tasks) {\n    const handles = []\n\n    // Enqueue each task so all tasks are processed concurrently.\n    for (const task of tasks) {\n      handles.push(await DBOS.startWorkflow(Tasks, {queueName: queue.name}).processTask(task));\n    }\n\n    // Wait for each task to complete and retrieve its result.\n    // Return the results of all tasks.\n    const results = [];\n    for (const h of handles) {\n      results.push(await h.getResult());\n    }\n    return results;\n  }\n}\n```\n\n\n### Managing Concurrency\n\nYou can specify the _concurrency_ of a queue, the maximum number of functions from this queue that may run concurrently, at two scopes: global and per process.\nGlobal concurrency limits are applied across all DBOS processes using this queue.\nPer process concurrency limits are applied to each DBOS process using this queue.\nIf no limit is provided, any number of functions may run concurrently.\nFor example, this queue has a maximum global concurrency of 10 and a per process maximum concurrency of 5, so at most 10 functions submitted to it may run at once, up to 5 per process:\n\n```javascript\nimport { DBOS, WorkflowQueue } from "@dbos-inc/dbos-sdk";\n\nconst queue = new WorkflowQueue("example_queue", { concurrency: 10, workerConcurrency: 5 });\n```\n\nYou may want to specify a maximum concurrency if functions in your queue submit work to an external process with limited resources.\nThe concurrency limit guarantees that even if many functions are submitted at once, they won\'t overwhelm the process.\n\n### Rate Limiting\n\nYou can set _rate limits_ for a queue, limiting the number of functions that it can start in a given period.\nRate limits are global across all DBOS processes using this queue.\nFor example, this queue has a limit of 50 with a period of 30 seconds, so it may not start more than 50 functions in 30 seconds:\n\n```javascript\nconst queue = new WorkflowQueue("example_queue", { rateLimit: { limitPerPeriod: 50, periodSec: 30 } });\n```\n\n\nRate limits are especially useful when working with a rate-limited API, such as many LLM APIs.\n\n### In-Order Processing\n\nYou can use a queue with `concurrency=1` to guarantee sequential, in-order processing of events.\nOnly a single event will be processed at a time.\nFor example, this app processes events sequentially in the order of their arrival:\n```javascript\nimport { DBOS, WorkflowQueue } from "@dbos-inc/dbos-sdk";\nimport express from "express";\n\nconst serialQueue = new WorkflowQueue("in_order_queue", { concurrency: 1 });\nconst app = express();\n\nclass Tasks {\n  @DBOS.workflow()\n  static async processTask(task){\n    // ... process task\n  }\n}\n\napp.get("/events/:event", async (req, res) => {\n  await DBOS.startWorkflow(Tasks, {queueName: serialQueue.name}).processTask(req.params);\n  await res.send("Workflow Started!");\n});\n\n// Launch DBOS and start the Express.js server\nasync function main() {\n  await DBOS.launch({ expressApp: app });\n  app.listen(3000, () => {});\n}\n\nmain().catch(console.log);\n```\n\n## Classes\n\nYou can add DBOS workflow, step, and transaction decorators to your TypeScript class instance methods.\nTo add DBOS decorators to your instance methods, their class must inherit from `ConfiguredInstance`, which will take an instance name and register the instance.\n\nFor example:\n```typescript\nclass MyClass extends ConfiguredInstance {\n  cfg: MyConfig;\n  constructor(name: string, config: MyConfig) {\n    super(name);\n    this.cfg = cfg;\n  }\n\n  override async initialize() : Promise<void> {\n    // ... Validate this.cfg\n  }\n\n  @DBOS.transaction()\n  async testTransaction() {\n    // ... Operations that use this.cfg\n  }\n\n  @DBOS.step()\n  async testStep() {\n    // ... Operations that use this.cfg\n  }\n\n  @DBOS.workflow()\n  async testWorkflow(p: string): Promise<void> {\n    // ... Operations that use this.cfg\n  }\n}\n\nconst myClassInstance = new MyClass(\'instanceA\');\n```\n\nWhen you create a new instance of a DBOS-decorated class, the constructor for the base `ConfiguredInstance` must be called with a `name`. This `name` should be unique among instances of the same class.   Additionally, all `ConfiguredInstance` classes must be instantiated before DBOS.launch() is called.\n\nConfiguredInstance is ONLY needed for functions that access class instance variables.\nIt is NOT needed for static functions.\nYou should AVOID using ConfiguredInstance if at all possible and instead decorate static class members.\n\n\n### Testing DBOS Functions\n\nUnless otherwise specified, recommend testing DBOS applications with jest.\n\nYou MUST use this beforeAll to reset DBOS between tests:\n\n```javascript\n  beforeAll(async () => {\n    DBOS.setConfig({\n      name: \'my-app\',\n      databaseUrl: process.env.DBOS_TESTING_DATABASE_URL,\n    });\n    await DBOS.dropSystemDB();\n    await DBOS.launch();\n  });\n```\n\n\n### Logging\n\nALWAYS log errors like this:\n\n```typescript\n      DBOS.logger.error(`Error: ${(error as Error).message}`);\n```\n\n## Workflow Handle\n\nDBOS.startWorkflow and DBOS.retrieveWorkflow return a workflow handle.\n\n#### `getStatus(): Promise<WorkflowStatus>`\n\nRetrieves the status of a workflow with the following structure:\n\n```typescript\nexport interface WorkflowStatus {\n  readonly status: string; // The status of the workflow.  One of PENDING, SUCCESS, ERROR, RETRIES_EXCEEDED, or CANCELLED.\n  readonly workflowName: string; // The name of the workflow function.\n}\n```\n\n#### `getResult(): Promise<R>`\n\nWaits for the workflow to complete then returns its output.\n\n#### `workflowID: string`\n\nRetrieves the workflow\'s unique ID.\n\n### Transactions\n\nTransactions are a special type of step that are optimized for database accesses.\nThey execute as a single database transaction.\n\nONLY use transactions if you are SPECIFICALLY requested to perform database operations, DO NOT USE THEM OTHERWISE.\n\nONLY use transactions with a Postgres database.\nTo access any other database, ALWAYS use steps.\n\nIf asked to add DBOS to code that already contains database operations, ALWAYS make it a step, do NOT attempt to make it a transaction unless requested.\n\nTo make a TypeScript function a transaction, annotate it with the DBOS.transaction decorator.\nThen, access the database with raw SQL or one of several supported ORMS, including Knex.js, Drizzle, TypeORM, and Prisma.\n\nIF AND ONLY IF you are using transactions, ALWAYS set the `userDbclient` field in your DBOS configuration to your ORM of choice. The options are knex, drizzle, typeorm, and prisma.\n\nFor example, for knex:\n\n```javascript\nDBOS.setConfig({\n  name: \'my-app\',\n  databaseUrl: process.env.DBOS_DATABASE_URL,\n  userDbclient: \'knex\',\n});\nawait DBOS.launch();\n```\n\nHere are some example transactions:\n\n#### Knex\n\n```javascript\ninterface GreetingRecord {\n  name: string;\n  note: string;\n}\n\nexport class Greetings {\n\n  @DBOS.transaction()\n  static async insertGreeting(gr: GreetingRecord) {\n    await DBOS.knexClient(\'greetings\').insert(gr);\n  }\n\n  @DBOS.transaction()\n  static async getGreetings(): Promise<GreetingRecord[]>  {\n    return await DBOS.knexClient<GreetingRecord>(\'greetings\').select(\'*\');\n  }\n}\n```\n\n#### Drizzle\n\n```javascript\nexport const GreetingRecord = pgTable(\'greetings\', {\n  name: text(\'name\'),\n  note: text(\'note\'),\n});\n\nfunction getClient() { return DBOS.drizzleClient as NodePgDatabase; }\n\n@OrmEntities({GreetingRecord})\nexport class Greetings {\n\n  @DBOS.transaction()\n  static async insertGreeting(name: string, note: string) {\n    await getClient().insert(GreetingRecord).values({name: name, note: note});\n  }\n\n  @DBOS.transaction()\n  static async getGreetings(): Promise<{name: string | null, note: string | null}[]> {\n    return getClient().select().from(GreetingRecord);\n  }\n}\n```\n\nWith workflows and express:\n\n```javascript\nimport { DBOS, } from "@dbos-inc/dbos-sdk";\nimport express from "express";\n\nexport const app = express();\napp.use(express.json());\n\nexport class Toolbox {\n  @DBOS.transaction()\n  static async insertRow() {\n    await DBOS.knexClient.raw(\'INSERT INTO example_table (name) VALUES (?)\', [\'dbos\']);\n  }\n\n  @DBOS.transaction({ readOnly: true })\n  static async countRows() {\n    const result = await DBOS.knexClient.raw(\'SELECT COUNT(*) as count FROM example_table\');\n    const count = result.rows[0].count;\n    DBOS.logger.info(`Row count: ${count}`);\n  }\n\n  @DBOS.workflow()\n  static async transactionWorkflow() {\n    await Toolbox.insertRow()\n    await Toolbox.countRows()\n  }\n}\n\napp.get("/", async (req, res) => {\n  await Toolbox.transactionWorkflow();\n  res.send();\n});\n\nasync function main() {\n  DBOS.setConfig({\n    "name": "dbos-starter",\n    "databaseUrl": process.env.DBOS_DATABASE_URL\n  });\n  await DBOS.launch({ expressApp: app });\n  const PORT = 3000;\n  app.listen(PORT, () => {\n    console.log(`\ud83d\ude80 Server is running on http://localhost:${PORT}`);\n  });\n}\n\nmain().catch(console.log);\n```\n\n\n\n'})})]})}function p(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(u,{...n})}):u(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>i});var o=t(6540);const s={},a=o.createContext(s);function r(n){const e=o.useContext(a);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),o.createElement(a.Provider,{value:e},n.children)}}}]);