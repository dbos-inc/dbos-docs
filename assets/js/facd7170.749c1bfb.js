"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[8036],{8255:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"python/tutorials/upgrading-workflows","title":"Upgrading Workflow Code","description":"One challenge you may encounter when operating long-running durable workflows in production is how to deploy breaking changes without disrupting in-progress workflows.","source":"@site/docs/python/tutorials/upgrading-workflows.md","sourceDirName":"python/tutorials","slug":"/python/tutorials/upgrading-workflows","permalink":"/python/tutorials/upgrading-workflows","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":65,"frontMatter":{"sidebar_position":65,"title":"Upgrading Workflow Code","toc_max_heading_level":3},"sidebar":"tutorialSidebar","previous":{"title":"Workflow Management","permalink":"/python/tutorials/workflow-management"},"next":{"title":"Scheduling Workflows","permalink":"/python/tutorials/scheduled-workflows"}}');var t=o(4848),s=o(8453);const a={sidebar_position:65,title:"Upgrading Workflow Code",toc_max_heading_level:3},i=void 0,c={},l=[{value:"Patching",id:"patching",level:2},{value:"Deprecating and Removing Patches",id:"deprecating-and-removing-patches",level:3},{value:"How Patching Works",id:"how-patching-works",level:3},{value:"Versioning",id:"versioning",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["One challenge you may encounter when operating long-running durable workflows in production is ",(0,t.jsx)(n.strong,{children:"how to deploy breaking changes without disrupting in-progress workflows."}),"\nA breaking change to a workflow is any change in what steps run or the order in which steps run.\nThe issue is that if a breaking change was made to a workflow, the checkpoints created by a workflow that started on the previous version of the code may not match the steps called by the workflow in the new version of the code, which makes the workflow difficult to recover."]}),"\n",(0,t.jsxs)(n.p,{children:["DBOS supports two strategies for safely upgrading workflow code: ",(0,t.jsx)(n.strong,{children:"patching"})," and ",(0,t.jsx)(n.strong,{children:"versioning"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"patching",children:"Patching"}),"\n",(0,t.jsxs)(n.p,{children:["When using patching, you use ",(0,t.jsx)(n.a,{href:"/python/reference/contexts#patch",children:(0,t.jsx)(n.code,{children:"DBOS.patch()"})})," to make a breaking change in a conditional.\n",(0,t.jsx)(n.code,{children:"DBOS.patch()"})," returns ",(0,t.jsx)(n.code,{children:"True"})," for new workflows (those started after the breaking change) and ",(0,t.jsx)(n.code,{children:"False"})," for old workflows (those started before the breaking change).\nTherefore, if ",(0,t.jsx)(n.code,{children:"DBOS.patch()"})," is ",(0,t.jsx)(n.code,{children:"True"}),", call the new code, else, call the old code."]}),"\n",(0,t.jsx)(n.p,{children:"To use patching, you must enable it in configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'config: DBOSConfig = {\n    "name": "dbos-app",\n    "system_database_url": os.environ.get("DBOS_SYSTEM_DATABASE_URL"),\n    "enable_patching": True,\n}\nDBOS(config=config)\n'})}),"\n",(0,t.jsx)(n.p,{children:"For example, let's say our workflow is:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"@DBOS.workflow()\ndef workflow():\n  foo()\n  bar()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We want to replace the call to ",(0,t.jsx)(n.code,{children:"foo()"})," with a call to ",(0,t.jsx)(n.code,{children:"baz()"}),".\nThis is a breaking change because it changes what steps run.\nWe can make this breaking change safely using a patch:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'@DBOS.workflow()\ndef workflow():\n  if DBOS.patch("use-baz"):\n    baz()\n  else:\n    foo()\n  bar()\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Now, new workflows will run ",(0,t.jsx)(n.code,{children:"baz()"}),", while old workflows will safely continue through ",(0,t.jsx)(n.code,{children:"foo()"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"deprecating-and-removing-patches",children:"Deprecating and Removing Patches"}),"\n",(0,t.jsxs)(n.p,{children:["Patches don't need to stay in your code forever.\nOnce all workflows that started before you deployed the patch are complete, you can safely remove patches from your code.\nYou can use the ",(0,t.jsx)(n.a,{href:"/python/tutorials/workflow-management#listing-workflows",children:"list workflows APIs"})," to see what workflows are still active.\nFirst, you must deprecate the patch with ",(0,t.jsx)(n.a,{href:"/python/reference/contexts#deprecate_patch",children:(0,t.jsx)(n.code,{children:"DBOS.deprecate_patch()"})}),".\nThis safely runs all workflows that contain the patch marker, but does not insert the patch marker into new workflows.\nFor example, here's how to deprecate the patch above:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'@DBOS.workflow()\ndef workflow():\n  DBOS.deprecate_patch("use-baz")\n  baz()\n  bar()\n'})}),"\n",(0,t.jsx)(n.p,{children:"Then, when all workflows that started before you deprecated the patch are complete, you can remove the patch entirely:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"@DBOS.workflow()\ndef workflow():\n  baz()\n  bar()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If any mistakes happen during the process (a breaking change is not patched, or a patch is deprecated or removed prematurely), the workflow will throw a ",(0,t.jsx)(n.code,{children:"DBOSUnexpectedStepError"})," error clearly pointing to the step where the problem occurred."]}),"\n",(0,t.jsx)(n.h3,{id:"how-patching-works",children:"How Patching Works"}),"\n",(0,t.jsxs)(n.p,{children:["Under the hood, when you call ",(0,t.jsx)(n.code,{children:"DBOS.patch()"}),' from a workflow, it attempts to insert a "patch marker" at its current point in your workflow history (this is a new row in the ',(0,t.jsx)(n.code,{children:"operation_outputs"})," table in your database).\nIf it succesfully inserts the patch marker or if the patch marker is already present, then the workflow must be new (it started after the patch, or started before the patch but has not yet reached this point), so ",(0,t.jsx)(n.code,{children:"DBOS.patch()"})," returns ",(0,t.jsx)(n.code,{children:"True"}),".\nIf there is already a record present in this point in your workflow history, then the workflow must be old (it started before the patch and has already continued past this point), so ",(0,t.jsx)(n.code,{children:"DBOS.patch()"})," returns ",(0,t.jsx)(n.code,{children:"False"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["When you deprecate a patch with ",(0,t.jsx)(n.code,{children:"DBOS.deprecate_patch()"}),", new workflows no longer insert patch markers into their workflow history.\nHowever, if a workflow contains the patch marker in its history, it continues past that patch marker, safely ignoring it.\nOnce all workflows with patch markers are complete, you can safely remove the patch entirely."]}),"\n",(0,t.jsx)(n.h2,{id:"versioning",children:"Versioning"}),"\n",(0,t.jsxs)(n.p,{children:["When using versioning, DBOS ",(0,t.jsx)(n.strong,{children:"versions"})," applications and workflows.\nAll workflows are tagged with the application version on which they started.\nBy default, application version is automatically computed from a hash of workflow source code.\nHowever, you can set your own version through configuration."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'config: DBOSConfig = {\n    "name": "dbos-app",\n    "system_database_url": os.environ.get("DBOS_SYSTEM_DATABASE_URL"),\n    "application_version": "1.0.0",\n}\nDBOS(config=config)\n'})}),"\n",(0,t.jsx)(n.p,{children:"When DBOS tries to recover workflows, it only recovers workflows whose version matches the current application version.\nThis prevents unsafe recovery of workflows that depend on different code."}),"\n",(0,t.jsxs)(n.p,{children:["When using versioning, we recommend ",(0,t.jsx)(n.strong,{children:"blue-green"}),' code upgrades.\nWhen deploying a new version of your code, launch new processes running your new code version, but retain some processes running your old code version.\nDirect new traffic to your new processes while your old processes "drain" and complete all workflows of the old code version.\nThen, once all workflows of the old version are complete (you can use ',(0,t.jsx)(n.a,{href:"/python/reference/contexts#list_workflows",children:(0,t.jsx)(n.code,{children:"DBOS.list_workflows"})})," to check), you can retire the old code version."]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>i});var r=o(6540);const t={},s=r.createContext(t);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);