"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[6465],{2218:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"python/tutorials/workflow-tutorial","title":"Workflows","description":"Workflows provide durable execution so you can write programs that are resilient to any failure.","source":"@site/docs/python/tutorials/workflow-tutorial.md","sourceDirName":"python/tutorials","slug":"/python/tutorials/workflow-tutorial","permalink":"/python/tutorials/workflow-tutorial","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Workflows","toc_max_heading_level":3},"sidebar":"tutorialSidebar","previous":{"title":"AI Model Prompting","permalink":"/python/prompting"},"next":{"title":"Steps","permalink":"/python/tutorials/step-tutorial"}}');var r=t(4848),s=t(8453);const a={sidebar_position:1,title:"Workflows",toc_max_heading_level:3},i=void 0,l={},c=[{value:"Starting Workflows In The Background",id:"starting-workflows-in-the-background",level:2},{value:"Workflow IDs and Idempotency",id:"workflow-ids-and-idempotency",level:2},{value:"Determinism",id:"determinism",level:2},{value:"Workflow Timeouts",id:"workflow-timeouts",level:2},{value:"Durable Sleep",id:"durable-sleep",level:2},{value:"Workflow Events",id:"workflow-events",level:2},{value:"set_event",id:"set_event",level:4},{value:"get_event",id:"get_event",level:4},{value:"Events Example",id:"events-example",level:4},{value:"Reliability Guarantees",id:"reliability-guarantees",level:4},{value:"Workflow Messaging and Notifications",id:"workflow-messaging-and-notifications",level:2},{value:"Send",id:"send",level:4},{value:"Recv",id:"recv",level:4},{value:"Messages Example",id:"messages-example",level:4},{value:"Reliability Guarantees",id:"reliability-guarantees-1",level:4},{value:"Workflow Streaming",id:"workflow-streaming",level:2},{value:"Writing to Streams",id:"writing-to-streams",level:4},{value:"Reading from Streams",id:"reading-from-streams",level:4},{value:"Coroutine (Async) Workflows",id:"coroutine-async-workflows",level:2},{value:"Workflow Guarantees",id:"workflow-guarantees",level:2},{value:"Workflow Versioning and Recovery",id:"workflow-versioning-and-recovery",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Workflows provide ",(0,r.jsx)(n.strong,{children:"durable execution"})," so you can write programs that are ",(0,r.jsx)(n.strong,{children:"resilient to any failure"}),".\nWorkflows help you write fault-tolerant background tasks, data processing pipelines, AI agents, and more."]}),"\n",(0,r.jsxs)(n.p,{children:["You can make a function a workflow by annotating it with ",(0,r.jsx)(n.a,{href:"/python/reference/decorators#workflow",children:(0,r.jsx)(n.code,{children:"@DBOS.workflow()"})}),".\nWorkflows call ",(0,r.jsx)(n.a,{href:"/python/tutorials/step-tutorial",children:"steps"}),", which are Python functions annotated with ",(0,r.jsx)(n.a,{href:"/python/reference/decorators#step",children:(0,r.jsx)(n.code,{children:"@DBOS.step()"})}),".\nIf a workflow is interrupted for any reason, DBOS automatically recovers its execution from the last completed step."]}),"\n",(0,r.jsx)(n.p,{children:"Here's an example of a workflow:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@DBOS.step()\ndef step_one():\n    print("Step one completed!")\n\n@DBOS.step()\ndef step_two():\n    print("Step two completed!")\n\n@DBOS.workflow()\ndef workflow():\n    step_one()\n    step_two()\n'})}),"\n",(0,r.jsx)(n.h2,{id:"starting-workflows-in-the-background",children:"Starting Workflows In The Background"}),"\n",(0,r.jsxs)(n.p,{children:["One common use-case for workflows is building reliable background tasks that keep running even when the program is interrupted, restarted, or crashes.\nYou can use ",(0,r.jsx)(n.a,{href:"/python/reference/contexts#start_workflow",children:(0,r.jsx)(n.code,{children:"DBOS.start_workflow"})})," to start a workflow in the background.\nIf you start a workflow this way, it returns a ",(0,r.jsx)(n.a,{href:"/python/reference/workflow_handles",children:"workflow handle"}),", from which you can access information about the workflow or wait for it to complete and retrieve its result."]}),"\n",(0,r.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@DBOS.workflow()\ndef background_task(input):\n    # ...\n    return output\n\n# Start the background task\nhandle: WorkflowHandle = DBOS.start_workflow(background_task, input)\n# Wait for the background task to complete and retrieve its result.\noutput = handle.get_result()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["After starting a workflow in the background, you can use ",(0,r.jsx)(n.a,{href:"/python/reference/contexts#retrieve_workflow",children:(0,r.jsx)(n.code,{children:"DBOS.retrieve_workflow"})})," to retrieve a workflow's handle from its ID.\nYou can also retrieve a workflow's handle from outside of your DBOS application with ",(0,r.jsx)(n.a,{href:"/python/reference/client#retrieve_workflow",children:(0,r.jsx)(n.code,{children:"DBOSClient.retrieve_workflow"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If you need to run many workflows in the background and manage their concurrency or flow control, you can also use ",(0,r.jsx)(n.a,{href:"/python/tutorials/queue-tutorial",children:"DBOS queues"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"workflow-ids-and-idempotency",children:"Workflow IDs and Idempotency"}),"\n",(0,r.jsxs)(n.p,{children:["Every time you execute a workflow, that execution is assigned a unique ID, by default a ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Universally_unique_identifier",children:"UUID"}),".\nYou can access this ID through the ",(0,r.jsx)(n.a,{href:"/python/reference/contexts#workflow_id",children:(0,r.jsx)(n.code,{children:"DBOS.workflow_id"})})," context variable.\nWorkflow IDs are useful for communicating with workflows and developing interactive workflows."]}),"\n",(0,r.jsxs)(n.p,{children:["You can set the workflow ID of a workflow with ",(0,r.jsx)(n.a,{href:"/python/reference/contexts#setworkflowid",children:(0,r.jsx)(n.code,{children:"SetWorkflowID"})}),".\nWorkflow IDs must be ",(0,r.jsx)(n.strong,{children:"globally unique"})," for your application.\nAn assigned workflow ID acts as an idempotency key: if a workflow is called multiple times with the same ID, it executes only once.\nThis is useful if your operations have side effects like making a payment or sending an email.\nFor example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@DBOS.workflow()\ndef example_workflow():\n    DBOS.logger.info(f"I am a workflow with ID {DBOS.workflow_id}")\n\nwith SetWorkflowID("very-unique-id"):\n    example_workflow()\n'})}),"\n",(0,r.jsx)(n.h2,{id:"determinism",children:"Determinism"}),"\n",(0,r.jsxs)(n.p,{children:["Workflows are in most respects normal Python functions.\nThey can have loops, branches, conditionals, and so on.\nHowever, a workflow function must be ",(0,r.jsx)(n.strong,{children:"deterministic"}),": if called multiple times with the same inputs, it should invoke the same steps with the same inputs in the same order (given the same return values from those steps).\nIf you need to perform a non-deterministic operation like accessing the database, calling a third-party API, generating a random number, or getting the local time, you shouldn't do it directly in a workflow function.\nInstead, you should do all database operations in ",(0,r.jsx)(n.a,{href:"./transaction-tutorial",children:"transactions"})," and all other non-deterministic operations in ",(0,r.jsx)(n.a,{href:"/python/tutorials/step-tutorial",children:"steps"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, ",(0,r.jsx)(n.strong,{children:"don't do this"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@DBOS.workflow()\ndef example_workflow(friend: str):\n    body = requests.get("https://example.com").text\n    return example_transaction(body)\n'})}),"\n",(0,r.jsx)(n.p,{children:"Do this instead:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@DBOS.step()\ndef example_step():\n    return requests.get("https://example.com").text\n\n@DBOS.workflow()\ndef example_workflow(friend: str):\n    body = example_step()\n    return example_transaction(body)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"workflow-timeouts",children:"Workflow Timeouts"}),"\n",(0,r.jsxs)(n.p,{children:["You can set a timeout for a workflow with ",(0,r.jsx)(n.a,{href:"/python/reference/contexts#setworkflowtimeout",children:(0,r.jsx)(n.code,{children:"SetWorkflowTimeout"})}),".\nWhen the timeout expires, the workflow ",(0,r.jsx)(n.strong,{children:"and all its children"})," are cancelled.\nCancelling a workflow sets its status to ",(0,r.jsx)(n.code,{children:"CANCELLED"})," and preempts its execution at the beginning of its next step."]}),"\n",(0,r.jsxs)(n.p,{children:["Timeouts are ",(0,r.jsx)(n.strong,{children:"start-to-completion"}),": if a workflow is enqueued, the timeout does not begin until the workflow is dequeued and starts execution.\nAlso, timeouts are ",(0,r.jsx)(n.strong,{children:"durable"}),": they are stored in the database and persist across restarts, so workflows can have very long timeouts."]}),"\n",(0,r.jsx)(n.p,{children:"Example syntax:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@DBOS.workflow()\ndef example_workflow():\n    ...\n\n# If the workflow does not complete within 10 seconds, it times out and is cancelled\nwith SetWorkflowTimeout(10):\n    example_workflow()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"durable-sleep",children:"Durable Sleep"}),"\n",(0,r.jsxs)(n.p,{children:["You can use ",(0,r.jsx)(n.a,{href:"/python/reference/contexts#sleep",children:(0,r.jsx)(n.code,{children:"DBOS.sleep()"})})," to put your workflow to sleep for any period of time.\nThis sleep is ",(0,r.jsx)(n.strong,{children:"durable"}),"\u2014DBOS saves the wakeup time in the database so that even if the workflow is interrupted and restarted multiple times while sleeping, it still wakes up on schedule."]}),"\n",(0,r.jsx)(n.p,{children:"Sleeping is useful for scheduling a workflow to run in the future (even days, weeks, or months from now).\nFor example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@DBOS.workflow()\ndef schedule_task(time_to_sleep, task):\n  # Durably sleep for some time before running the task\n  DBOS.sleep(time_to_sleep)\n  run_task(task)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"workflow-events",children:"Workflow Events"}),"\n",(0,r.jsxs)(n.p,{children:["Workflows can emit ",(0,r.jsx)(n.em,{children:"events"}),", which are key-value pairs associated with the workflow's ID.\nThey are useful for publishing information about the state of an active workflow, for example to transmit information to the workflow's caller."]}),"\n",(0,r.jsx)(n.h4,{id:"set_event",children:"set_event"}),"\n",(0,r.jsxs)(n.p,{children:["Any workflow can call ",(0,r.jsx)(n.a,{href:"/python/reference/contexts#set_event",children:(0,r.jsx)(n.code,{children:"DBOS.set_event"})})," to publish a key-value pair, or update its value if has already been published."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"DBOS.set_event(\n    key: str,\n    value: Any,\n) -> None\n"})}),"\n",(0,r.jsx)(n.h4,{id:"get_event",children:"get_event"}),"\n",(0,r.jsxs)(n.p,{children:["You can call ",(0,r.jsx)(n.a,{href:"/python/reference/contexts#get_event",children:(0,r.jsx)(n.code,{children:"DBOS.get_event"})})," to retrieve the value published by a particular workflow identity for a particular key.\nIf the event does not yet exist, this call waits for it to be published, returning ",(0,r.jsx)(n.code,{children:"None"})," if the wait times out."]}),"\n",(0,r.jsxs)(n.p,{children:["You can also call ",(0,r.jsx)(n.a,{href:"/python/reference/client#get_event",children:(0,r.jsx)(n.code,{children:"get_event"})})," from outside of your DBOS application with ",(0,r.jsx)(n.a,{href:"/python/reference/client",children:"DBOS Client"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"DBOS.get_event(\n    workflow_id: str,\n    key: str,\n    timeout_seconds: float = 60,\n) -> None\n"})}),"\n",(0,r.jsx)(n.h4,{id:"events-example",children:"Events Example"}),"\n",(0,r.jsxs)(n.p,{children:["Events are especially useful for writing interactive workflows that communicate information to their caller.\nFor example, in the ",(0,r.jsx)(n.a,{href:"/python/examples/widget-store",children:"widget store demo"}),", the checkout workflow, after validating an order, needs to send the customer a unique payment ID.\nTo communicate the payment ID to the customer, it uses events."]}),"\n",(0,r.jsxs)(n.p,{children:["The payments workflow emits the payment ID using ",(0,r.jsx)(n.code,{children:"set_event()"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@DBOS.workflow()\ndef checkout_workflow():\n    ...\n    payment_id = ...\n    dbos.set_event(PAYMENT_ID, payment_id)\n    ...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The FastAPI handler that originally started the workflow uses ",(0,r.jsx)(n.code,{children:"get_event()"})," to await this payment ID, then returns it:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@app.post("/checkout/{idempotency_key}")\ndef checkout_endpoint(idempotency_key: str) -> Response:\n    # Idempotently start the checkout workflow in the background.\n    with SetWorkflowID(idempotency_key):\n        handle = DBOS.start_workflow(checkout_workflow)\n    # Wait for the checkout workflow to send a payment ID, then return it.\n    payment_id = DBOS.get_event(handle.workflow_id, PAYMENT_ID)\n    if payment_id is None:\n        raise HTTPException(status_code=404, detail="Checkout failed to start")\n    return Response(payment_id)\n'})}),"\n",(0,r.jsx)(n.h4,{id:"reliability-guarantees",children:"Reliability Guarantees"}),"\n",(0,r.jsxs)(n.p,{children:["All events are persisted to the database, so the latest version of an event is always retrievable.\nAdditionally, if ",(0,r.jsx)(n.code,{children:"get_event"})," is called in a workflow, the retrieved value is persisted in the database so workflow recovery can use that value, even if the event is later updated."]}),"\n",(0,r.jsx)(n.h2,{id:"workflow-messaging-and-notifications",children:"Workflow Messaging and Notifications"}),"\n",(0,r.jsx)(n.p,{children:"You can send messages to a specific workflow ID.\nThis is useful for sending notifications to an active workflow."}),"\n",(0,r.jsx)(n.h4,{id:"send",children:"Send"}),"\n",(0,r.jsxs)(n.p,{children:["You can call ",(0,r.jsx)(n.code,{children:"DBOS.send()"})," to send a message to a workflow.\nMessages can optionally be associated with a topic and are queued on the receiver per topic."]}),"\n",(0,r.jsxs)(n.p,{children:["You can also call ",(0,r.jsx)(n.a,{href:"/python/reference/client#send",children:(0,r.jsx)(n.code,{children:"send"})})," from outside of your DBOS application with ",(0,r.jsx)(n.a,{href:"/python/reference/client",children:"DBOS Client"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"DBOS.send(\n    destination_id: str,\n    message: Any,\n    topic: Optional[str] = None\n) -> None\n"})}),"\n",(0,r.jsx)(n.h4,{id:"recv",children:"Recv"}),"\n",(0,r.jsxs)(n.p,{children:["Workflows can call ",(0,r.jsx)(n.code,{children:"DBOS.recv()"})," to receive messages sent to them, optionally for a particular topic.\nEach call to ",(0,r.jsx)(n.code,{children:"recv()"})," waits for and consumes the next message to arrive in the queue for the specified topic, returning ",(0,r.jsx)(n.code,{children:"None"})," if the wait times out.\nIf the topic is not specified, this method only receives messages sent without a topic."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"DBOS.recv(\n    topic: Optional[str] = None,\n    timeout_seconds: float = 60,\n) -> Any\n"})}),"\n",(0,r.jsx)(n.h4,{id:"messages-example",children:"Messages Example"}),"\n",(0,r.jsxs)(n.p,{children:["Messages are especially useful for sending notifications to a workflow.\nFor example, in the ",(0,r.jsx)(n.a,{href:"/python/examples/widget-store",children:"widget store demo"}),", the checkout workflow, after redirecting customers to a payments page, must wait for a notification that the user has paid."]}),"\n",(0,r.jsxs)(n.p,{children:["To wait for this notification, the payments workflow uses ",(0,r.jsx)(n.code,{children:"recv()"}),", executing failure-handling code if the notification doesn't arrive in time:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@DBOS.workflow()\ndef checkout_workflow():\n  ... # Validate the order, then redirect customers to a payments service.\n  payment_status = DBOS.recv(PAYMENT_STATUS)\n  if payment_status is not None and payment_status == "paid":\n      ... # Handle a successful payment.\n  else:\n      ... # Handle a failed payment or timeout.\n'})}),"\n",(0,r.jsxs)(n.p,{children:["An endpoint waits for the payment processor to send the notification, then uses ",(0,r.jsx)(n.code,{children:"send()"})," to forward it to the workflow:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@app.post("/payment_webhook/{workflow_id}/{payment_status}")\ndef payment_endpoint(payment_id: str, payment_status: str) -> Response:\n    # Send the payment status to the checkout workflow.\n    DBOS.send(payment_id, payment_status, PAYMENT_STATUS)\n'})}),"\n",(0,r.jsx)(n.h4,{id:"reliability-guarantees-1",children:"Reliability Guarantees"}),"\n",(0,r.jsxs)(n.p,{children:["All messages are persisted to the database, so if ",(0,r.jsx)(n.code,{children:"send"})," completes successfully, the destination workflow is guaranteed to be able to ",(0,r.jsx)(n.code,{children:"recv"})," it.\nIf you're sending a message from a workflow, DBOS guarantees exactly-once delivery.\nIf you're sending a message from normal Python code, you can use ",(0,r.jsx)(n.a,{href:"/python/reference/contexts#setworkflowid",children:(0,r.jsx)(n.code,{children:"SetWorkflowID"})})," with an idempotency key to guarantee exactly-once execution."]}),"\n",(0,r.jsx)(n.h2,{id:"workflow-streaming",children:"Workflow Streaming"}),"\n",(0,r.jsx)(n.p,{children:"Workflows can stream data in real time to clients.\nThis is useful for streaming results from a long-running workflow or LLM call or for monitoring or progress reporting."}),"\n",(0,r.jsx)(n.h4,{id:"writing-to-streams",children:"Writing to Streams"}),"\n",(0,r.jsxs)(n.p,{children:["You can write values to a stream from a workflow or its steps using ",(0,r.jsx)(n.a,{href:"/python/reference/contexts#write_stream",children:(0,r.jsx)(n.code,{children:"DBOS.write_stream"})}),".\nA workflow may have any number of streams, each identified by a unique key."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"DBOS.write_stream(\n    key: str, \n    value: Any\n) -> None:\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When you are done writing to a stream, you should close it with ",(0,r.jsx)(n.a,{href:"/python/reference/contexts#close_stream",children:(0,r.jsx)(n.code,{children:"DBOS.close_stream"})}),".\nOtherwise, streams are automatically closed when the workflow terminates."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"DBOS.close_stream(\n    key: str\n) -> None\n"})}),"\n",(0,r.jsx)(n.p,{children:"DBOS streams are immutable and append-only:.\nWrites to a stream from a workflow happen exactly-once.\nWrites to a stream from a step happen at-least-once; if a step fails and is retried, it may write to the stream multiple times.\nReaders will see all values written to the stream from all tries of the step in the order in which they were written."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example syntax:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@DBOS.workflow()\ndef producer_workflow():\n    DBOS.write_stream(example_key, {"step": 1, "data": "value1"})\n    DBOS.write_stream(example_key, {"step": 2, "data": "value2"})\n    DBOS.close_stream(example_key)  # Signal completion\n'})}),"\n",(0,r.jsx)(n.h4,{id:"reading-from-streams",children:"Reading from Streams"}),"\n",(0,r.jsxs)(n.p,{children:["You can read values from a stream from anywhere using ",(0,r.jsx)(n.a,{href:"/python/reference/contexts#read_stream",children:(0,r.jsx)(n.code,{children:"DBOS.read_stream"})}),".\nThis function reads values from a stream identified by a workflow ID and key, yielding each value in order until the stream is closed or the workflow terminates."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"DBOS.read_stream(\n    workflow_id: str,\n    key: str\n) -> Generator[Any, Any, None]\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example syntax:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'for value in DBOS.read_stream(workflow_id, example_key):\n    print(f"Received: {value}")\n'})}),"\n",(0,r.jsx)(n.h2,{id:"coroutine-async-workflows",children:"Coroutine (Async) Workflows"}),"\n",(0,r.jsxs)(n.p,{children:["Coroutinues (functions defined with ",(0,r.jsx)(n.code,{children:"async def"}),", also known as async functions) can also be DBOS workflows.\nCoroutine workflows may invoke ",(0,r.jsx)(n.a,{href:"/python/tutorials/step-tutorial#coroutine-steps",children:"coroutine steps"})," via ",(0,r.jsx)(n.a,{href:"https://docs.python.org/3/reference/expressions.html#await",children:"await expressions"}),".\nYou should start coroutine workflows using ",(0,r.jsx)(n.a,{href:"/python/reference/contexts#start_workflow_async",children:(0,r.jsx)(n.code,{children:"DBOS.start_workflow_async"})})," and enqueue them using ",(0,r.jsx)(n.a,{href:"/python/reference/queues#enqueue_async",children:(0,r.jsx)(n.code,{children:"enqueue_async"})}),".\nCalling a coroutine workflow or starting it with ",(0,r.jsx)(n.code,{children:"DBOS.start_workflow_async"})," always runs it in the same event loop as its caller, but enqueueing it with ",(0,r.jsx)(n.code,{children:"enqueue_async"})," starts the workflow in a different event loop.\nAdditionally, coroutine workflows should use the asynchronous versions of the workflow ",(0,r.jsx)(n.a,{href:"#workflow-events",children:"event"})," and ",(0,r.jsx)(n.a,{href:"#workflow-messaging-and-notifications",children:"messaging and notification"})," context methods."]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["At this time, DBOS does not support coroutine ",(0,r.jsx)(n.a,{href:"/python/tutorials/transaction-tutorial",children:"transactions"}),".\nTo execute transaction functions without blocking the event loop, use ",(0,r.jsx)(n.a,{href:"https://docs.python.org/3/library/asyncio-task.html#asyncio.to_thread",children:(0,r.jsx)(n.code,{children:"asyncio.to_thread"})}),"."]})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@DBOS.step()\nasync def example_step():\n    async with aiohttp.ClientSession() as session:\n        async with session.get("https://example.com") as response:\n            return await response.text()\n\n@DBOS.workflow()\nasync def example_workflow(friend: str):\n    await DBOS.sleep_async(10)\n    body = await example_step()\n    result = await asyncio.to_thread(example_transaction, body)\n    return result\n'})}),"\n",(0,r.jsx)(n.h2,{id:"workflow-guarantees",children:"Workflow Guarantees"}),"\n",(0,r.jsx)(n.p,{children:"Workflows provide the following guarantees.\nThese guarantees assume that the application and database may crash and go offline at any point in time, but are always restarted and return online."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Workflows always run to completion.  If a DBOS process is interrupted while executing a workflow and restarts, it resumes the workflow from the last completed step."}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/python/tutorials/step-tutorial",children:"Steps"})," are tried ",(0,r.jsx)(n.em,{children:"at least once"})," but are never re-executed after they complete.  If a failure occurs inside a step, the step may be retried, but once a step has completed, it will never be re-executed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/python/tutorials/transaction-tutorial",children:"Transactions"})," commit ",(0,r.jsx)(n.em,{children:"exactly once"}),".  Once a workflow commits a transaction, it will never retry that transaction."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If an exception is thrown from a workflow, the workflow terminates\u2014DBOS records the exception, sets the workflow status to ",(0,r.jsx)(n.code,{children:"ERROR"}),", and does not recover the workflow.\nThis is because uncaught exceptions are assumed to be nonrecoverable.\nIf your workflow performs operations that may transiently fail (for example, sending HTTP requests to unreliable services), those should be performed in ",(0,r.jsx)(n.a,{href:"/python/tutorials/step-tutorial#configurable-retries",children:"steps with configured retries"}),".\nDBOS provides ",(0,r.jsx)(n.a,{href:"/python/tutorials/workflow-management",children:"tooling"})," to help you identify failed workflows and examine the specific uncaught exceptions."]}),"\n",(0,r.jsx)(n.h2,{id:"workflow-versioning-and-recovery",children:"Workflow Versioning and Recovery"}),"\n",(0,r.jsxs)(n.p,{children:["Because DBOS recovers workflows by re-executing them using information saved in the database, a workflow cannot safely be recovered if its code has changed since the workflow was started.\nTo guard against this, DBOS ",(0,r.jsx)(n.em,{children:"versions"})," applications and their workflows.\nWhen DBOS is launched, it computes an application version from a hash of the source code of its workflows (this can be overridden ",(0,r.jsxs)(n.a,{href:"/python/reference/configuration",children:["through the ",(0,r.jsx)(n.code,{children:"application_version"})," configuration parameter"]}),").\nAll workflows are tagged with the application version on which they started."]}),"\n",(0,r.jsxs)(n.p,{children:["When DBOS tries to recover workflows, it only recovers workflows whose version matches the current application version.\nThis prevents unsafe recovery of workflows that depend on different code.\nYou cannot change the version of a workflow, but you can use ",(0,r.jsx)(n.a,{href:"../reference/contexts#fork_workflow",children:(0,r.jsx)(n.code,{children:"DBOS.fork_workflow"})})," to restart a workflow from a specific step on a specific code version."]}),"\n",(0,r.jsxs)(n.p,{children:["For more information on managing workflow recovery when self-hosting production DBOS applications, check out ",(0,r.jsx)(n.a,{href:"/production/self-hosting/workflow-recovery",children:"the guide"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var o=t(6540);const r={},s=o.createContext(r);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);