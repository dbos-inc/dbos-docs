"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[3185],{1160:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"production/self-hosting/workflow-recovery","title":"Workflow Recovery","description":"When the execution of a durable workflow is interrupted (for example, if its executor is restarted, interrupted, or crashes), another executor must recover the workflow and resume its execution.","source":"@site/docs/production/self-hosting/workflow-recovery.md","sourceDirName":"production/self-hosting","slug":"/production/self-hosting/workflow-recovery","permalink":"/production/self-hosting/workflow-recovery","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":50,"frontMatter":{"sidebar_position":50,"title":"Workflow Recovery"},"sidebar":"tutorialSidebar","previous":{"title":"Workflow Management","permalink":"/production/self-hosting/workflow-management"},"next":{"title":"Admin API Reference","permalink":"/production/self-hosting/admin-api"}}');var n=t(4848),i=t(8453);const s={sidebar_position:50,title:"Workflow Recovery"},c=void 0,a={},l=[{value:"Managing Recovery",id:"managing-recovery",level:2},{value:"Recovery On A Single Server",id:"recovery-on-a-single-server",level:3},{value:"Recovery in a Distributed Setting",id:"recovery-in-a-distributed-setting",level:3},{value:"Recovery With Conductor",id:"recovery-with-conductor",level:3},{value:"Managing Application versions",id:"managing-application-versions",level:2}];function d(e){const o={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.p,{children:"When the execution of a durable workflow is interrupted (for example, if its executor is restarted, interrupted, or crashes), another executor must recover the workflow and resume its execution.\nTo prevent duplicate work, it is important to detect interruptions promptly and to recover each workflow only once.\nThis guide describes how to manage workflow recovery in a production environment."}),"\n",(0,n.jsx)(o.h2,{id:"managing-recovery",children:"Managing Recovery"}),"\n",(0,n.jsx)(o.h3,{id:"recovery-on-a-single-server",children:"Recovery On A Single Server"}),"\n",(0,n.jsxs)(o.p,{children:["If hosting an application on a single server without Conductor, each time you restart your application's process, DBOS recovers all workflows that were executing before the restart (all ",(0,n.jsx)(o.code,{children:"PENDING"})," workflows)."]}),"\n",(0,n.jsx)(o.h3,{id:"recovery-in-a-distributed-setting",children:"Recovery in a Distributed Setting"}),"\n",(0,n.jsxs)(o.p,{children:["When self-hosting in a distributed setting without Conductor, it is important to manage workflow recovery so that when an executor crashes, restarts, or is shut down, its workflows are recovered.\nYou should assign each executor running a DBOS application an executor ID by setting the ",(0,n.jsx)(o.code,{children:"DBOS__VMID"})," environment variable.\nEach workflow is tagged with the ID of the executor that started it.\nWhen an application with an executor ID restarts, it only recovers pending workflows assigned to that executor ID.\nYou can also instruct your executor to recover workflows assigned to other executor IDs through the ",(0,n.jsx)(o.a,{href:"/production/self-hosting/admin-api#workflow-recovery",children:"workflow recovery endpoint of the admin API"}),"."]}),"\n",(0,n.jsx)(o.h3,{id:"recovery-with-conductor",children:"Recovery With Conductor"}),"\n",(0,n.jsxs)(o.p,{children:["If your application is connected to ",(0,n.jsx)(o.a,{href:"/production/self-hosting/conductor",children:"DBOS Conductor"}),", workflow recovery is automatic.\nWhen Conductor detects that an executor is unhealthy, it automatically signals another executor to recover its workflows."]}),"\n",(0,n.jsxs)(o.p,{children:["When an executor disconnects from Conductor, its status is changed to ",(0,n.jsx)(o.code,{children:"DISCONNECTED"})," while Conductor waits for it to reconnect.\nIf it has not reconnected after a grace period, its status is changed to ",(0,n.jsx)(o.code,{children:"DEAD"})," and Conductor signals another executor of a compatible application version to recover its workflows.\nAfter recovery is confirmed, the executor is deleted."]}),"\n",(0,n.jsx)(o.h2,{id:"managing-application-versions",children:"Managing Application versions"}),"\n",(0,n.jsxs)(o.p,{children:["When self-hosting, it is important to be careful when upgrading your application's code.\nWhen DBOS is launched, it computes an \"application version\" from a checksum of the code in your application's workflows (you can override this version through the ",(0,n.jsx)(o.code,{children:"DBOS__APPVERSION"})," environment variable).\nEach workflow is tagged with the version of the application that started it.\nTo prevent code compatibility issues, DBOS does not attempt to recover workflows tagged with a different application version."]}),"\n",(0,n.jsxs)(o.p,{children:["To safely recover workflows started on an older version of your code, you should start a process running that code version.\nIf self-hosting using Conductor, that process will automatically recover all pending workflows of that code version.\nIf self-hosting without Conductor, you should use the ",(0,n.jsx)(o.a,{href:"/production/self-hosting/admin-api#workflow-recovery",children:"workflow recovery endpoint of the admin API"})," to instruct that process to recover workflows belonging to executors that ran old code versions."]})]})}function u(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,n.jsx)(o,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,o,t)=>{t.d(o,{R:()=>s,x:()=>c});var r=t(6540);const n={},i=r.createContext(n);function s(e){const o=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function c(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),r.createElement(i.Provider,{value:o},e.children)}}}]);