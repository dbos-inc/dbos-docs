"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[6222],{6628:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"explanations/comparing-temporal","title":"Comparing DBOS and Temporal","description":"DBOS and Temporal both provide durable workflows.","source":"@site/docs/explanations/comparing-temporal.md","sourceDirName":"explanations","slug":"/explanations/comparing-temporal","permalink":"/explanations/comparing-temporal","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":20,"frontMatter":{"sidebar_position":20,"title":"Comparing DBOS and Temporal","hide_table_of_contents":true},"sidebar":"tutorialSidebar","previous":{"title":"DBOS System Tables","permalink":"/explanations/system-tables"},"next":{"title":"Troubleshooting & FAQ","permalink":"/faq"}}');var o=r(4848),n=r(8453);const s={sidebar_position:20,title:"Comparing DBOS and Temporal",hide_table_of_contents:!0},i=void 0,l={},c=[{value:"&gt;10x Better Latency",id:"10x-better-latency",level:4},{value:"Rich Workflow Introspection and Management",id:"rich-workflow-introspection-and-management",level:4},{value:"Improved Operational Reliability",id:"improved-operational-reliability",level:4},{value:"Privacy-Preserving Architecture",id:"privacy-preserving-architecture",level:4}];function p(e){const t={a:"a",h4:"h4",p:"p",strong:"strong",...(0,n.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"DBOS and Temporal both provide durable workflows.\nThe main difference is that DBOS is a lightweight Postgres-backed library, while Temporal is an external orchestration service.\nIn our opinion, this architecture makes DBOS radically simpler to adopt and operate."}),"\n",(0,o.jsx)(t.p,{children:"To add DBOS to an application, you install the open-source library and annotate workflows and steps.\nThe library checkpoints workflows to your database and recovers workflows from failures.\nBecause DBOS is just a library, you don't need to change how your application is architected or deployed\u2014it can run on any infrastructure connected to any Postgres-compatible database."}),"\n",(0,o.jsx)("img",{src:r(9452).A,alt:"DBOS Architecture",width:"750",className:"custom-img"}),"\n",(0,o.jsx)(t.p,{children:"By contrast, Temporal is designed around a central workflow server that orchestrates workflow execution on a cluster of workers.\nThe central server runs workflow code, dispatching steps to workers.\nWorkers execute steps, then return their output to the orchestrator, which durably checkpoints it then dispatches the next step.\nApplication code can't call workflows directly, but instead sends requests to the workflows server to start workflows and fetch their results."}),"\n",(0,o.jsxs)(t.p,{children:["Because of this design, adding Temporal to an application requires rearchitecting it.\nFirst, you must move all workflow and step code from application servers to Temporal workers.\nThen, you must also rewrite all interaction between your application and its workflows to go through the orchestration server and its client APIs.\nNext, you must build infrastructure to operate and scale the worker servers.\nFinally, you must operate and scale the orchestration server and its underlying Cassandra data store (Temporal supports other backends, but Cassandra is strongly recommended in production).\n",(0,o.jsx)(t.a,{href:"https://www.dbos.dev/blog/durable-execution-coding-comparison",children:"This blog post"})," empirically benchmarks the comparison, showing how adding DBOS to an example data pipeline application requires changing <10 lines of code, while adding Temporal requires a complete rewrite."]}),"\n",(0,o.jsx)("img",{src:r(4892).A,alt:"External Orchestrator Architecture",width:"750",className:"custom-img"}),"\n",(0,o.jsx)(t.p,{children:"Beyond ease of adoption and operation, the DBOS architecture has a number of other advantages:"}),"\n",(0,o.jsx)(t.h4,{id:"10x-better-latency",children:">10x Better Latency"}),"\n",(0,o.jsxs)(t.p,{children:["In DBOS, the only overhead required to call a step is checkpointing its output.\nThis requires a single Postgres write, which typically takes 1-2ms.\nIn Temporal, a step requires an async dispatch from the central server, which takes ",(0,o.jsx)(t.a,{href:"https://temporal.io/blog/reduce-latency-and-speed-up-your-temporal-workflows",children:"tens to hundreds of ms"}),".\nThus, DBOS is strongly preferred for interactive or otherwise latency-sensitive workflows."]}),"\n",(0,o.jsx)(t.h4,{id:"rich-workflow-introspection-and-management",children:"Rich Workflow Introspection and Management"}),"\n",(0,o.jsx)(t.p,{children:"Because DBOS is built on Postgres, it provides rich SQL-backed workflow introspection and management.\nYou can search workflows by name, time, queue, version, or custom properties, introspect individual steps, and pause, cancel, or resume workflows.\nAll these capabilities are available both programmatically and through a web UI."}),"\n",(0,o.jsxs)(t.p,{children:["One particularly powerful and unique feature is ",(0,o.jsx)(t.strong,{children:"fork"}),": you can restart a workflow from a specific step, either programmatically or from the UI.\nThis is useful for recovering from an unexpected failure in a step, such as a failure due to a bug or an outage.\nFor example, if a large number of billing workflows failed overnight due to an outage in a payment API, you can use fork to restart them all from the payment step after the outage is resolved."]}),"\n",(0,o.jsx)(t.h4,{id:"improved-operational-reliability",children:"Improved Operational Reliability"}),"\n",(0,o.jsx)(t.p,{children:"Because DBOS is just a library, its only point of failure is Postgres.\nIf your organization already uses Postgres, DBOS does not add any new infrastructural dependencies or points of failure to your application's architecture."}),"\n",(0,o.jsx)(t.p,{children:"By contrast, the Temporal architecture adds two new two points of failure: the Temporal server and its Cassandra data store.\nYour team is responsible for operating both, and if either has downtime, your application becomes unavailable."}),"\n",(0,o.jsx)(t.h4,{id:"privacy-preserving-architecture",children:"Privacy-Preserving Architecture"}),"\n",(0,o.jsxs)(t.p,{children:["Because DBOS is just an open-source library and can store data in any Postgres database, it is intrinsically privacy-preserving\u2014you own your data, you store it in your Postgres, and it is never stored or sent anywhere else. By contrast, to use Temporal, you must send potentially sensitive data (including workflow and step checkpoints) to the Temporal server for storage. To mitigate this, Temporal has privacy-preserving features, including support for ",(0,o.jsx)(t.a,{href:"https://docs.temporal.io/evaluate/development-production-features/data-encryption",children:"client-side encryption"})," of all data sent to Temporal."]})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},9452:(e,t,r)=>{r.d(t,{A:()=>a});const a=r.p+"assets/images/dbos-architecture-be89e880bc75334f1743bf8c256209cf.png"},4892:(e,t,r)=>{r.d(t,{A:()=>a});const a=r.p+"assets/images/temporal-architecture-97ecea3658803671d198c09687c0afda.png"},8453:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>i});var a=r(6540);const o={},n=a.createContext(o);function s(e){const t=a.useContext(n);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(n.Provider,{value:t},e.children)}}}]);