"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[6853],{6840:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"golang/tutorials/workflow-tutorial","title":"Workflows","description":"Workflows provide durable execution so you can write programs that are resilient to any failure.","source":"@site/docs/golang/tutorials/workflow-tutorial.md","sourceDirName":"golang/tutorials","slug":"/golang/tutorials/workflow-tutorial","permalink":"/golang/tutorials/workflow-tutorial","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"title":"Workflows","toc_max_heading_level":3},"sidebar":"tutorialSidebar","previous":{"title":"Add DBOS To Your App","permalink":"/golang/integrating-dbos"},"next":{"title":"Steps","permalink":"/golang/tutorials/step-tutorial"}}');var t=r(4848),s=r(8453);const i={sidebar_position:10,title:"Workflows",toc_max_heading_level:3},l=void 0,a={},c=[{value:"Workflow IDs and Idempotency",id:"workflow-ids-and-idempotency",level:2},{value:"Determinism",id:"determinism",level:2},{value:"Workflow Timeouts",id:"workflow-timeouts",level:2},{value:"Durable Sleep",id:"durable-sleep",level:2},{value:"Scheduled Workflows",id:"scheduled-workflows",level:2},{value:"Workflow Guarantees",id:"workflow-guarantees",level:2},{value:"Workflow Versioning and Recovery",id:"workflow-versioning-and-recovery",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Workflows provide ",(0,t.jsx)(n.strong,{children:"durable execution"})," so you can write programs that are ",(0,t.jsx)(n.strong,{children:"resilient to any failure"}),".\nWorkflows are comprised of ",(0,t.jsx)(n.a,{href:"/golang/tutorials/step-tutorial",children:"steps"}),", which wrap ordinary Go functions.\nIf a workflow is interrupted for any reason (e.g., an executor restarts or crashes), when your program restarts the workflow automatically resumes execution from the last completed step."]}),"\n",(0,t.jsxs)(n.p,{children:["To write a workflow, register a Go function with ",(0,t.jsx)(n.a,{href:"/golang/reference/workflows-steps#registerworkflow",children:(0,t.jsx)(n.code,{children:"RegisterWorkflow"})}),".\nWorkflow registration must happen before launching the DBOS context with ",(0,t.jsx)(n.code,{children:"DBOSContext.Launch()"}),"\nThe function's signature must match:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"type Workflow[P any, R any] func(ctx DBOSContext, input P) (R, error)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In other words, a workflow must take in a DBOS context and one other input of any serializable (",(0,t.jsx)(n.a,{href:"https://pkg.go.dev/encoding/gob",children:"gob-encodable"}),") type and must return one output of any serializable type and error."]}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func stepOne(ctx context.Context) (string, error) {\n    fmt.Println("Step one completed")\n    return "success", nil\n}\n\nfunc stepTwo(ctx context.Context) (string, error) {\n    fmt.Println("Step two completed")\n    return "success", nil\n}\n\nfunc workflow(ctx dbos.DBOSContext, _ string) (string, error) {\n    _, err := dbos.RunAsStep(ctx, stepOne)\n    if err != nil {\n        return "failure", err\n    }\n    _, err = dbos.RunAsStep(ctx, stepTwo)\n    if err != nil {\n        return "failure", err\n    }\n    return "success", err\n}\n\nfunc main() {\n    ... // Create the DBOS context\n    dbos.RegisterWorkflow(dbosContext, workflow)\n    ... // Launch DBOS after registering all workflows\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Call workflows with ",(0,t.jsx)(n.a,{href:"/golang/reference/workflows-steps#runworkflow",children:(0,t.jsx)(n.code,{children:"RunWorkflow"})}),".\nThis starts the workflow in the background and returns a ",(0,t.jsx)(n.a,{href:"/golang/reference/workflows-steps#workflowhandle",children:"workflow handle"})," from which you can access information about the workflow or wait for it to complete and return its result."]}),"\n",(0,t.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func runWorkflowExample(dbosContext dbos.DBOSContext, input string) error {\n    handle, err := dbos.RunWorkflow(dbosContext, workflow, input)\n    if err != nil {\n        return err\n    }\n    result, err := handle.GetResult()\n    if err != nil {\n        return err\n    }\n    fmt.Println("Workflow result:", result)\n    return nil\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"workflow-ids-and-idempotency",children:"Workflow IDs and Idempotency"}),"\n",(0,t.jsxs)(n.p,{children:["Every time you execute a workflow, that execution is assigned a unique ID, by default a ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Universally_unique_identifier",children:"UUID"}),".\nYou can access this ID through ",(0,t.jsx)(n.a,{href:"/golang/reference/methods#getworkflowid",children:(0,t.jsx)(n.code,{children:"GetWorkflowID"})}),", or from the handle's ",(0,t.jsx)(n.a,{href:"/golang/reference/workflows-steps#workflowhandlegetworkflowid",children:(0,t.jsx)(n.code,{children:"GetWorkflowID"})})," method.\nWorkflow IDs are useful for communicating with workflows and developing interactive workflows."]}),"\n",(0,t.jsxs)(n.p,{children:["You can set the workflow ID of a workflow using ",(0,t.jsx)(n.a,{href:"/golang/reference/workflows-steps#withworkflowid",children:(0,t.jsx)(n.code,{children:"WithWorkflowID"})})," when calling ",(0,t.jsx)(n.code,{children:"RunWorkflow"}),".\nWorkflow IDs must be ",(0,t.jsx)(n.strong,{children:"globally unique"})," for your application.\nAn assigned workflow ID acts as an idempotency key: if a workflow is called multiple times with the same ID, it executes only once.\nThis is useful if your operations have side effects like making a payment or sending an email.\nFor example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func exampleWorkflow(ctx dbos.DBOSContext, input string) (string, error) {\n    workflowID, err := dbos.GetWorkflowID(ctx)\n    if err != nil {\n        return "", err\n    }\n    fmt.Printf("Running workflow with ID: %s\\n", workflowID)\n    // ...\n    return "success", nil\n}\n\nfunc example(dbosContext dbos.DBOSContext, input string) error {    \n    myID := "unique-workflow-id-123"\n    handle, err := dbos.RunWorkflow(dbosContext, exampleWorkflow, input, dbos.WithWorkflowID(myID))\n    if err != nil {\n        log.Fatal(err)\n    }\n    result, err := handle.GetResult()\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println("Result:", result)\n    return nil\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"determinism",children:"Determinism"}),"\n",(0,t.jsxs)(n.p,{children:["Workflows are in most respects normal Go functions.\nThey can have loops, branches, conditionals, and so on.\nHowever, a workflow function must be ",(0,t.jsx)(n.strong,{children:"deterministic"}),": if called multiple times with the same inputs, it should invoke the same steps with the same inputs in the same order (given the same return values from those steps).\nIf you need to perform a non-deterministic operation like accessing the database, calling a third-party API, generating a random number, or getting the local time, you shouldn't do it directly in a workflow function.\nInstead, you should do all database operations in non-deterministic operations in ",(0,t.jsx)(n.a,{href:"/golang/tutorials/step-tutorial",children:"steps"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["Go's goroutine scheduler and ",(0,t.jsx)(n.code,{children:"select"})," operation are non-deterministic. You should use them only inside steps."]})}),"\n",(0,t.jsxs)(n.p,{children:["For example, ",(0,t.jsx)(n.strong,{children:"don't do this"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func exampleWorkflow(ctx dbos.DBOSContext, input string) (string, error) {\n    randomChoice := rand.Intn(2)\n    if randomChoice == 0 {\n        return dbos.RunAsStep(ctx, stepOne)\n    } else {\n        return dbos.RunAsStep(ctx, stepTwo)\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Instead, do this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func generateChoice(ctx context.Context) (int, error) {\n    return rand.Intn(2), nil\n}\n\nfunc exampleWorkflow(ctx dbos.DBOSContext, input string) (string, error) {\n    randomChoice, err := dbos.RunAsStep(ctx, generateChoice)\n    if err != nil {\n        return "", err\n    }\n    if randomChoice == 0 {\n        return dbos.RunAsStep(ctx, stepOne)\n    } else {\n        return dbos.RunAsStep(ctx, stepTwo)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"workflow-timeouts",children:"Workflow Timeouts"}),"\n",(0,t.jsxs)(n.p,{children:["You can set a timeout for a workflow using its input ",(0,t.jsx)(n.a,{href:"/golang/reference/dbos-context",children:(0,t.jsx)(n.code,{children:"DBOSContext"})}),". Use ",(0,t.jsx)(n.a,{href:"../reference/dbos-context#withtimeout",children:(0,t.jsx)(n.code,{children:"WithTimeout"})})," to obtain a cancellable ",(0,t.jsx)(n.code,{children:"DBOSContext"}),", as you would with a normal ",(0,t.jsx)(n.a,{href:"https://pkg.go.dev/context#Context",children:(0,t.jsx)(n.code,{children:"context.Context"})}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["When the timeout expires, the workflow and all its children are cancelled. Cancelling a workflow sets its status to CANCELLED and preempts its execution at the beginning of its next step. You can detach a child workflow by passing it an uncancellable context, which you can obtain with ",(0,t.jsx)(n.a,{href:"../reference/dbos-context#withoutcancel",children:(0,t.jsx)(n.code,{children:"WithoutCancel"})}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Timeouts are ",(0,t.jsx)(n.strong,{children:"start-to-completion"}),": if a workflow is ",(0,t.jsx)(n.a,{href:"/golang/tutorials/queue-tutorial",children:"enqueued"}),", the timeout does not begin until the workflow is dequeued and starts execution. Also, timeouts are durable: they are stored in the database and persist across restarts, so workflows can have very long timeouts."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func exampleWorkflow(ctx dbos.DBOSContext, input string) (string, error) {}\n\ntimeoutCtx, cancelFunc := dbos.WithTimeout(dbosCtx, 12*time.Hour)\nhandle, err := RunWorkflow(timeoutCtx, exampleWorkflow, "wait-for-cancel")\n'})}),"\n",(0,t.jsxs)(n.p,{children:["You can also manually cancel the workflow by calling its ",(0,t.jsx)(n.code,{children:"cancel"})," function (or calling ",(0,t.jsx)(n.a,{href:"/golang/tutorials/workflow-management#cancelling-workflows",children:"CancelWorkflow"}),")."]}),"\n",(0,t.jsx)(n.h2,{id:"durable-sleep",children:"Durable Sleep"}),"\n",(0,t.jsxs)(n.p,{children:["You can use ",(0,t.jsx)(n.a,{href:"../reference/methods#sleep",children:(0,t.jsx)(n.code,{children:"Sleep"})})," to put your workflow to sleep for any period of time.\nThis sleep is ",(0,t.jsx)(n.strong,{children:"durable"}),"\u2014DBOS saves the wakeup time in the database so that even if the workflow is interrupted and restarted multiple times while sleeping, it still wakes up on schedule."]}),"\n",(0,t.jsx)(n.p,{children:"Sleeping is useful for scheduling a workflow to run in the future (even days, weeks, or months from now).\nFor example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func runTask(ctx dbos.DBOSContext, task string) (string, error) {\n\t// Execute the task...\n\treturn "task completed", nil\n}\n\nfunc exampleWorkflow(ctx dbos.DBOSContext, input struct {\n\tTimeToSleep time.Duration\n\tTask        string\n}) (string, error) {\n\t// Sleep for the specified duration\n\t_, err := dbos.Sleep(ctx, input.TimeToSleep)\n\tif err != nil {\n\t\treturn "", err\n\t}\n\n\t// Execute the task after sleeping\n\tresult, err := dbos.RunAsStep(\n\t\tctx,\n\t\tfunc(stepCtx context.Context) (string, error) {\n\t\t\treturn runTask(ctx, input.Task)\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn "", err\n\t}\n\n\treturn result, nil\n}\n\n'})}),"\n",(0,t.jsx)(n.h2,{id:"scheduled-workflows",children:"Scheduled Workflows"}),"\n",(0,t.jsx)(n.p,{children:"You can schedule workflows to run automatically at specified times using cron syntax with seconds precision.\nScheduled workflows are useful for running recurring tasks like data backups, report generation, or cleanup operations."}),"\n",(0,t.jsxs)(n.p,{children:["To create a scheduled workflow, use ",(0,t.jsx)(n.a,{href:"../reference/workflows-steps#withschedule",children:(0,t.jsx)(n.code,{children:"WithSchedule"})})," when registering your workflow.\nThe workflow must have a single ",(0,t.jsx)(n.a,{href:"https://pkg.go.dev/time#Time",children:(0,t.jsx)(n.code,{children:"time.Time"})})," input parameter, representing the scheduled execution time."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example syntax:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func frequentTask(ctx dbos.DBOSContext, scheduledTime time.Time) (string, error) {\n    fmt.Printf("Performing a scheduled task at: %s\\n", scheduledTime.Format(time.RFC3339))\n    ... // Perform a scheduled task operations\n    return result, nil\n}\n\nfunc dailyBackup(ctx dbos.DBOSContext, scheduledTime time.Time) (string, error) {\n    fmt.Printf("Running daily backup at: %s\\n", scheduledTime.Format(time.RFC3339))\n    ... // Perform daily backup operations\n    return result, nil\n}\n\nfunc main() {\n    dbosContext := ... // Initialize DBOS\n\n    // Register a workflow to run daily at 2:00 AM\n    dbos.RegisterWorkflow(dbosContext, dailyBackup, \n        dbos.WithSchedule("0 0 2 * * *")) // Cron: daily at 2:00 AM\n    \n    // Register a workflow to run every 15 minutes\n    dbos.RegisterWorkflow(dbosContext, frequentTask,\n        dbos.WithSchedule("0 */15 * * * * ")) // Cron: every 15 minutes\n    \n    // Launch DBOS - scheduled workflows will start automatically\n    err := dbosContext.Launch()\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"workflow-guarantees",children:"Workflow Guarantees"}),"\n",(0,t.jsx)(n.p,{children:"Workflows provide the following reliability guarantees.\nThese guarantees assume that the application and database may crash and go offline at any point in time, but are always restarted and return online."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Workflows always run to completion.  If a DBOS process is interrupted while executing a workflow and restarts, it resumes the workflow from the last completed step."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/golang/tutorials/step-tutorial",children:"Steps"})," are tried ",(0,t.jsx)(n.em,{children:"at least once"})," but are never re-executed after they complete.  If a failure occurs inside a step, the step may be retried, but once a step has completed (returned a value or thrown an exception to the calling workflow), it will never be re-executed."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If an exception is thrown from a workflow, the workflow ",(0,t.jsx)(n.strong,{children:"terminates"}),"\u2014DBOS records the exception, sets the workflow status to ",(0,t.jsx)(n.code,{children:"ERROR"}),", and ",(0,t.jsx)(n.strong,{children:"does not recover the workflow"}),".\nThis is because uncaught exceptions are assumed to be nonrecoverable.\nIf your workflow performs operations that may transiently fail (for example, sending HTTP requests to unreliable services), those should be performed in ",(0,t.jsx)(n.a,{href:"/golang/tutorials/step-tutorial#configurable-retries",children:"steps with configured retries"}),".\nDBOS provides ",(0,t.jsx)(n.a,{href:"/golang/tutorials/workflow-management",children:"tooling"})," to help you identify failed workflows and examine the specific uncaught exceptions."]}),"\n",(0,t.jsx)(n.h2,{id:"workflow-versioning-and-recovery",children:"Workflow Versioning and Recovery"}),"\n",(0,t.jsxs)(n.p,{children:["Because DBOS recovers workflows by re-executing them using information saved in the database, a workflow cannot safely be recovered if its code has changed since the workflow was started.\nTo guard against this, DBOS ",(0,t.jsx)(n.em,{children:"versions"})," applications and their workflows.\nWhen DBOS is launched, it computes an application version from a hash of the application source code (this can be overridden through configuration).\nAll workflows are tagged with the application version on which they started."]}),"\n",(0,t.jsxs)(n.p,{children:["When DBOS tries to recover workflows, it only recovers workflows whose version matches the current application version.\nThis prevents unsafe recovery of workflows that depend on different code.\nYou cannot change the version of a workflow, but you can use ",(0,t.jsx)(n.a,{href:"/golang/tutorials/workflow-management#forking-workflows",children:(0,t.jsx)(n.code,{children:"ForkWorkflow"})})," to restart a workflow from a specific step on a specific code version."]}),"\n",(0,t.jsxs)(n.p,{children:["For more information on managing workflow recovery when self-hosting production DBOS applications, check out ",(0,t.jsx)(n.a,{href:"/production/self-hosting/workflow-recovery",children:"the guide"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>l});var o=r(6540);const t={},s=o.createContext(t);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);