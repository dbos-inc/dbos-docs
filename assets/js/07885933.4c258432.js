"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[7400],{8787:(t,e,r)=>{r.r(e),r.d(e,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"golang/examples/widget-store","title":"Fault-Tolerant Checkout","description":"This example is also available in TypeScript and Python.","source":"@site/docs/golang/examples/widget-store.md","sourceDirName":"golang/examples","slug":"/golang/examples/widget-store","permalink":"/golang/examples/widget-store","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":30,"frontMatter":{"displayed_sidebar":"examplesSidebar","sidebar_position":30,"title":"Fault-Tolerant Checkout"},"sidebar":"examplesSidebar","previous":{"title":"DBOS Task Scheduler","permalink":"/typescript/examples/task-scheduler"}}');var o=r(4848),s=r(8453);const i={displayed_sidebar:"examplesSidebar",sidebar_position:30,title:"Fault-Tolerant Checkout"},a=void 0,d={},c=[{value:"Building the Checkout Workflow",id:"building-the-checkout-workflow",level:2},{value:"The Checkout and Payment Endpoints",id:"the-checkout-and-payment-endpoints",level:2},{value:"Database Operations",id:"database-operations",level:2},{value:"Launching and Serving the App",id:"launching-and-serving-the-app",level:2},{value:"Try it Yourself!",id:"try-it-yourself",level:2}];function l(t){const e={a:"a",admonition:"admonition",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...t.components},{Details:n}=e;return n||function(t,e){throw new Error("Expected "+(e?"component":"object")+" `"+t+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.admonition,{type:"info",children:(0,o.jsxs)(e.p,{children:["This example is also available in ",(0,o.jsx)(e.a,{href:"../../typescript/examples/checkout-tutorial",children:"TypeScript"})," and ",(0,o.jsx)(e.a,{href:"/python/examples/widget-store",children:"Python"}),"."]})}),"\n",(0,o.jsx)(e.p,{children:"In this example, we use DBOS and Gin to build an online storefront that's resilient to any failure."}),"\n",(0,o.jsxs)(e.p,{children:["You can see the application live ",(0,o.jsx)(e.a,{href:"https://demo-widget-store.cloud.dbos.dev/",children:"here"}),".\nTry playing with it and pressing the crash button as often as you want.\nWithin a few seconds, the app will recover and resume as if nothing happened."]}),"\n",(0,o.jsxs)(e.p,{children:["All source code is ",(0,o.jsx)(e.a,{href:"https://github.com/dbos-inc/dbos-demo-apps/tree/main/golang/widget-store",children:"available on GitHub"}),"."]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.img,{alt:"Widget store UI",src:r(914).A+"",width:"1243",height:"915"})}),"\n",(0,o.jsx)(e.h2,{id:"building-the-checkout-workflow",children:"Building the Checkout Workflow"}),"\n",(0,o.jsx)(e.p,{children:"The heart of this application is the checkout workflow, which orchestrates the entire purchase process.\nThis workflow is triggered whenever a customer buys a widget and handles the complete order lifecycle:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Creates a new order in the system"}),"\n",(0,o.jsx)(e.li,{children:"Reserves inventory to ensure the item is available"}),"\n",(0,o.jsx)(e.li,{children:"Processes payment"}),"\n",(0,o.jsx)(e.li,{children:"Marks the order as paid and initiates fulfillment"}),"\n",(0,o.jsx)(e.li,{children:"Handles failures gracefully by releasing reserved inventory and canceling orders when necessary"}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["DBOS ",(0,o.jsx)(e.strong,{children:"durably executes"})," this workflow.\nIt checkpoints each step in the database so that if the app fails or is interrupted during checkout, it will automatically recover from the last completed step.\nThis means that customers never lose their order progress, no matter what breaks."]}),"\n",(0,o.jsxs)(e.p,{children:["You can try this yourself!\nOn the ",(0,o.jsx)(e.a,{href:"https://demo-widget-store.cloud.dbos.dev/",children:"live application"}),", start an order and press the crash button at any time.\nWithin seconds, your app will recover to exactly the state it was in before the crash and continue as if nothing happened."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'func checkoutWorkflow(ctx dbos.DBOSContext, _ string) (string, error) {\n\tworkflowID, err := ctx.GetWorkflowID()\n\tif err != nil {\n\t\tlogger.Error("workflow ID retrieval failed", "error", err)\n\t\treturn "", err\n\t}\n\n\t// Create a new order\n\torderID, err := dbos.RunAsStep(ctx, func(stepCtx context.Context) (int, error) {\n\t\treturn createOrder(stepCtx)\n\t})\n\tif err != nil {\n\t\tlogger.Error("order creation failed", "error", err, "wf_id", workflowID)\n\t\treturn "", err\n\t}\n\n\t// Attempt to reserve inventory, cancelling the order if no inventory remains\n\tsuccess, err := dbos.RunAsStep(ctx, func(stepCtx context.Context) (bool, error) {\n\t\treturn reserveInventory(stepCtx)\n\t})\n\tif err != nil || !success {\n\t\tlogger.Warn("no inventory", "order", orderID)\n\t\tdbos.RunAsStep(ctx, func(stepCtx context.Context) (string, error) {\n\t\t\treturn updateOrderStatus(stepCtx, UpdateOrderStatusInput{OrderID: orderID, OrderStatus: CANCELLED})\n\t\t})\n\t\terr = dbos.SetEvent(ctx, PAYMENT_ID, "")\n\t\treturn "", err\n\t}\n\n\terr = dbos.SetEvent(ctx, PAYMENT_ID, workflowID)\n\tif err != nil {\n\t\tlogger.Error("payment event creation failed", "error", err, "order", orderID, "payment", workflowID)\n\t\treturn "", err\n\t}\n\n\tpayment_status, err := dbos.Recv[string](ctx, PAYMENT_STATUS, 60*time.Second)\n\tif err != nil || payment_status != "paid" {\n\t\tlogger.Warn("payment failed", "order", orderID, "payment", workflowID, "status", payment_status)\n\t\tdbos.RunAsStep(ctx, func(stepCtx context.Context) (string, error) {\n\t\t\treturn undoReserveInventory(stepCtx)\n\t\t})\n\t\tdbos.RunAsStep(ctx, func(stepCtx context.Context) (string, error) {\n\t\t\treturn updateOrderStatus(stepCtx, UpdateOrderStatusInput{OrderID: orderID, OrderStatus: CANCELLED})\n\t\t})\n\t} else {\n\t\tlogger.Info("payment success", "order", orderID, "payment", workflowID)\n\t\tdbos.RunAsStep(ctx, func(stepCtx context.Context) (string, error) {\n\t\t\treturn updateOrderStatus(stepCtx, UpdateOrderStatusInput{OrderID: orderID, OrderStatus: PAID})\n\t\t})\n\t\tfmt.Println("calling dispatchOrderWorkflow")\n\t\tdbos.RunWorkflow(ctx, dispatchOrderWorkflow, orderID)\n\t}\n\n\terr = dbos.SetEvent(ctx, ORDER_ID, strconv.Itoa(orderID))\n\tif err != nil {\n\t\tlogger.Error("order event creation failed", "error", err, "order", orderID)\n\t\treturn "", err\n\t}\n\treturn "", nil\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"the-checkout-and-payment-endpoints",children:"The Checkout and Payment Endpoints"}),"\n",(0,o.jsx)(e.p,{children:"Now let's implement the HTTP endpoints that handle customer interactions with the checkout system."}),"\n",(0,o.jsx)(e.p,{children:'The checkout endpoint is triggered when a customer clicks the "Buy Now" button.\nIt starts the checkout workflow in the background, then waits for the workflow to generate and send it a unique payment ID.\nIt then returns the payment ID so the browser can redirect the user to the payments page.'}),"\n",(0,o.jsxs)(e.p,{children:["The endpoint accepts an ",(0,o.jsx)(e.a,{href:"/golang/tutorials/workflow-tutorial#workflow-ids-and-idempotency",children:"idempotency key"}),' so that even if the customer presses "buy now" multiple times, only one checkout workflow is started.']}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'func checkoutEndpoint(c *gin.Context, dbosCtx dbos.DBOSContext, logger *slog.Logger) {\n\tidempotencyKey := c.Param("idempotency_key")\n\n\t// Start the checkout workflow with the idempotency key\n\t_, err := dbos.RunWorkflow(dbosCtx, checkoutWorkflow, "", dbos.WithWorkflowID(idempotencyKey))\n\tif err != nil {\n\t\tlogger.Error("checkout workflow start failed", "error", err, "key", idempotencyKey)\n\t\tc.JSON(http.StatusInternalServerError, gin.H{"error": "Checkout failed to start"})\n\t\treturn\n\t}\n\n\tpayment_id, err := dbos.GetEvent[string](dbosCtx, idempotencyKey, PAYMENT_ID, 60*time.Second)\n\tif err != nil || payment_id == "" {\n\t\tlogger.Error("payment ID retrieval failed", "key", idempotencyKey)\n\t\tc.JSON(http.StatusInternalServerError, gin.H{"error": "Checkout failed"})\n\t\treturn\n\t}\n\n\tc.String(http.StatusOK, payment_id)\n}\n'})}),"\n",(0,o.jsx)(e.p,{children:"The payment endpoint handles the communication between the payment system and the checkout workflow.\nIt uses the payment ID to signal the checkout workflow whether the payment succeeded or failed.\nIt then retrieves the order ID from the checkout workflow so the browser can redirect the customer to the order status page."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'func paymentEndpoint(c *gin.Context, dbosCtx dbos.DBOSContext, logger *slog.Logger) {\n\tpaymentID := c.Param("payment_id")\n\tpaymentStatus := c.Param("payment_status")\n\n\terr := dbos.Send(dbosCtx, paymentID, paymentStatus, PAYMENT_STATUS)\n\tif err != nil {\n\t\tlogger.Error("payment notification failed", "error", err, "payment", paymentID, "status", paymentStatus)\n\t\tc.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process payment"})\n\t\treturn\n\t}\n\n\torderID, err := dbos.GetEvent[string](dbosCtx, paymentID, ORDER_ID, 60*time.Second)\n\tif err != nil || orderID == "" {\n\t\tlogger.Error("order ID retrieval failed", "payment", paymentID)\n\t\tc.JSON(http.StatusInternalServerError, gin.H{"error": "Payment failed to process"})\n\t\treturn\n\t}\n\n\tc.String(http.StatusOK, orderID)\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"database-operations",children:"Database Operations"}),"\n",(0,o.jsx)(e.p,{children:"Now, let's implement the checkout workflow's steps.\nEach step performs a database operation, like updating inventory or order status.\nThese are implemented as regular Go functions that interact with the Postgres database."}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:(0,o.jsx)("strong",{children:"Database Operations"})}),(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'// Database operations for inventory management\nfunc reserveInventory(ctx context.Context) (bool, error) {\n\tresult, err := db.Exec(ctx,\n\t\t"UPDATE products SET inventory = inventory - 1 WHERE product_id = $1 AND inventory > 0",\n\t\tWIDGET_ID)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn result.RowsAffected() > 0, nil\n}\n\nfunc undoReserveInventory(ctx context.Context) (string, error) {\n\t_, err := db.Exec(ctx,\n\t\t"UPDATE products SET inventory = inventory + 1 WHERE product_id = $1",\n\t\tWIDGET_ID)\n\treturn "", err\n}\n\n// Database operations for order management\nfunc createOrder(ctx context.Context) (int, error) {\n\tvar orderID int\n\terr := db.QueryRow(ctx,\n\t\t"INSERT INTO orders (order_status) VALUES ($1) RETURNING order_id",\n\t\tint(PENDING)).Scan(&orderID)\n\treturn orderID, err\n}\n\nfunc updateOrderStatus(ctx context.Context, input UpdateOrderStatusInput) (string, error) {\n\t_, err := db.Exec(ctx,\n\t\t"UPDATE orders SET order_status = $1 WHERE order_id = $2",\n\t\tint(input.OrderStatus), input.OrderID)\n\treturn "", err\n}\n\nfunc updateOrderProgress(ctx context.Context, orderID int) (int, error) {\n\tvar progressRemaining int\n\terr := db.QueryRow(ctx,\n\t\t"UPDATE orders SET progress_remaining = progress_remaining - 1 WHERE order_id = $1 RETURNING progress_remaining",\n\t\torderID).Scan(&progressRemaining)\n\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif progressRemaining == 0 {\n\t\t_, err = updateOrderStatus(ctx, UpdateOrderStatusInput{OrderID: orderID, OrderStatus: DISPATCHED})\n\t}\n\n\treturn progressRemaining, err\n}\n\n// HTTP endpoints for accessing data\nfunc getProduct(c *gin.Context, db *pgxpool.Pool, logger *slog.Logger) {\n\tvar product Product\n\terr := db.QueryRow(context.Background(),\n\t\t"SELECT product_id, product, description, inventory, price FROM products LIMIT 1").\n\t\tScan(&product.ProductID, &product.Product, &product.Description, &product.Inventory, &product.Price)\n\n\tif err != nil {\n\t\tlogger.Error("product query failed", "error", err)\n\t\tc.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch product"})\n\t\treturn\n\t}\n\tc.JSON(http.StatusOK, product)\n}\n\nfunc getOrders(c *gin.Context, db *pgxpool.Pool, logger *slog.Logger) {\n\trows, err := db.Query(context.Background(),\n\t\t"SELECT order_id, order_status, last_update_time, progress_remaining FROM orders")\n\tif err != nil {\n\t\tlogger.Error("orders database query failed", "error", err)\n\t\tc.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch orders"})\n\t\treturn\n\t}\n\tdefer rows.Close()\n\n\torders := []Order{}\n\tfor rows.Next() {\n\t\tvar order Order\n\t\terr := rows.Scan(&order.OrderID, &order.OrderStatus, &order.LastUpdateTime, &order.ProgressRemaining)\n\t\tif err != nil {\n\t\t\tlogger.Error("order data parsing failed", "error", err)\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process orders"})\n\t\t\treturn\n\t\t}\n\t\torders = append(orders, order)\n\t}\n\n\tc.JSON(http.StatusOK, orders)\n}\n\nfunc getOrder(c *gin.Context, db *pgxpool.Pool, logger *slog.Logger) {\n\tidStr := c.Param("id")\n\tid, err := strconv.Atoi(idStr)\n\tif err != nil {\n\t\tlogger.Warn("invalid order ID", "error", err, "id", idStr)\n\t\tc.JSON(http.StatusBadRequest, gin.H{"error": "Invalid order ID"})\n\t\treturn\n\t}\n\n\tvar order Order\n\terr = db.QueryRow(context.Background(),\n\t\t"SELECT order_id, order_status, last_update_time, progress_remaining FROM orders WHERE order_id = $1", id).\n\t\tScan(&order.OrderID, &order.OrderStatus, &order.LastUpdateTime, &order.ProgressRemaining)\n\n\tif err != nil {\n\t\tif err == pgx.ErrNoRows {\n\t\t\tlogger.Warn("order not found", "order", id)\n\t\t\tc.JSON(http.StatusNotFound, gin.H{"error": "Order not found"})\n\t\t} else {\n\t\t\tlogger.Error("order database query failed", "error", err, "order", id)\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch order"})\n\t\t}\n\t\treturn\n\t}\n\tc.JSON(http.StatusOK, order)\n}\n\nfunc restock(c *gin.Context, db *pgxpool.Pool, logger *slog.Logger) {\n\t_, err := db.Exec(context.Background(), "UPDATE products SET inventory = 100")\n\tif err != nil {\n\t\tlogger.Error("inventory update failed", "error", err)\n\t\tc.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to restock inventory"})\n\t\treturn\n\t}\n\n\tc.JSON(http.StatusOK, gin.H{"message": "Restocked successfully"})\n}\n\n// Crash the app--for demonstration purposes only :)\nfunc crashApplication(c *gin.Context, logger *slog.Logger) {\n\tlogger.Warn("application crash requested")\n\tc.JSON(http.StatusOK, gin.H{"message": "Crashing application..."})\n\t// Give time for response to be sent\n\tgo func() {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tlogger.Error("intentional crash for demo")\n\t\tos.Exit(1)\n\t}()\n}\n'})})]}),"\n",(0,o.jsx)(e.h2,{id:"launching-and-serving-the-app",children:"Launching and Serving the App"}),"\n",(0,o.jsx)(e.p,{children:"Finally, here's the complete main function that initializes DBOS, sets up the database connection, registers workflows, and starts the Gin HTTP server:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'func main() {\n\tlogger = slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{\n\t\tLevel: slog.LevelDebug,\n\t}))\n\n\tdbURL := os.Getenv("DBOS_SYSTEM_DATABASE_URL")\n\tif dbURL == "" {\n\t\tlogger.Error("DBOS_SYSTEM_DATABASE_URL required")\n\t\tos.Exit(1)\n\t}\n\n\tdbosContext, err := dbos.NewDBOSContext(context.Background(), dbos.Config{\n\t\tAppName:         "widget-store",\n\t\tDatabaseURL:     os.Getenv("DBOS_SYSTEM_DATABASE_URL"),\n\t\tAdminServer:     true,\n\t\tLogger:          logger,\n\t\tConductorAPIKey: os.Getenv("DBOS_CONDUCTOR_API_KEY"),\n\t})\n\tif err != nil {\n\t\tlogger.Error("DBOS initialization failed", "error", err)\n\t\tos.Exit(1)\n\t}\n\tdbos.RegisterWorkflow(dbosContext, checkoutWorkflow)\n\tdbos.RegisterWorkflow(dbosContext, dispatchOrderWorkflow)\n\n\terr = dbosContext.Launch()\n\tif err != nil {\n\t\tlogger.Error("DBOS service start failed", "error", err)\n\t\tos.Exit(1)\n\t}\n\tdefer dbosContext.Shutdown(10 * time.Second)\n\n\tdb, err = pgxpool.New(context.Background(), dbURL)\n\tif err != nil {\n\t\tlogger.Error("database connection failed", "error", err)\n\t\tos.Exit(1)\n\t}\n\tdefer db.Close()\n\n\tr := gin.Default()\n\n\t// Serve HTML\n\tr.StaticFile("/", "./html/app.html")\n\n\t// HTTP endpoints\n\tr.GET("/product", func(c *gin.Context) { getProduct(c, db, logger) })\n\tr.GET("/orders", func(c *gin.Context) { getOrders(c, db, logger) })\n\tr.GET("/order/:id", func(c *gin.Context) { getOrder(c, db, logger) })\n\tr.POST("/restock", func(c *gin.Context) { restock(c, db, logger) })\n\tr.POST("/checkout/:idempotency_key", func(c *gin.Context) { checkoutEndpoint(c, dbosContext, logger) })\n\tr.POST("/payment_webhook/:payment_id/:payment_status", func(c *gin.Context) { paymentEndpoint(c, dbosContext, logger) })\n\tr.POST("/crash_application", func(c *gin.Context) { crashApplication(c, logger) })\n\n\tif err := r.Run(":8080"); err != nil {\n\t\tlogger.Error("HTTP server start failed", "error", err)\n\t\tos.Exit(1)\n\t}\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"try-it-yourself",children:"Try it Yourself!"}),"\n",(0,o.jsxs)(e.p,{children:["First, clone and enter the ",(0,o.jsx)(e.a,{href:"https://github.com/dbos-inc/dbos-demo-apps",children:"dbos-demo-apps"})," repository:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-shell",children:"git clone https://github.com/dbos-inc/dbos-demo-apps.git\ncd golang/widget-store\n"})}),"\n",(0,o.jsx)(e.p,{children:"Then follow the instructions in the README to build and run the app!"})]})}function p(t={}){const{wrapper:e}={...(0,s.R)(),...t.components};return e?(0,o.jsx)(e,{...t,children:(0,o.jsx)(l,{...t})}):l(t)}},914:(t,e,r)=>{r.d(e,{A:()=>n});const n=r.p+"assets/images/widget_store_ui-a4c2b42a8c4b98b711e3a2aa714511c9.png"},8453:(t,e,r)=>{r.d(e,{R:()=>i,x:()=>a});var n=r(6540);const o={},s=n.createContext(o);function i(t){const e=n.useContext(s);return n.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function a(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(o):t.components||o:i(t.components),n.createElement(s.Provider,{value:e},t.children)}}}]);