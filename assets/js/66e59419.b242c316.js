"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[944],{3282:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var t=o(5893),r=o(1151);const i={sidebar_position:4,title:"Workflows",description:"Learn how to make applications reliable using workflows."},a=void 0,s={id:"tutorials/workflow-tutorial",title:"Workflows",description:"Learn how to make applications reliable using workflows.",source:"@site/docs/tutorials/workflow-tutorial.md",sourceDirName:"tutorials",slug:"/tutorials/workflow-tutorial",permalink:"/tutorials/workflow-tutorial",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Workflows",description:"Learn how to make applications reliable using workflows."},sidebar:"tutorialSidebar",previous:{title:"Communicators",permalink:"/tutorials/communicator-tutorial"},next:{title:"Idempotency",permalink:"/tutorials/idempotency-tutorial"}},l={},c=[{value:"Invoking Functions from Workflows",id:"invoking-functions-from-workflows",level:3},{value:"Reliability Guarantees",id:"reliability-guarantees",level:3},{value:"Determinism",id:"determinism",level:3},{value:"Workflow Identity",id:"workflow-identity",level:3},{value:"Asynchronous Workflows",id:"asynchronous-workflows",level:3},{value:"Further Reading",id:"further-reading",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In this guide, you'll learn how to make your applications reliable using workflows."}),"\n",(0,t.jsxs)(n.p,{children:["Workflows orchestrate the execution of other functions, like transactions and communicators.\nThey're useful because they're ",(0,t.jsx)(n.em,{children:"reliable"}),": if a server is interruped for any reason (for example, it crashes and restarts), it automatically resumes all incomplete workflows and runs them to completion without re-executing any operation that already completed.\nYou can use workflows when you need to coordinate multiple operations that all need to complete for a program to be correct.\nFor example, in our ",(0,t.jsx)(n.a,{href:"https://github.com/dbos-inc/dbos-demo-apps/tree/main/e-commerce",children:"e-commerce demo"}),", we use a workflow to do payment processing.\nWorkflow reliability guarantees are especially valuable when some operations are long-running, like waiting for user inputs."]}),"\n",(0,t.jsxs)(n.p,{children:["Workflows must be annotated with the ",(0,t.jsx)(n.a,{href:"../api-reference/decorators#workflow",children:(0,t.jsx)(n.code,{children:"@Workflow"})})," decorator and must have a ",(0,t.jsx)(n.a,{href:"../api-reference/contexts#workflowcontext",children:(0,t.jsx)(n.code,{children:"WorkflowContext"})})," as their first argument.\nLike for other functions, inputs and outputs must be serializable to JSON.\nAdditionally, workflows must be ",(0,t.jsx)(n.a,{href:"#determinism",children:"deterministic"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Here's an example workflow from our ",(0,t.jsx)(n.a,{href:"../getting-started/quickstart-programming-2",children:"quickstart"}),".\nIt increments a counter in the database, then sends an HTTP request.\nIf the request fails, it sends a compensating undo transaction to reverse the increment.\nBy making this a workflow, we guarantee that the undo always happens if the request fails, even if the server is interrupted."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class Hello {\n\n  ... // Other function implementations\n\n  @GetApi('/greeting/:user')\n  @Workflow()\n  static async helloWorkflow(ctxt: WorkflowContext, @ArgSource(ArgSources.URL) user: string) {\n    const greeting = await ctxt.invoke(Hello).helloTransaction(user);\n    try {\n      await ctxt.invoke(Hello).greetPostman(greeting);\n      return greeting;\n    } catch (e) {\n      ctxt.logger.error(e);\n      await ctxt.invoke(Hello).undoHelloTransaction(user);\n      return `Greeting failed for ${user}\\n`\n    }\n  }\n"})}),"\n",(0,t.jsx)(n.h3,{id:"invoking-functions-from-workflows",children:"Invoking Functions from Workflows"}),"\n",(0,t.jsxs)(n.p,{children:["Workflows can invoke transactions and communicators using their ",(0,t.jsx)(n.a,{href:"../api-reference/contexts#workflowctxtinvoketargetclass",children:(0,t.jsx)(n.code,{children:"ctxt.invoke()"})})," method.\nFor example, this line from our above example invokes ",(0,t.jsx)(n.code,{children:"helloTransaction"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const greeting = await ctxt.invoke(Hello).helloTransaction(user);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The syntax for invoking function ",(0,t.jsx)(n.code,{children:"foo(args)"})," in class ",(0,t.jsx)(n.code,{children:"Bar"})," is ",(0,t.jsx)(n.code,{children:"ctxt.invoke(Bar).foo(args)"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["You can also invoke other workflows using the ",(0,t.jsx)(n.a,{href:"../api-reference/contexts#workflowctxtchildworkflowwf-args",children:"ctxt.childWorkflow()"})," method."]}),"\n",(0,t.jsx)(n.h3,{id:"reliability-guarantees",children:"Reliability Guarantees"}),"\n",(0,t.jsx)(n.p,{children:"Workflows provide the following reliability guaranteees:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"They always run to completion.  If a server executing a workflow fails and is restarted, it resumes all incomplete workflows from where they left off."}),"\n",(0,t.jsxs)(n.li,{children:["Transactions execute ",(0,t.jsx)(n.em,{children:"exactly once"}),".  Regardless of what failures occur during a workflow's execution, it executes each of its transactions once and only once."]}),"\n",(0,t.jsxs)(n.li,{children:["Communicators execute ",(0,t.jsx)(n.em,{children:"at least once"})," but are never re-executed after they successfully complete.  If a failure occurs inside a communicator, the communicator may be retried, but once a communicator has completed execution, guarantees it will never be re-executed regardless of what failures happen afterwards."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"determinism",children:"Determinism"}),"\n",(0,t.jsxs)(n.p,{children:["For workflows to provide reliability guarantees, they must be deterministic.\nIn other words, a workflow function must always do the same thing given the same inputs.\nIf you need to perform a non-deterministic operation like accessing the database, calling a third-party API, generating a random number, or getting the local time, you shouldn't do it directly in a workflow function.\nInstead, you should do all database operations in ",(0,t.jsx)(n.a,{href:"./transaction-tutorial",children:"transactions"})," and all other non-deterministic operations in ",(0,t.jsx)(n.a,{href:"./communicator-tutorial",children:"communicators"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"workflow-identity",children:"Workflow Identity"}),"\n",(0,t.jsxs)(n.p,{children:["Every time you execute a workflow, that execution is assigned a unique identity, represented as a ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Universally_unique_identifier",children:"UUID"}),".\nYou can access this UUID through the ",(0,t.jsx)(n.code,{children:"context.workflowUUID"})," field.\nWorkflow identities are important for communicating with workflows and developing interactive workflows.\nFor more information on workflow communication, see ",(0,t.jsx)(n.a,{href:"/tutorials/workflow-communication-tutorial",children:"our guide"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"asynchronous-workflows",children:"Asynchronous Workflows"}),"\n",(0,t.jsxs)(n.p,{children:["Because workflows are often long-running, DBOS supports invoking workflows asynchronously.\nWhen you invoke a workflow from a handler or from another workflow, the invocation returns a ",(0,t.jsx)(n.a,{href:"../api-reference/workflow-handles",children:"workflow handle"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"  @GetApi(...)\n  static async exampleHandler(ctxt: HandlerContext, ...) {\n    const handle = await ctxt.invoke(Class).workflow(...);\n  }\n"})}),"\n",(0,t.jsx)(n.p,{children:"You can also retrieve another workflow's handle if you know its identity:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"  @GetApi(...)\n  static async exampleHandler(ctxt: HandlerContext, workflowIdentity: string, ...) {\n    const handle = await ctxt.retrieveWorkflow(workflowIdentity);\n  }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To wait for a workflow to complete and retrieve its result, await ",(0,t.jsx)(n.code,{children:"handle.getResult()"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const handle = await ctxt.invoke(Class).workflow(...);\nconst result = await handle.getResult();\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or, more concisely:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const result = await ctxt.invoke(Class).workflow(name).then(h => h.getResult());\n"})}),"\n",(0,t.jsxs)(n.p,{children:["For more information on workflow handles, see ",(0,t.jsx)(n.a,{href:"../api-reference/workflow-handles",children:"their reference page"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(n.p,{children:["To learn how to make workflows (or other functions) idempotent, see ",(0,t.jsx)(n.a,{href:"./idempotency-tutorial",children:"our idempotency guide"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["To learn how to make workflows interactive (for example, to handle user input), see our ",(0,t.jsx)(n.a,{href:"./workflow-communication-tutorial",children:"workflow communication guide"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},1151:(e,n,o)=>{o.d(n,{Z:()=>s,a:()=>a});var t=o(7294);const r={},i=t.createContext(r);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);