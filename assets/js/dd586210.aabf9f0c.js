"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[787],{631:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>u,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"golang/tutorials/queue-tutorial","title":"Queues & Concurrency","description":"You can use queues to run many workflows at once with managed concurrency.","source":"@site/docs/golang/tutorials/queue-tutorial.md","sourceDirName":"golang/tutorials","slug":"/golang/tutorials/queue-tutorial","permalink":"/golang/tutorials/queue-tutorial","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":45,"frontMatter":{"sidebar_position":45,"title":"Queues & Concurrency","toc_max_heading_level":3},"sidebar":"tutorialSidebar","previous":{"title":"Steps","permalink":"/golang/tutorials/step-tutorial"},"next":{"title":"Communicating with Workflows","permalink":"/golang/tutorials/workflow-communication"}}');var o=r(4848),s=r(8453);const i={sidebar_position:45,title:"Queues & Concurrency",toc_max_heading_level:3},a=void 0,u={},l=[{value:"Queue Example",id:"queue-example",level:3},{value:"Enqueueing from Another Application",id:"enqueueing-from-another-application",level:3},{value:"Managing Concurrency",id:"managing-concurrency",level:3},{value:"Worker Concurrency",id:"worker-concurrency",level:4},{value:"Global Concurrency",id:"global-concurrency",level:4},{value:"Rate Limiting",id:"rate-limiting",level:3},{value:"Deduplication",id:"deduplication",level:3},{value:"Priority",id:"priority",level:3},{value:"Partitioning Queues",id:"partitioning-queues",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["You can use queues to run many workflows at once with managed concurrency.\nQueues provide ",(0,o.jsx)(n.em,{children:"flow control"}),", letting you manage how many workflows run at once or how often workflows are started."]}),"\n",(0,o.jsxs)(n.p,{children:["To create a queue, use ",(0,o.jsx)(n.a,{href:"../reference/queues#newworkflowqueue",children:(0,o.jsx)(n.code,{children:"NewWorkflowQueue"})})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'queue := dbos.NewWorkflowQueue(dbosContext, "example_queue")\n'})}),"\n",(0,o.jsxs)(n.p,{children:["You can then enqueue any workflow using ",(0,o.jsx)(n.a,{href:"../reference/workflows-steps#withqueue",children:(0,o.jsx)(n.code,{children:"WithQueue"})})," when calling ",(0,o.jsx)(n.code,{children:"RunWorkflow"}),".\nEnqueuing a function submits it for execution and returns a ",(0,o.jsx)(n.a,{href:"../reference/workflows-steps#workflowhandle",children:"handle"})," to it.\nQueued tasks are started in first-in, first-out (FIFO) order."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'func processTask(ctx dbos.DBOSContext, task string) (string, error) {\n    // Process the task...\n    return fmt.Sprintf("Processed: %s", task), nil\n}\n\nfunc example(dbosContext dbos.DBOSContext, queue dbos.WorkflowQueue) error {\n    // Enqueue a workflow\n    task := "example_task"\n    handle, err := dbos.RunWorkflow(dbosContext, processTask, task, dbos.WithQueue(queue.Name))\n    if err != nil {\n        return err\n    }\n    \n    // Get the result\n    result, err := handle.GetResult()\n    if err != nil {\n        return err\n    }\n    fmt.Println("Task result:", result)\n    return nil\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"queue-example",children:"Queue Example"}),"\n",(0,o.jsx)(n.p,{children:"Here's an example of a workflow using a queue to process tasks concurrently:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'func taskWorkflow(ctx dbos.DBOSContext, task string) (string, error) {\n    // Process the task...\n    return fmt.Sprintf("Processed: %s", task), nil\n}\n\nfunc queueWorkflow(ctx dbos.DBOSContext, queue dbos.WorkflowQueue) ([]string, error) {\n    // Enqueue each task so all tasks are processed concurrently\n    tasks := []string{"task1", "task2", "task3", "task4", "task5"}\n\n    var handles []dbos.WorkflowHandle[string]\n    for _, task := range tasks {\n        handle, err := dbos.RunWorkflow(ctx, taskWorkflow, task, dbos.WithQueue(queue.Name))\n        if err != nil {\n            return nil, fmt.Errorf("failed to enqueue task %s: %w", task, err)\n        }\n        handles = append(handles, handle)\n    }\n\n    // Wait for each task to complete and retrieve its result\n    var results []string\n    for i, handle := range handles {\n        result, err := handle.GetResult()\n        if err != nil {\n            return nil, fmt.Errorf("task %d failed: %w", i, err)\n        }\n        results = append(results, result)\n    }\n\n    return results, nil\n}\n\nfunc example(dbosContext dbos.DBOSContext, queue dbos.WorkflowQueue) error {\n    handle, err := dbos.RunWorkflow(dbosContext, queueWorkflow, queue)\n    if err != nil {\n        return err\n    }\n\n    results, err := handle.GetResult()\n    if err != nil {\n        return err\n    }\n\n    for _, result := range results {\n        fmt.Println(result)\n    }\n    return nil\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Sometimes, you may wish to receive the result of each task as soon as it's ready instead of waiting for all tasks to complete.\nYou can do this using ",(0,o.jsxs)(n.a,{href:"/golang/tutorials/workflow-communication#workflow-messaging-and-notifications",children:[(0,o.jsx)(n.code,{children:"Send"})," and ",(0,o.jsx)(n.code,{children:"Recv"})]}),".\nEach enqueued workflow sends a message to the main workflow when it's done processing its task.\nThe main workflow awaits those messages, retrieving the result of each task as soon as the task completes."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'const TaskCompleteTopic = "task_complete"\n\ntype TaskInput struct {\n    ParentWorkflowID string\n    TaskID           int\n    Task             string\n}\n\nfunc processTask(ctx dbos.DBOSContext, input TaskInput) (string, error) {\n    result := ... // Process the task\n\n    // Notify the main workflow this task is complete\n    err := dbos.Send(ctx, input.ParentWorkflowID, input.TaskID, TaskCompleteTopic)\n    if err != nil {\n        return "", fmt.Errorf("failed to send completion notification: %w", err)\n    }\n    return result, nil\n}\n\nfunc processTasks(ctx dbos.DBOSContext, tasks []string) ([]string, error) {\n    parentWorkflowID, err := dbos.GetWorkflowID(ctx)\n    if err != nil {\n        return nil, fmt.Errorf("failed to get workflow ID: %w", err)\n    }\n\n    var handles []dbos.WorkflowHandle[string]\n    for i, task := range tasks {\n        handle, err := dbos.RunWorkflow(ctx, processTask,\n            TaskInput{ParentWorkflowID: parentWorkflowID, TaskID: i, Task: task},\n            dbos.WithQueue(queue.Name),\n        )\n        if err != nil {\n            return nil, fmt.Errorf("failed to enqueue task %d: %w", i, err)\n        }\n        handles = append(handles, handle)\n    }\n\n    var results []string\n    for len(results) < len(tasks) {\n        // Wait for a notification that a task is complete\n        completedTaskID, err := dbos.Recv[int](ctx, TaskCompleteTopic, 5*time.Minute)\n        if err != nil {\n            return nil, fmt.Errorf("timeout waiting for task completion: %w", err)\n        }\n        // Retrieve result of the completed task\n        completedTaskHandle := handles[completedTaskID]\n        result, err := completedTaskHandle.GetResult()\n        if err != nil {\n            return nil, fmt.Errorf("task %d failed: %w", completedTaskID, err)\n        }\n        fmt.Printf("Task %d completed. Result: %s\\n", completedTaskID, result)\n        results = append(results, result)\n    }\n    return results, nil\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"enqueueing-from-another-application",children:"Enqueueing from Another Application"}),"\n",(0,o.jsx)(n.p,{children:"Often, you want to enqueue a workflow from outside your DBOS application.\nFor example, let's say you have an API server and a data processing service.\nYou're using DBOS to build a durable data pipeline in the data processing service.\nWhen the API server receives a request, it should enqueue the data pipeline for execution on the data processing service."}),"\n",(0,o.jsxs)(n.p,{children:["You can use the ",(0,o.jsx)(n.a,{href:"/golang/reference/client",children:"DBOS Client"})," to enqueue workflows from outside your DBOS application by connecting directly to your DBOS application's system database.\nSince the DBOS Client is designed to be used from outside your DBOS application, workflow and queue metadata must be specified explicitly."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, this code enqueues the ",(0,o.jsx)(n.code,{children:"dataPipeline"})," workflow on the ",(0,o.jsx)(n.code,{children:"pipelineQueue"})," queue with a ",(0,o.jsx)(n.code,{children:"ProcessInput"})," argument:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'type ProcessInput struct {\n    TaskID string\n    Data   string\n}\n\ntype ProcessOutput struct {\n    Result string\n    Status string\n}\n\nconfig := dbos.ClientConfig{\n    DatabaseURL: os.Getenv("DBOS_SYSTEM_DATABASE_URL"),\n}\nclient, err := dbos.NewClient(context.Background(), config)\nif err != nil {\n    log.Fatal(err)\n}\ndefer client.Shutdown(5 * time.Second)\n\nhandle, err := dbos.Enqueue[ProcessInput, ProcessOutput](\n    client, \n    "pipelineQueue",\n    "dataPipeline",\n    ProcessInput{TaskID: "task-123", Data: "data"},\n)\nif err != nil {\n    log.Fatal(err)\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"managing-concurrency",children:"Managing Concurrency"}),"\n",(0,o.jsx)(n.p,{children:"You can control how many workflows from a queue run simultaneously by configuring concurrency limits.\nThis helps prevent resource exhaustion when workflows consume significant memory or processing power."}),"\n",(0,o.jsx)(n.h4,{id:"worker-concurrency",children:"Worker Concurrency"}),"\n",(0,o.jsx)(n.p,{children:"Worker concurrency sets the maximum number of workflows from a queue that can run concurrently on a single DBOS process.\nThis is particularly useful for resource-intensive workflows to avoid exhausting the resources of any process.\nFor example, this queue has a worker concurrency of 5, so each process will run at most 5 workflows from this queue simultaneously:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'queue := dbos.NewWorkflowQueue(dbosContext, "example_queue",  dbos.WithWorkerConcurrency(5))\n'})}),"\n",(0,o.jsx)(n.h4,{id:"global-concurrency",children:"Global Concurrency"}),"\n",(0,o.jsx)(n.p,{children:"Global concurrency limits the total number of workflows from a queue that can run concurrently across all DBOS processes in your application.\nFor example, this queue will have a maximum of 10 workflows running simultaneously across your entire application."}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsxs)(n.p,{children:["Worker concurrency limits are recommended for most use cases.\nTake care when using a global concurrency limit as any ",(0,o.jsx)(n.code,{children:"PENDING"})," workflow on the queue counts toward the limit, including workflows from previous application versions"]})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'queue := dbos.NewWorkflowQueue(dbosContext, "example_queue", dbos.WithGlobalConcurrency(10))\n'})}),"\n",(0,o.jsx)(n.h3,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,o.jsxs)(n.p,{children:["You can set ",(0,o.jsx)(n.em,{children:"rate limits"})," for a queue, limiting the number of functions that it can start in a given period.\nRate limits are global across all DBOS processes using this queue.\nFor example, this queue has a limit of 100 workflows with a period of 60 seconds, so it may not start more than 100 workflows in 60 seconds:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'queue := dbos.NewWorkflowQueue(dbosContext, "example_queue", \n    dbos.WithRateLimiter(&dbos.RateLimiter{\n        Limit:  100,\n        Period: 60.0, // 60 seconds\n    }))\n'})}),"\n",(0,o.jsx)(n.p,{children:"Rate limits are especially useful when working with a rate-limited API, such as many LLM APIs."}),"\n",(0,o.jsx)(n.h3,{id:"deduplication",children:"Deduplication"}),"\n",(0,o.jsxs)(n.p,{children:["You can set a deduplication ID for an enqueued workflow using ",(0,o.jsx)(n.a,{href:"../reference/workflows-steps#withdeduplicationid",children:(0,o.jsx)(n.code,{children:"WithDeduplicationID"})})," when calling ",(0,o.jsx)(n.code,{children:"RunWorkflow"}),".\nAt any given time, only one workflow with a specific deduplication ID can be enqueued in the specified queue.\nIf a workflow with a deduplication ID is currently enqueued or actively executing (status ",(0,o.jsx)(n.code,{children:"ENQUEUED"})," or ",(0,o.jsx)(n.code,{children:"PENDING"}),"), subsequent workflow enqueue attempts with the same deduplication ID in the same queue will return an error."]}),"\n",(0,o.jsx)(n.p,{children:"For example, this is useful if you only want to have one workflow active at a time per user\u2014set the deduplication ID to the user's ID."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example syntax:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'func taskWorkflow(ctx dbos.DBOSContext, task string) (string, error) {\n    // Process the task...\n    return "completed", nil\n}\n\nfunc example(dbosContext dbos.DBOSContext, queue dbos.WorkflowQueue) error {\n    task := "example_task"\n    deduplicationID := "user_12345" // Use user ID for deduplication\n    \n    handle, err := dbos.RunWorkflow(\n        dbosContext, taskWorkflow, task,\n        dbos.WithQueue(queue.Name),\n        dbos.WithDeduplicationID(deduplicationID))\n    if err != nil {\n        // Handle deduplication error or other failures\n        return fmt.Errorf("failed to enqueue workflow: %w", err)\n    }\n    \n    result, err := handle.GetResult()\n    if err != nil {\n        return fmt.Errorf("workflow failed: %w", err)\n    }\n    \n    fmt.Printf("Workflow completed: %s\\n", result)\n    return nil\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"priority",children:"Priority"}),"\n",(0,o.jsxs)(n.p,{children:["You can set a priority for an enqueued workflow using ",(0,o.jsx)(n.a,{href:"../reference/workflows-steps#withpriority",children:(0,o.jsx)(n.code,{children:"WithPriority"})})," when calling ",(0,o.jsx)(n.code,{children:"RunWorkflow"}),".\nWorkflows with the same priority are dequeued in ",(0,o.jsx)(n.strong,{children:"FIFO (first in, first out)"})," order. Priority values can range from ",(0,o.jsx)(n.code,{children:"1"})," to ",(0,o.jsx)(n.code,{children:"2,147,483,647"}),", where ",(0,o.jsx)(n.strong,{children:"a low number indicates a higher priority"}),".\nIf using priority, you must set ",(0,o.jsx)(n.a,{href:"../reference/queues#withpriorityenabled",children:(0,o.jsx)(n.code,{children:"WithPriorityEnabled"})})," on your queue."]}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsx)(n.p,{children:"Workflows without assigned priorities have the highest priority and are dequeued before workflows with assigned priorities."})}),"\n",(0,o.jsx)(n.p,{children:"To use priorities in a queue, you must enable it when creating the queue:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'queue := dbos.NewWorkflowQueue(dbosContext, "example_queue", dbos.WithPriorityEnabled())\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example syntax:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'func taskWorkflow(ctx dbos.DBOSContext, task string) (string, error) {\n    // Process the task...\n    return "completed", nil\n}\n\nfunc example(dbosContext dbos.DBOSContext, queue dbos.WorkflowQueue) error {\n    task := "example_task"\n    priority := uint(10) // Lower number = higher priority\n    \n    handle, err := dbos.RunWorkflow(dbosContext, taskWorkflow, task,\n        dbos.WithQueue(queue.Name),\n        dbos.WithPriority(priority))\n    if err != nil {\n        return err\n    }\n    \n    result, err := handle.GetResult()\n    if err != nil {\n        return fmt.Errorf("workflow failed: %w", err)\n    }\n    \n    fmt.Printf("Workflow completed: %s\\n", result)\n    return nil\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"partitioning-queues",children:"Partitioning Queues"}),"\n",(0,o.jsxs)(n.p,{children:["You can ",(0,o.jsx)(n.strong,{children:"partition"}),' queues to distribute work across dynamically created queue partitions.\nWhen you enqueue a workflow on a partitioned queue, you must supply a queue partition key.\nPartitioned queues dequeue workflows and apply flow control limits for individual partitions, not for the entire queue.\nEssentially, you can think of each partition as a "subqueue" you dynamically create by enqueueing a workflow with a partition key.']}),"\n",(0,o.jsx)(n.p,{children:"For example, suppose you want your users to each be able to run at most one task at a time.\nYou can do this with a partitioned queue with a maximum concurrency limit of 1 where the partition key is user ID."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example Syntax:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'// Create a partitioned queue with a global concurrency limit of 1\npartitionedQueue := dbos.NewWorkflowQueue(dbosContext, "user-tasks",\n    dbos.WithPartitionQueue(),\n    dbos.WithGlobalConcurrency(1),\n)\n\ntype Task struct {\n    TaskID string\n    Data   string\n}\n\nfunc processTask(ctx dbos.DBOSContext, task Task) (string, error) {\n    // Process the task...\n    return fmt.Sprintf("Processed task %s", task.TaskID), nil\n}\n\nfunc onUserTaskSubmission(dbosContext dbos.DBOSContext, userID string, task Task) error {\n    // Partition the task queue by user ID. As the queue has a\n    // maximum concurrency of 1, this means that at most one\n    // task can run at once per user (but tasks from different\n    // users can run concurrently).\n    handle, err := dbos.RunWorkflow(dbosContext, processTask, task,\n        dbos.WithQueue("user-tasks"),\n        dbos.WithQueuePartitionKey(userID),\n    )\n    if err != nil {\n        return fmt.Errorf("failed to enqueue task: %w", err)\n    }\n\n    result, err := handle.GetResult()\n    if err != nil {\n        return fmt.Errorf("task failed: %w", err)\n    }\n\n    fmt.Printf("Task completed: %s\\n", result)\n    return nil\n}\n'})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Partition keys are required when enqueueing to a partitioned queue."}),"\n",(0,o.jsx)(n.li,{children:"Partition keys cannot be used with non-partitioned queues."}),"\n",(0,o.jsx)(n.li,{children:"Partition keys and deduplication IDs cannot be used together."}),"\n"]})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var t=r(6540);const o={},s=t.createContext(o);function i(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);