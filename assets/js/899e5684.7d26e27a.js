"use strict";(self.webpackChunkoperon_docs=self.webpackChunkoperon_docs||[]).push([[602],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),k=o,m=d["".concat(s,".").concat(k)]||d[k]||u[k]||r;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=k;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:o,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},1596:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:4,title:"Operon Contexts Reference"},i="Operon Context Reference",l={unversionedId:"api-reference/contexts",id:"api-reference/contexts",title:"Operon Contexts Reference",description:"- Background Information",source:"@site/docs/api-reference/contexts.md",sourceDirName:"api-reference",slug:"/api-reference/contexts",permalink:"/operon-docs/api-reference/contexts",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Operon Contexts Reference"},sidebar:"tutorialSidebar",previous:{title:"Decorator Reference",permalink:"/operon-docs/api-reference/decorators"},next:{title:"Workflow Handles",permalink:"/operon-docs/api-reference/workflow-handles"}},s={},p=[{value:"Background Information",id:"background-information",level:2},{value:"Contexts Reference",id:"contexts-reference",level:2},{value:"<code>OperonContext</code>",id:"operoncontext",level:3},{value:"Properties",id:"properties",level:4},{value:"Methods",id:"methods",level:4},{value:"ctxt.request",id:"ctxtrequest",level:4},{value:"ctxt.workflowUUID",id:"ctxtworkflowuuid",level:4},{value:"ctxt.authenticatedUser",id:"ctxtauthenticateduser",level:4},{value:"ctxt.logger",id:"ctxtlogger",level:4},{value:"ctxt.span",id:"ctxtspan",level:4},{value:"ctxt.getConfig(key)",id:"ctxtgetconfigkey",level:4},{value:"<code>HandlerContext</code>",id:"handlercontext",level:3},{value:"Properties",id:"properties-1",level:4},{value:"Methods",id:"methods-1",level:4},{value:"handlerCtxt.koaContext",id:"handlerctxtkoacontext",level:4},{value:"handlerCtxt.invoke(targetClass, [workflowUUID])",id:"handlerctxtinvoketargetclass-workflowuuid",level:4},{value:"handlerCtxt.retrieveWorkflow(workflowUUID)",id:"handlerctxtretrieveworkflowworkflowuuid",level:4},{value:"handlerCtxt.send(destinationUUID, message, [topic, idempotencyKey])",id:"handlerctxtsenddestinationuuid-message-topic-idempotencykey",level:4},{value:"handlerCtxt.getEvent(workflowUUID, key, [timeoutSeconds])",id:"handlerctxtgeteventworkflowuuid-key-timeoutseconds",level:4},{value:"<code>WorkflowContext</code>",id:"workflowcontext",level:3},{value:"Methods",id:"methods-2",level:4},{value:"workflowCtxt.invoke(targetClass)",id:"workflowctxtinvoketargetclass",level:4},{value:"workflowCtxt.childWorkflow(wf, ...args)",id:"workflowctxtchildworkflowwf-args",level:4},{value:"workflowCtxt.send(destinationUUID, message, [topic])",id:"workflowctxtsenddestinationuuid-message-topic",level:4},{value:"workflowCtxt.recv([topic, timeoutSeconds])",id:"workflowctxtrecvtopic-timeoutseconds",level:4},{value:"workflowCtxt.setEvent(key, value)",id:"workflowctxtseteventkey-value",level:4},{value:"<code>TransactionContext&lt;T&gt;</code>",id:"transactioncontextt",level:3},{value:"Generic Type Parameter",id:"generic-type-parameter",level:4},{value:"Properties",id:"properties-2",level:4},{value:"transactionCtxt.client",id:"transactionctxtclient",level:4},{value:"<code>CommunicatorContext</code>",id:"communicatorcontext",level:3},{value:"Properties",id:"properties-3",level:4},{value:"communicatorCtxt.retriesAllowed",id:"communicatorctxtretriesallowed",level:4},{value:"communicatorCtxt.maxAttempts",id:"communicatorctxtmaxattempts",level:4}],c={toc:p},d="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"operon-context-reference"},"Operon Context Reference"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#background-information"},"Background Information")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#contexts-reference"},"Contexts Reference"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#operoncontext"},(0,o.kt)("inlineCode",{parentName:"a"},"OperonContext"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#handlercontext"},(0,o.kt)("inlineCode",{parentName:"a"},"HandlerContext"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#workflowcontext"},(0,o.kt)("inlineCode",{parentName:"a"},"WorkflowContext"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#transactioncontextt"},(0,o.kt)("inlineCode",{parentName:"a"},"TransactionContext<T>"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#communicatorcontext"},(0,o.kt)("inlineCode",{parentName:"a"},"CommunicatorContext")))))),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"background-information"},"Background Information"),(0,o.kt)("p",null,"A context is the first argument of any Operon functions, which provides critical methods for interacting with other functions and the database, and passes useful information along the call graph of functions.\nThe context must be consistent with the decorator you apply to it.\nDifferent types of contexts are not interchangeable:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"All types of contexts share the same properties and methods defined in the base ",(0,o.kt)("a",{parentName:"li",href:"#operoncontext"},(0,o.kt)("inlineCode",{parentName:"a"},"OperonContext")),"."),(0,o.kt)("li",{parentName:"ul"},"The first argument of a handler must takes in a ",(0,o.kt)("a",{parentName:"li",href:"#handlercontext"},(0,o.kt)("inlineCode",{parentName:"a"},"HandlerContext")),"."),(0,o.kt)("li",{parentName:"ul"},"The first argument of a workflow must takes in a ",(0,o.kt)("a",{parentName:"li",href:"#workflowcontext"},(0,o.kt)("inlineCode",{parentName:"a"},"WorkflowContext")),"."),(0,o.kt)("li",{parentName:"ul"},"The first argument of a transaction must takes in a ",(0,o.kt)("a",{parentName:"li",href:"#transactioncontextt"},(0,o.kt)("inlineCode",{parentName:"a"},"TransactionContext<T>"))," with a specific database client type."),(0,o.kt)("li",{parentName:"ul"},"The first argument of a communicator must takes in a ",(0,o.kt)("a",{parentName:"li",href:"#communicatorcontext"},(0,o.kt)("inlineCode",{parentName:"a"},"CommunicatorContext")),".")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"contexts-reference"},"Contexts Reference"),(0,o.kt)("h3",{id:"operoncontext"},(0,o.kt)("inlineCode",{parentName:"h3"},"OperonContext")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"OperonContext")," is the base of all other types of contexts.\nYou don't directly use this base context in your functions, but when an Operon function invokes other functions using its context, Operon automatically propagates the properties of its base context across invocations."),(0,o.kt)("h4",{id:"properties"},"Properties"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#ctxtrequest"},"request")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#ctxtworkflowuuid"},"workflowUUID")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#ctxtauthenticateduser"},"authenticatedUser")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#ctxtlogger"},"logger")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#ctxtspan"},"span"))),(0,o.kt)("h4",{id:"methods"},"Methods"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#ctxtgetconfigkey"},"getConfig(key)"))),(0,o.kt)("h4",{id:"ctxtrequest"},"ctxt.request"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"readonly request: HTTPRequest\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"request")," property includes useful information of an HTTP request (all fields are optional and may be ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface HTTPRequest {\n  headers?: IncomingHttpHeaders; // A node's http.IncomingHttpHeaders object.\n  rawHeaders?: string[]; // Raw headers.\n  params?: unknown; // Parsed path parameters from the URL.\n  body?: unknown; // parsed HTTP body as an object.\n  rawBody?: string; // Unparsed raw HTTP body string.\n  query?: ParsedUrlQuery; // Parsed query string.\n  querystring?: string; // Unparsed raw query string.\n  url?: string; // Request URL.\n  ip?: string; // Request remote address.\n}\n")),(0,o.kt)("h4",{id:"ctxtworkflowuuid"},"ctxt.workflowUUID"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"readonly workflowUUID: string\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"workflowUUID")," property is the current workflow's ",(0,o.kt)("a",{parentName:"p",href:"../tutorials/workflow-tutorial#workflow-identity"},"identity UUID"),", a 128-bit UUID in string format that uniquely identifies that workflow's execution."),(0,o.kt)("p",null,"Operon passes the identity UUID of a workflow to the contexts of transactions and communicators it invokes.\nIf a workflow invokes a ",(0,o.kt)("a",{parentName:"p",href:"#workflowctxtchildworkflowwf-args"},"child workflow"),", the context of the child workflow will have the parent's UUID as the prefix."),(0,o.kt)("p",null,"This field is an empty string in ",(0,o.kt)("a",{parentName:"p",href:"#handlercontext"},(0,o.kt)("inlineCode",{parentName:"a"},"HandlerContext")),", as a handler is not part of any workflows."),(0,o.kt)("h4",{id:"ctxtauthenticateduser"},"ctxt.authenticatedUser"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"readonly authenticatedUser: string\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"authenticatedUser")," property is the identity of the current authenticated user that runs this function.\nThe ",(0,o.kt)("a",{parentName:"p",href:".."},"authentication middleware")," parses the HTTP request and returns this identity.\nOperon passes the authenticated user identity when an Operon function uses its context to invoke other functions."),(0,o.kt)("h4",{id:"ctxtlogger"},"ctxt.logger"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"readonly logger: OperonLogger\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"logger")," property is a global logger that provides useful methods for logging at multiple levels.\nPlease see our ",(0,o.kt)("a",{parentName:"p",href:"/operon-docs/tutorials/logging#logging"},"logging tutorial")," for more information."),(0,o.kt)("h4",{id:"ctxtspan"},"ctxt.span"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"readonly span: Span\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"span")," property is the current ",(0,o.kt)("a",{parentName:"p",href:"https://opentelemetry.io/docs/concepts/signals/traces/#spans"},"OpenTelemetry Span"),".\nYou can set custom trace attributes to this span. Please see our ",(0,o.kt)("a",{parentName:"p",href:"/operon-docs/tutorials/logging#tracing"},"tracing tutorial")," for more information."),(0,o.kt)("h4",{id:"ctxtgetconfigkey"},"ctxt.getConfig(key)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"getConfig(key: string): any\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"getConfig()")," method returns the value/object of the specified ",(0,o.kt)("a",{parentName:"p",href:"/operon-docs/api-reference/configuration#application-configuration"},"application configuration"),"."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"handlercontext"},(0,o.kt)("inlineCode",{parentName:"h3"},"HandlerContext")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"HandlerContext")," is the first argument of handler functions, which extends ",(0,o.kt)("inlineCode",{parentName:"p"},"OperonContext")," and provides additional information on the HTTP request and response, and contains useful methods to invoke other functions and interact with workflows."),(0,o.kt)("h4",{id:"properties-1"},"Properties"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#handlerctxtkoacontext"},"koaContext"))),(0,o.kt)("h4",{id:"methods-1"},"Methods"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#handlerctxtinvoketargetclass-workflowuuid"},"invoke(targetClass, ","[","workflowUUID","]",")")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#handlerctxtretrieveworkflowworkflowuuid"},"retrieveWorkflow(workflowUUID)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#handlerctxtsenddestinationuuid-message-topic-idempotencykey"},"send(destinationUUID, message, ","[","topic, idempotencyKey","]",")")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#handlerctxtgeteventworkflowuuid-key-timeoutseconds"},"getEvent(workflowUUID, key, ","[","timeoutSeconds","]",")"))),(0,o.kt)("h4",{id:"handlerctxtkoacontext"},"handlerCtxt.koaContext"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"koaContext: Koa.Context;\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"koaContext")," property stores the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/koajs/koa/blob/master/docs/api/context.md"},"Koa Context")," of the current request serving.\nIt allows handlers to have full access and control over the raw request and response objects.\nPlease see our ",(0,o.kt)("a",{parentName:"p",href:"/operon-docs/tutorials/http-serving-tutorial"},"HTTP serving")," for more information."),(0,o.kt)("h4",{id:"handlerctxtinvoketargetclass-workflowuuid"},"handlerCtxt.invoke(targetClass, ","[","workflowUUID","]",")"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"invoke<T>(targetClass: T, workflowUUID?: string): InvokeFuncs<T>\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"invoke()")," method returns a list of workflows, transactions, and communicators in the specified ",(0,o.kt)("inlineCode",{parentName:"p"},"targetClass"),".\nWe transform each returned function to exclude its first parameter (the context) and only contain the tail parameters, so you can then invoke a function without needing to worry about how to construct the first context parameter."),(0,o.kt)("p",null,"For example, as we show in ",(0,o.kt)("a",{parentName:"p",href:"/operon-docs/getting-started/quickstart-programming-1"},"Programming Quickstart"),", you only need to provide the second parameter ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," when you invoke ",(0,o.kt)("inlineCode",{parentName:"p"},"helloTransaction"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"return handlerCtxt.invoke(Hello).helloTransaction(name);\n")),(0,o.kt)("p",null,"For transactions and communicators, the invoked function returns its output.\nHowever, for workflows, the invoked function returns a ",(0,o.kt)("a",{parentName:"p",href:"/operon-docs/api-reference/workflow-handles"},"Workflow Handle")," so that you can asynchronously invoke a workflow from a handler.\nFor example, you can invoke a workflow ",(0,o.kt)("inlineCode",{parentName:"p"},"helloWorkflow")," and retrieve its result:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const workflowHandle = await handlerCtxt.invoke(Hello).helloWorkflow(name);\nconst result = await workflowHandle.getResult();\n")),(0,o.kt)("p",null,"Optionally, you can pass in an ",(0,o.kt)("a",{parentName:"p",href:"/operon-docs/tutorials/idempotency-tutorial"},"idempotency key")," to guarantee the invocation only executes once.\nYou should not reuse the returned list of the ",(0,o.kt)("inlineCode",{parentName:"p"},"invoke()")," method, because each idempotency key should only be used once."),(0,o.kt)("h4",{id:"handlerctxtretrieveworkflowworkflowuuid"},"handlerCtxt.retrieveWorkflow(workflowUUID)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"retrieveWorkflow<R>(workflowUUID: string): WorkflowHandle<R>\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"retrieveWorkflow()")," method returns a ",(0,o.kt)("a",{parentName:"p",href:"/operon-docs/api-reference/workflow-handles"},"Workflow Handle")," for the workflow that has the given identity UUID.\nThe type ",(0,o.kt)("inlineCode",{parentName:"p"},"R")," is the return type of the target workflow."),(0,o.kt)("h4",{id:"handlerctxtsenddestinationuuid-message-topic-idempotencykey"},"handlerCtxt.send(destinationUUID, message, ","[","topic, idempotencyKey","]",")"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"send<T extends NonNullable<any>>(destinationUUID: string, message: T, topic?: string, idempotencyKey?: string): Promise<void>\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"send()")," method sends a provided message to a destination workflow identity. Messages can optionally be associated with a ",(0,o.kt)("inlineCode",{parentName:"p"},"topic")," and are queued on the receiver per topic.\nThe message may be sent multiple times and the receiver may receive duplicated messages, because a handler can potentially execute multiple times during failures, but you can specify an ",(0,o.kt)("inlineCode",{parentName:"p"},"idempotencyKey")," for the message to be sent exactly once."),(0,o.kt)("h4",{id:"handlerctxtgeteventworkflowuuid-key-timeoutseconds"},"handlerCtxt.getEvent(workflowUUID, key, ","[","timeoutSeconds","]",")"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"getEvent<T extends NonNullable<any>>(workflowUUID: string, key: string, timeoutSeconds?: number): Promise<T | null>\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"getEvent")," method retrieves the value published by a workflow identity for a given key.\nOptionally, you can specify a ",(0,o.kt)("inlineCode",{parentName:"p"},"timeoutSeconds")," so the method would return ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," if the value is still unavailable after the specified time period."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"workflowcontext"},(0,o.kt)("inlineCode",{parentName:"h3"},"WorkflowContext")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"WorkflowContext")," is the first argument of workflow functions, which extends ",(0,o.kt)("inlineCode",{parentName:"p"},"OperonContext")," and provides useful methods to invoke other functions and interact with other workflows."),(0,o.kt)("h4",{id:"methods-2"},"Methods"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#workflowctxtinvoketargetclass"},"invoke(targetClass)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#workflowctxtchildworkflowwf-args"},"childWorkflow(wf, ...args)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#workflowctxtsenddestinationuuid-message-topic"},"send(destinationUUID, message, ","[","topic","]",")")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#workflowctxtrecvtopic-timeoutseconds"},"recv(","[","topic, timeoutSeconds","]",")")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#workflowctxtseteventkey-value"},"setEvent(key, value)"))),(0,o.kt)("h4",{id:"workflowctxtinvoketargetclass"},"workflowCtxt.invoke(targetClass)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"invoke<T>(targetClass: T): WFInvokeFuncs<T>\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"invoke()")," method returns a list of transactions and communicators in the specified ",(0,o.kt)("inlineCode",{parentName:"p"},"targetClass"),".\nWe transform each returned function to exclude its first parameter (the context) and only contain the tail parameters, and preserve its return type, so you can then invoke a transaction or communicator without needing to worry about how to construct the first context parameter."),(0,o.kt)("p",null,"For example, in our ",(0,o.kt)("a",{parentName:"p",href:"/operon-docs/tutorials/workflow-tutorial"},"Worklows tutorial")," we invoke the ",(0,o.kt)("inlineCode",{parentName:"p"},"helloTransaction")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"postmanFunction")," within the ",(0,o.kt)("inlineCode",{parentName:"p"},"helloWorkflow"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const greeting = await wfCtxt.invoke(Hello).helloTransaction(name);\n...\nawait wfCtxt.invoke(Hello).postmanFunction(greeting);\n")),(0,o.kt)("p",null,"Operon automatically propagates the current workflow identity UUID to the invoked functions, and the invocations are guaranteed to happen exactly once."),(0,o.kt)("h4",{id:"workflowctxtchildworkflowwf-args"},"workflowCtxt.childWorkflow(wf, ...args)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"childWorkflow<T extends any[], R>(wf: OperonWorkflow<T, R>, ...args: T): Promise<WorkflowHandle<R>>\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"childWorkflow()")," method invokes a child workflow and returns a ",(0,o.kt)("a",{parentName:"p",href:"/operon-docs/api-reference/workflow-handles"},"Workflow handle"),".\nThe child workflow is deterministically assigned with an identity UUID which has the parent workflow's identity UUID as the prefix, so the invocations are guaranteed to happen exactly once."),(0,o.kt)("p",null,"For example, you can invoke the ",(0,o.kt)("inlineCode",{parentName:"p"},"helloWorkflow")," as a child workflow from within the current workflow:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const workflowHandle = await workflowCtxt.childWorkflow(helloWorkflow, name);\nconst result = await workflowHandle.getResult();\n")),(0,o.kt)("h4",{id:"workflowctxtsenddestinationuuid-message-topic"},"workflowCtxt.send(destinationUUID, message, ","[","topic","]",")"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"send<T extends NonNullable<any>>(destinationUUID: string, message: T, topic?: string): Promise<void>\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"send()")," method sends a provided message to a destination workflow identity. Messages can optionally be associated with a ",(0,o.kt)("inlineCode",{parentName:"p"},"topic")," and are queued on the receiver per topic.\nThis method is guaranteed to send a message exactly once."),(0,o.kt)("h4",{id:"workflowctxtrecvtopic-timeoutseconds"},"workflowCtxt.recv(","[","topic, timeoutSeconds","]",")"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"recv<T extends NonNullable<any>>(topic?: string, timeoutSeconds?: number): Promise<T | null>\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"recv()")," method waits for and consumes the next message to arrive in its message queue, optionally for a particular topic.\nIf the ",(0,o.kt)("inlineCode",{parentName:"p"},"topic")," is not specified, this method only receives messages sent without a topic.\nThis method guarantees that a message is consumed only once."),(0,o.kt)("p",null,"Optionally, you can also specify a ",(0,o.kt)("inlineCode",{parentName:"p"},"timeoutSeconds")," so the method returns ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," if no message is received after the specified time period."),(0,o.kt)("h4",{id:"workflowctxtseteventkey-value"},"workflowCtxt.setEvent(key, value)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"setEvent<T extends NonNullable<any>>(key: string, value: T): Promise<void>\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"setEvent()")," method immutably emits a key-value pair associated with its identity.\nIt throws an error if a workflow tries to set the same key twice."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"transactioncontextt"},(0,o.kt)("inlineCode",{parentName:"h3"},"TransactionContext<T>")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"TransactionContext")," is the first argument of transaction functions, which extends ",(0,o.kt)("inlineCode",{parentName:"p"},"OperonContext")," and provides a user database client for functions to execute data operations transactionally."),(0,o.kt)("h4",{id:"generic-type-parameter"},"Generic Type Parameter"),(0,o.kt)("p",null,"Transaction context has a generic type parameter ",(0,o.kt)("inlineCode",{parentName:"p"},"TransactionContext<T extends UserDatabaseClient>"),", where Operon currently supports:"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://knexjs.org/guide/#typescript"},"Knex")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'import { Knex } from "knex";\n// TransactionContext<Knex>\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://orkhan.gitbook.io/typeorm/docs/entity-manager-api"},"TypeORM EntityManager")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'import { EntityManager } from "typeorm";\n// TransactionContext<EntityManager>\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.prisma.io/docs/concepts/components/prisma-client"},"PrismaClient")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'import { PrismaClient } from "@prisma/client";\n// TransactionContext<PrismaClient>\n')),(0,o.kt)("p",null,"The provided database client type must be consistent with the ",(0,o.kt)("a",{parentName:"p",href:"/operon-docs/api-reference/configuration#user_dbclient"},(0,o.kt)("inlineCode",{parentName:"a"},"user_dbclient")," configuration"),".\nOperon guarantees that all data operations in a transaction function are executed in the same database transaction."),(0,o.kt)("h4",{id:"properties-2"},"Properties"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#transactionctxtclient"},"client"))),(0,o.kt)("h4",{id:"transactionctxtclient"},"transactionCtxt.client"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"client: T; // One of [Knex, EntityManager, PrismaClient]\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"client")," property is a Knex/TypeORM Entity Manager/PrismaClient object.\nA transaction function should only interact with the user database using this client."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"communicatorcontext"},(0,o.kt)("inlineCode",{parentName:"h3"},"CommunicatorContext")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CommunicatorContext")," is the first argument of communicator functions, which extends ",(0,o.kt)("inlineCode",{parentName:"p"},"OperonContext")," and provides information on the communicator's configuration."),(0,o.kt)("h4",{id:"properties-3"},"Properties"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#communicatorctxtretriesallowed"},"retriesAllowed")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#communicatorctxtmaxattempts"},"maxAttempts"))),(0,o.kt)("h4",{id:"communicatorctxtretriesallowed"},"communicatorCtxt.retriesAllowed"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"readonly retriesAllowed: boolean;\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"retriesAllowed")," property specifies whether the communicator can be automatically retried on failures."),(0,o.kt)("h4",{id:"communicatorctxtmaxattempts"},"communicatorCtxt.maxAttempts"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"readonly maxAttempts: number;\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"maxAttempts")," property specifies the maximum number of retries (if allowed) on failures."))}u.isMDXComponent=!0}}]);