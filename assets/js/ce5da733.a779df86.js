"use strict";(self.webpackChunkoperon_docs=self.webpackChunkoperon_docs||[]).push([[217],{3905:(n,e,t)=>{t.d(e,{Zo:()=>c,kt:()=>u});var o=t(7294);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,o)}return t}function r(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,o,i=function(n,e){if(null==n)return{};var t,o,i={},a=Object.keys(n);for(o=0;o<a.length;o++)t=a[o],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(o=0;o<a.length;o++)t=a[o],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var l=o.createContext({}),p=function(n){var e=o.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):r(r({},e),n)),t},c=function(n){var e=p(n.components);return o.createElement(l.Provider,{value:e},n.children)},g="mdxType",m={inlineCode:"code",wrapper:function(n){var e=n.children;return o.createElement(o.Fragment,{},e)}},f=o.forwardRef((function(n,e){var t=n.components,i=n.mdxType,a=n.originalType,l=n.parentName,c=s(n,["components","mdxType","originalType","parentName"]),g=p(t),f=i,u=g["".concat(l,".").concat(f)]||g[f]||m[f]||a;return t?o.createElement(u,r(r({ref:e},c),{},{components:t})):o.createElement(u,r({ref:e},c))}));function u(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var a=t.length,r=new Array(a);r[0]=f;var s={};for(var l in e)hasOwnProperty.call(e,l)&&(s[l]=e[l]);s.originalType=n,s[g]="string"==typeof n?n:i,r[1]=s;for(var p=2;p<a;p++)r[p]=t[p];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}f.displayName="MDXCreateElement"},3929:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var o=t(7462),i=(t(7294),t(3905));const a={sidebar_position:6,title:"Workflows communication",description:"Two workflows play ping pong"},r=void 0,s={unversionedId:"tutorials/t5-ping-pong",id:"tutorials/t5-ping-pong",title:"Workflows communication",description:"Two workflows play ping pong",source:"@site/docs/tutorials/t5-ping-pong.mdx",sourceDirName:"tutorials",slug:"/tutorials/t5-ping-pong",permalink:"/operon-docs/tutorials/t5-ping-pong",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"Workflows communication",description:"Two workflows play ping pong"},sidebar:"tutorialSidebar",previous:{title:"Asynchronous workflows",permalink:"/operon-docs/tutorials/t4-async-workflows"},next:{title:"Third party calls",permalink:"/operon-docs/tutorials/t6-third-party"}},l={},p=[{value:"Final code",id:"final-code",level:2}],c={toc:p},g="wrapper";function m(n){let{components:e,...t}=n;return(0,i.kt)(g,(0,o.Z)({},c,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Workflows can communicate with each other. Specifically, using ",(0,i.kt)("a",{parentName:"p",href:"../api-reference/contexts#workflowcontext"},"WorkflowContext"),", you can send a generic message to a destination workflow using its UUID."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"send<T extends NonNullable<any>>(destinationUUID: string, message: T, topic?: string | null): Promise<void>;\n")),(0,i.kt)("p",null,"Likewise, from a ",(0,i.kt)("a",{parentName:"p",href:"../api-reference/contexts#workflowcontext"},"WorkflowContext"),", you can receive a message:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"recv<T extends NonNullable<any>>(topic?: string | null, timeoutSeconds?: number): Promise<T | null>\n")),(0,i.kt)("p",null,"Note that send and receive can be filtered by topics."),(0,i.kt)("p",null,"Let's build an Operon application that, upon receiving a network request, starts two workflows exchanging message with each other."),(0,i.kt)("p",null,"First, we will write the HTTP handler:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'  @GetApi("/pingpong")\n  static async pingPongEndpoint(ctx: HandlerContext) {\n    const pongHandle = await ctx.invoke(PingPong).pong();\n    const pongUUID = pongHandle.getWorkflowUUID();\n\n    const pinghandle = await ctx.invoke(PingPong).ping(pongUUID);\n    const pingUUID = pinghandle.getWorkflowUUID();\n\n    await new Promise((r) => setTimeout(r, 50));\n\n    await ctx.send(pongUUID, "stop", "stopTopic");\n    return await ctx.send(pingUUID, "stop", "stopTopic");\n  }\n')),(0,i.kt)("p",null,"The handler first invokes a workflow named ",(0,i.kt)("inlineCode",{parentName:"p"},"pong")," and uses its handler to retrieve its UUID.\nIt then invokes a second workflow named ",(0,i.kt)("inlineCode",{parentName:"p"},"ping"),", passing it ",(0,i.kt)("inlineCode",{parentName:"p"},"pong"),"'s UUID as parameter.\nIt then goes on to sleep for 50ms, then sends a ",(0,i.kt)("inlineCode",{parentName:"p"},"stop")," message to ",(0,i.kt)("inlineCode",{parentName:"p"},"ping")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"pong")," on a topic named ",(0,i.kt)("inlineCode",{parentName:"p"},"stopTopic"),"."),(0,i.kt)("p",null,"Let's look at ",(0,i.kt)("inlineCode",{parentName:"p"},"ping"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'  @OperonWorkflow()\n  static async ping(wfCtxt: WorkflowContext, pongUUID: string) {\n    let running: boolean = true;\n    wfCtxt.recv("stopTopic").then((m) => {\n      if (m) {\n        wfCtxt.info("[PING] received stop notification");\n        running = false;\n      }\n    });\n\n    const message: Message = {\n      senderUUID: wfCtxt.workflowUUID,\n      message: "ping",\n    };\n    await wfCtxt.send(pongUUID, message);\n    while (running) {\n      const m = (await wfCtxt.recv<string>()) as Message;\n      if (m) {\n        wfCtxt.info(`[PING] received ${m.message}`);\n        await wfCtxt.send(pongUUID, message);\n      }\n    }\n  }\n')),(0,i.kt)("p",null,"First, the workflow starts listening on the ",(0,i.kt)("inlineCode",{parentName:"p"},"stopTopic"),".\nOnce this promise is resolved, it will flip a boolean flag named ",(0,i.kt)("inlineCode",{parentName:"p"},"running")," to know when to exit.\nThen, it sets a message with its UUID and sends the first message to ",(0,i.kt)("inlineCode",{parentName:"p"},"pong"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Message")," is user-defined, in this case:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"interface MessengingProtocol {\n  senderUUID: string;\n  message: string;\n}\ntype Message = MessengingProtocol | null;\n")),(0,i.kt)("p",null,"The main loop of the workflow waits for a response from ",(0,i.kt)("inlineCode",{parentName:"p"},"pong"),", logs it, then sends back a ping message."),(0,i.kt)("p",null,"Note the following with respect to sending and receiving workflow messages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"send")," and receive are asynchronous. You can chose to block on them, or register a callback through ",(0,i.kt)("inlineCode",{parentName:"li"},".then"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"recv")," can return a ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," value. This is because the message value itself could be ",(0,i.kt)("inlineCode",{parentName:"li"},"null"),"."),(0,i.kt)("li",{parentName:"ul"},"You can specify the type to use for deserializing the message. In this example, ",(0,i.kt)("inlineCode",{parentName:"li"},"Message"),"."),(0,i.kt)("li",{parentName:"ul"},"Topics are optional. You can use them for specific purposes as demonstrated in this example.")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"pong")," is similar, with the exception it uses the UUID received in the message to determine who to send a pong:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'  @OperonWorkflow()\n  static async pong(wfCtxt: WorkflowContext) {\n    let running: boolean = true;\n    wfCtxt.recv("stopTopic").then((m) => {\n      if (m) {\n        wfCtxt.info("[PONG] received stop notification");\n        running = false;\n      }\n    });\n\n    while (running) {\n      const m = await wfCtxt.recv<Message>();\n      if (m) {\n        wfCtxt.info(`[PONG] received ${m.message}`);\n        m.message = "pong";\n        await wfCtxt.send(m.senderUUID, m);\n      }\n    }\n  }\n')),(0,i.kt)("h2",{id:"final-code"},"Final code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'import {\n  HandlerContext,\n  GetApi,\n  OperonWorkflow,\n  WorkflowContext,\n} from "@dbos-inc/operon";\n\ninterface MessengingProtocol {\n  senderUUID: string;\n  message: string;\n}\ntype Message = MessengingProtocol | null;\n\nexport class PingPong {\n  @OperonWorkflow()\n  static async pong(wfCtxt: WorkflowContext) {\n    let running: boolean = true;\n    wfCtxt.recv("stopTopic").then((m) => {\n      if (m) {\n        wfCtxt.info("[PONG] received stop notification");\n        running = false;\n      }\n    });\n\n    while (running) {\n      const m = await wfCtxt.recv<Message>();\n      if (m) {\n        wfCtxt.info(`[PONG] received ${m.message}`);\n        m.message = "pong";\n        await wfCtxt.send(m.senderUUID, m);\n      }\n    }\n  }\n\n  @OperonWorkflow()\n  static async ping(wfCtxt: WorkflowContext, pongUUID: string) {\n    let running: boolean = true;\n    wfCtxt.recv("stopTopic").then((m) => {\n      if (m) {\n        wfCtxt.info("[PING] received stop notification");\n        running = false;\n      }\n    });\n\n    const message: Message = {\n      senderUUID: wfCtxt.workflowUUID,\n      message: "ping",\n    };\n    await wfCtxt.send(pongUUID, message);\n    while (running) {\n      const m = await wfCtxt.recv<Message>();\n      if (m) {\n        wfCtxt.info(`[PING] received ${m.message}`);\n        await wfCtxt.send(pongUUID, message);\n      }\n    }\n  }\n\n  @GetApi("/pingpong")\n  static async pingPongEndpoint(ctx: HandlerContext) {\n    const pongHandle = await ctx.invoke(PingPong).pong();\n    const pongUUID = pongHandle.getWorkflowUUID();\n\n    const pinghandle = await ctx.invoke(PingPong).ping(pongUUID);\n    const pingUUID = pinghandle.getWorkflowUUID();\n\n    await new Promise((r) => setTimeout(r, 50));\n\n    await ctx.send(pingUUID, "stop", "stopTopic");\n    return await ctx.send(pongUUID, "stop", "stopTopic");\n  }\n}\n')))}m.isMDXComponent=!0}}]);