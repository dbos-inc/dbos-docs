"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[8933],{3290:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>f,frontMatter:()=>a,metadata:()=>o,toc:()=>u});const o=JSON.parse('{"id":"typescript/prompting","title":"AI Model Prompting","description":"You may want assistance from an AI model in building a DBOS application.","source":"@site/docs/typescript/prompting.md","sourceDirName":"typescript","slug":"/typescript/prompting","permalink":"/typescript/prompting","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":30,"frontMatter":{"sidebar_position":30,"title":"AI Model Prompting"},"sidebar":"tutorialSidebar","previous":{"title":"Add DBOS To Your App","permalink":"/typescript/integrating-dbos"},"next":{"title":"Workflows","permalink":"/typescript/tutorials/workflow-tutorial"}}');var s=t(4848),r=t(8453);const a={sidebar_position:30,title:"AI Model Prompting"},i=void 0,l={},u=[{value:"How To Use",id:"how-to-use",level:2},{value:"Prompt",id:"prompt",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"You may want assistance from an AI model in building a DBOS application.\nTo make sure your model has the latest information on how to use DBOS, provide it with this prompt."}),"\n",(0,s.jsx)(n.h2,{id:"how-to-use",children:"How To Use"}),"\n",(0,s.jsx)(n.p,{children:"First, use the click-to-copy button in the top right of the code block to copy the full prompt to your clipboard.\nThen, paste into your AI tool of choice (for example OpenAI's ChatGPT or Anthropic's Claude).\nThis adds the prompt to your AI model's context, giving it up-to-date instructions on how to build an application with DBOS."}),"\n",(0,s.jsx)(n.p,{children:"If you are using an AI-powered IDE, you can add this prompt to your project's context.\nFor example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Claude Code: Add the prompt, or a link to it, to your CLAUDE.md file."}),"\n",(0,s.jsxs)(n.li,{children:["Cursor: Add the prompt to ",(0,s.jsx)(n.a,{href:"https://docs.cursor.com/context/rules-for-ai",children:"your project rules"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Zed: Copy the prompt to a file in your project, then use the ",(0,s.jsx)(n.a,{href:"https://zed.dev/docs/assistant/commands?highlight=%2Ffile#file",children:(0,s.jsx)(n.code,{children:"/file"})})," command to add the file to your context."]}),"\n",(0,s.jsxs)(n.li,{children:["GitHub Copilot: Create a ",(0,s.jsx)(n.a,{href:"https://docs.github.com/en/copilot/customizing-copilot/adding-repository-custom-instructions-for-github-copilot",children:(0,s.jsx)(n.code,{children:".github/copilot-instructions.md"})})," file in your repository and add the prompt to it."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"prompt",children:"Prompt"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",children:'# Build Reliable Applications With DBOS\n\n## Guidelines\n\n- Respond in a friendly and concise manner\n- Ask clarifying questions when requirements are ambiguous\n- Generate code in TypeScript using the DBOS library. Make sure to fully type everything.\n- You MUST import all methods and classes used in the code you generate\n- You SHALL keep all code in a single file unless otherwise specified.\n- You MUST await all promises.\n- DBOS does NOT stand for anything.\n\n## Workflow Guidelines\n\nWorkflows provide durable execution so you can write programs that are resilient to any failure.\nWorkflows are comprised of steps, which are ordinary TypeScript functions called with DBOS.runStep().\nWhen using DBOS workflows, you should call any function that performs complex operations or accesses external APIs or services as a step using DBOS.runStep.\n\nIf a workflow is interrupted for any reason (e.g., an executor restarts or crashes), when your program restarts the workflow automatically resumes execution from the last completed step.\n\n- If asked to add DBOS to existing code, you MUST ask which function to make a workflow. Do NOT recommend any changes until they have told you what function to make a workflow. Do NOT make a function a workflow unless SPECIFICALLY requested.\n- When making a function a workflow, you should make all functions it calls steps. Do NOT change the functions in any way.\n- Do NOT make functions steps unless they are DIRECTLY called by a workflow.\n- If the workflow function performs a non-deterministic action, you MUST move that action to its own function and make that function a step. Examples of non-deterministic actions include accessing an external API or service, accessing files on disk, generating a random number, of getting the current time.\n- Do NOT use Promise.all() due to the risks posed by multiple rejections.  Using Promise.allSettled() for parallelism is allowed for single-step promises only.  For any complex parallel execution, you should instead use DBOS.startWorkflow and DBOS queues to achieve the parallelism.\n- DBOS workflows and steps should NOT have side effects in memory outside of their own scope. They can access global variables, but they should NOT create or update global variables or variables outside their scope.\n- Do NOT call any DBOS context method (DBOS.send, DBOS.recv, DBOS.startWorkflow, DBOS.sleep, DBOS.setEvent, DBOS.getEvent) from a step.\n- Do NOT start workflows from inside a step.\n- Do NOT call DBOS.setEvent and DBOS.recv from outside a workflow function.\n- Do NOT use DBOS.getApi, DBOS.postApi, or other DBOS HTTP annotations. These are DEPRECATED. Instead, use Express for HTTP serving by default, unless another web framework is specified.\n\n## DBOS Lifecycle Guidelines\n\nDBOS should be installed and imported from the `@dbos-inc/dbos-sdk` package.\nDue to its internal workflow registry, The DBOS library and DBOS workflows cannot be bundled with JavaScript or TypeScript bundlers (Webpack, Vite, Rollup, esbuild, Parcel, etc.) and must be treated as an external library by these tools.  Configuration for bundlers should be suggested if these tools are in use and cannot be avoided.\n\nDBOS does not support "serverless" frameworks due to its long-running background jobs.  DBOS programs MUST have a starting file (typically \'main.ts\' or \'server.ts\') that creates all objects and workflow functions during startup.\n\nAny DBOS program MUST call DBOS.setConfig and DBOS.launch in its main function, like so.\nYou MUST use this default configuration (changing the name as appropriate) unless otherwise specified.\n\n```javascript\nDBOS.setConfig({\n  "name": "dbos-node-starter",\n  "systemDatabaseUrl": process.env.DBOS_SYSTEM_DATABASE_URL,\n});\nawait DBOS.launch();\n```\n\nHere is an example main function using Express:\n\n```javascript\nimport { DBOS } from "@dbos-inc/dbos-sdk";\n\nasync function main() {\n  DBOS.setConfig({\n    "name": "dbos-node-starter",\n    "systemDatabaseUrl": process.env.DBOS_SYSTEM_DATABASE_URL,\n  });\n  await DBOS.launch();\n  const PORT = 3000;\n  app.listen(PORT, () => {\n    console.log(`\ud83d\ude80 Server is running on http://localhost:${PORT}`);\n  });\n}\n\nmain().catch(console.log);\n```\n\n## Workflow and Steps Examples\n\nSimple example:\n\n\n```javascript\nimport { DBOS } from "@dbos-inc/dbos-sdk";\n\nasync function stepOne() {\n  DBOS.logger.info("Step one completed!");\n}\n\nasync function stepTwo() {\n  DBOS.logger.info("Step two completed!");\n}\n\nasync function exampleFunction() {\n  await DBOS.runStep(() => stepOne());\n  await DBOS.runStep(() => stepTwo());\n}\nconst exampleWorkflow = DBOS.registerWorkflow(exampleFunction);\n\nasync function main() {\n  DBOS.setConfig({\n    "name": "dbos-node-starter",\n    "systemDatabaseUrl": process.env.DBOS_SYSTEM_DATABASE_URL,\n  });\n  await DBOS.launch();\n  await exampleWorkflow();\n  await DBOS.shutdown();\n}\n\nmain().catch(console.log);\n```\n\nExample with Express:\n\n```javascript\nimport { DBOS } from "@dbos-inc/dbos-sdk";\nimport express from "express";\n\nexport const app = express();\napp.use(express.json());\n\nasync function stepOne() {\n  DBOS.logger.info("Step one completed!");\n}\n\nasync function stepTwo() {\n  DBOS.logger.info("Step two completed!");\n}\n\nasync function exampleFunction() {\n  await DBOS.runStep(() => stepOne());\n  await DBOS.runStep(() => stepTwo());\n}\nconst exampleWorkflow = DBOS.registerWorkflow(exampleFunction);\n\napp.get("/", async (req, res) => {\n  await exampleWorkflow();\n  res.send();\n});\n\nasync function main() {\n  DBOS.setConfig({\n    "name": "dbos-node-starter",\n    "systemDatabaseUrl": process.env.DBOS_SYSTEM_DATABASE_URL,\n  });\n  await DBOS.launch();\n  const PORT = 3000;\n  app.listen(PORT, () => {\n    console.log(`\ud83d\ude80 Server is running on http://localhost:${PORT}`);\n  });\n}\n\nmain().catch(console.log);\n```\n\nExample with queues:\n\n```javascript\nimport { DBOS, WorkflowQueue } from "@dbos-inc/dbos-sdk";\nimport express from "express";\n\nexport const app = express();\napp.use(express.json());\n\nconst queue = new WorkflowQueue("example_queue");\n\nasync function taskFunction(n: number) {\n  await DBOS.sleep(5000);\n  DBOS.logger.info(`Task ${n} completed!`)\n}\nconst taskWorkflow = DBOS.registerWorkflow(taskFunction);\n\nasync function queueFunction() {\n  DBOS.logger.info("Enqueueing tasks!")\n  const handles = []\n  for (let i = 0; i < 10; i++) {\n    handles.push(await DBOS.startWorkflow(taskWorkflow, { queueName: queue.name })(i))\n  }\n  const results = []\n  for (const h of handles) {\n    results.push(await h.getResult())\n  }\n  DBOS.logger.info(`Successfully completed ${results.length} tasks`)\n}\nconst queueWorkflow = DBOS.registerWorkflow(queueFunction)\n\napp.get("/", async (req, res) => {\n  await queueWorkflow();\n  res.send();\n});\n\nasync function main() {\n  DBOS.setConfig({\n    "name": "dbos-node-starter",\n    "systemDatabaseUrl": process.env.DBOS_SYSTEM_DATABASE_URL,\n  });\n  await DBOS.launch();\n  const PORT = 3000;\n  app.listen(PORT, () => {\n    console.log(`\ud83d\ude80 Server is running on http://localhost:${PORT}`);\n  });\n}\n\nmain().catch(console.log);\n```\n\n#### Scheduled Workflow\n\nYou can schedule DBOS workflows to run exactly once per time interval.\nTo do this, use the the `DBOS.registerScheduled` method or the `DBOS.scheduled` decorator and specify the schedule in crontab syntax.  For example:\n\n- A scheduled workflow MUST specify a crontab schedule.\n- It MUST take in two arguments, scheduled and actual time. Both are Date of when the workflow started.\n\n```typescript\nasync function scheduledFunction(schedTime: Date, startTime: Date) {\n    DBOS.logger.info(`I am a workflow scheduled to run every 30 seconds`);\n}\n\nconst scheduledWorkflow = DBOS.registerWorkflow(scheduledFunction);\nDBOS.registerScheduled(scheduledWorkflow, {crontab: \'*/30 * * * * *\'});\n```\n\nOr using decorators:\n\n```typescript\nclass ScheduledExample{\n  @DBOS.workflow()\n  @DBOS.scheduled({crontab: \'*/30 * * * * *\'})\n  static async scheduledWorkflow(schedTime: Date, startTime: Date) {\n    DBOS.logger.info(`I am a workflow scheduled to run every 30 seconds`);\n  }\n}\n```\n\n## Workflow Documentation:\n\nTo write a workflow, register a TypeScript function with `DBOS.registerWorkflow`.\nThe function\'s inputs and outputs must be serializable to JSON.\nFor example:\n\n```typescript\nasync function stepOne() {\n  DBOS.logger.info("Step one completed!");\n}\n\nasync function stepTwo() {\n  DBOS.logger.info("Step two completed!");\n}\n\nasync function workflowFunction() {\n  await DBOS.runStep(() => stepOne(), {name: "stepOne"});\n  await DBOS.runStep(() => stepTwo(), {name: "stepTwo"});\n}\nconst workflow = DBOS.registerWorkflow(workflowFunction)\n\nawait workflow();\n```\n\nAlternatively, you can register workflows and steps with decorators:\nNEVER do this unless specifically asked for.\n\n```typescript\nexport class Example {\n  @DBOS.step()\n  static async stepOne() {\n    DBOS.logger.info("Step one completed!");\n  }\n\n  @DBOS.step()\n  static async stepTwo() {\n    DBOS.logger.info("Step two completed!");\n  }\n\n  // Call steps from workflows\n  @DBOS.workflow()\n  static async exampleWorkflow() {\n    await Toolbox.stepOne();\n    await Toolbox.stepTwo();\n  }\n}\n\nawait Example.exampleWorkflow();\n```\n\nIf an exception is thrown from a workflow, the workflow TERMINATES.\nDBOS records the exception, sets the workflow status to `ERROR`, and does not recover the workflow.\n\n## Workflow IDs\n\nEvery time you execute a workflow, that execution is assigned a unique ID, by default a UUID.\nYou can access this ID through the `DBOS.workflowID` context variable.\n\nSet the workflow ID of a workflow with `DBOS.withNextWorkflowID`.\nIf a workflow is called multiple times with the same ID, it executes ONLY ONCE.\n\n```javascript\nclass Example {\n  @DBOS.workflow()\n  static async exampleWorkflow(var1: string, var2: string) {\n      return var1 + var2;\n  }\n}\n\nconst workflowID = "my-workflow-id"\n\nawait DBOS.withNextWorkflowID(workflowID, async () => {\n  return await Example.exampleWorkflow("one", "two");\n});\n```\n\n### DBOS.startWorkflow\n\n```typescript\nstatic startWorkflow<Args extends unknown[], Return>(\n  target: (...args: Args) => Promise<Return>,\n  params?: StartWorkflowParams,\n): (...args: Args) => Promise<WorkflowHandle<Return>>;\n```\n\n```typescript\ninterface StartWorkflowParams {\n  workflowID?: string;\n  queueName?: string;\n  timeoutMS?: number | null;\n  enqueueOptions?: EnqueueOptions;\n}\n\nexport interface EnqueueOptions {\n  deduplicationID?: string;\n  priority?: number;\n}\n```\n\nOne common use-case for workflows is building reliable background tasks that keep running even when your program is interrupted, restarted, or crashes.\nYou can use `DBOS.startWorkflow` to start a workflow in the background.\nYou can optionally enqueue the workflow on a DBOS queue.\nIf you start a workflow this way, it returns a workflow handle, from which you can access information about the workflow or wait for it to complete and retrieve its result.\nThe `DBOS.startWorkflow` method resolves after the workflow is durably started; at this point the workflow is guaranteed to run to completion even if the app is interrupted.\n\n**Example syntax:**\n\nTo start a workflow created by registering a function:\n\n```typescript\nasync function example(input: number) {\n    // Call steps\n}\nconst exampleWorkflow = DBOS.registerWorkflow(example);\n\nconst input = 10;\nconst handle = await DBOS.startWorkflow(exampleWorkflow)(input);\n```\n\nTo start a workflow created by decorating a class method:\n\n```typescript\nexport class Example {\n  @DBOS.workflow()\n  static async exampleWorkflow(input: number) {\n    // Call steps\n  }\n}\n\nconst input = 10;\nconst handle = await DBOS.startWorkflow(Example).exampleWorkflow(input);\n```\n\n**Parameters:**\n\n- **target**: The workflow to start.\n- **workflowID**: An ID to assign to the workflow. If not specified, a random UUID is generated.\n- **queueName**: The name of the queue on which to enqueue this workflow, if any.\n- **timeoutMS**: The timeout of this workflow in milliseconds.\n- **deduplicationID**: Optionally specified when enqueueing a workflow. At any given time, only one workflow with a specific deduplication ID can be enqueued in the specified queue. If a workflow with a deduplication ID is currently enqueued or actively executing (status `ENQUEUED` or `PENDING`), subsequent workflow enqueue attempt with the same deduplication ID in the same queue will raise a `DBOSQueueDuplicatedError` exception.\n- **priority**: Optionally specified when enqueueing a workflow. The priority of the enqueued workflow in the specified queue. Workflows with the same priority are dequeued in **FIFO (first in, first out)** order. Priority values can range from `1` to `2,147,483,647`, where **a low number indicates a higher priority**. Workflows without assigned priorities have the highest priority and are dequeued before workflows with assigned priorities.\n\n\n## Workflow IDs and Idempotency\n\nEvery time you execute a workflow, that execution is assigned a unique ID, by default a UUID.\nYou can access this ID through the `DBOS.workflowID` context variable.\nWorkflow IDs are useful for communicating with workflows and developing interactive workflows.\n\nYou can set the workflow ID of a workflow as an argument to `DBOS.startWorkflow()`.\nWorkflow IDs must be **globally unique** for your application.\nAn assigned workflow ID acts as an idempotency key: if a workflow is called multiple times with the same ID, it executes only once.\nThis is useful if your operations have side effects like making a payment or sending an email.\nFor example:\n\n```javascript\nclass Example {\n    @DBOS.workflow()\n    static async exampleWorkflow(var1: string, var2: string) {\n        // ...\n    }\n}\n\nasync function main() {\n    const myID: string = ...\n    const handle = await DBOS.startWorkflow(Example, {workflowID: myID}).exampleWorkflow("one", "two");\n    const result = await handle.getResult();\n}\n```\n\n## Workflow Events\n\nWorkflows can emit _events_, which are key-value pairs associated with the workflow\'s ID.\nThey are useful for publishing information about the state of an active workflow, for example to transmit information to the workflow\'s caller.\n\n#### setEvent\n\nAny workflow can call `DBOS.setEvent` to publish a key-value pair, or update its value if has already been published.\nONLY call this from a workflow function, NEVER from a step.\n\n```typescript\nDBOS.setEvent<T>(key: string, value: T): Promise<void>\n```\n#### getEvent\n\nYou can call `DBOS.getEvent` to retrieve the value published by a particular workflow identity for a particular key.\nIf the event does not yet exist, this call waits for it to be published, returning `None` if the wait times out.\nNEVER call this from inside a step.\n\n```typescript\nDBOS.getEvent<T>(workflowID: string, key: string, timeoutSeconds?: number): Promise<T | null>\n```\n\n#### Events Example\n\nEvents are especially useful for writing interactive workflows that communicate information to their caller.\nFor example, in one demo, the checkout workflow, after validating an order, needs to send the customer a unique payment ID.\nTo communicate the payment ID to the customer, it uses events.\n\nThe payments workflow emits the payment ID using `setEvent()`:\n\n```javascript\n  @DBOS.workflow()\n  static async checkoutWorkflow(...): Promise<void> {\n    ...\n    const paymentsURL = ...\n    await DBOS.setEvent(PAYMENT_URL, paymentsURL);\n    ... \n  }\n```\n\nThe Express handler that originally started the workflow uses `getEvent()` to await this payment ID, then returns it:\n\n```javascript\nstatic async webCheckout(...): Promise<void> {\nconst handle = await DBOS.startWorkflow(Shop).checkoutWorkflow(...);\nconst paymentID = await DBOS.getEvent<string>(handle.workflowID, PAYMENT_ID_EVENT);\n  if (paymentID === null) {\n    DBOS.logger.error(\'checkout failed\');\n    return reply.code(500).send(\'Error starting checkout\');\n  }\n  return paymentID;\n}\n```\n\n## Workflow Timeouts\n\nYou can set a timeout for a workflow by passing a `timeoutMS` argument to `DBOS.startWorkflow`.\nWhen the timeout expires, the workflow **and all its children** are cancelled.\nCancelling a workflow sets its status to `CANCELLED` and preempts its execution at the beginning of its next step.\n\nTimeouts are **start-to-completion**: a workflow\'s timeout does not begin until the workflow starts execution.\nAlso, timeouts are **durable**: they are stored in the database and persist across restarts, so workflows can have very long timeouts.\n\nExample syntax:\n\n```javascript\nasync function taskFunction(task) {\n    // ...\n}\nconst taskWorkflow = DBOS.registerWorkflow(taskFunction);\n\nasync function main() {\n  const task = ...\n  const timeout = ... // Timeout in milliseconds\n  const handle = await DBOS.startWorkflow(taskWorkflow, {timeoutMS: timeout})(task);\n}\n```\n\n## Durable Sleep\n\nYou can use DBOS.sleep to put your workflow to sleep for any period of time.\nThis sleep is durable, DBOS saves the wakeup time in the database so that even if the workflow is interrupted and restarted multiple times while sleeping, it still wakes up on schedule.\n\nSleeping is useful for scheduling a workflow to run in the future (even days, weeks, or months from now).\nFor example:\n\n```javascript\n@DBOS.workflow()\nstatic async exampleWorkflow(timeToSleep, task) {\n    await DBOS.sleep(timeToSleep);\n    await runTask(task);\n}\n```\n\n## Workflow Messaging and Notifications\nYou can send messages to a specific workflow ID.\nThis is useful for sending notifications to an active workflow.\n\n#### Send\n\nYou can call `DBOS.send()` to send a message to a workflow.\nMessages can optionally be associated with a topic and are queued on the receiver per topic.\nNEVER call this from a step.\n\n```typescript\nDBOS.send<T>(destinationID: string, message: T, topic?: string): Promise<void>;\n```\n\n#### Recv\n\nWorkflows can call `DBOS.recv()` to receive messages sent to them, optionally for a particular topic.\nEach call to `recv()` waits for and consumes the next message to arrive in the queue for the specified topic, returning `None` if the wait times out.\nIf the topic is not specified, this method only receives messages sent without a topic.\nONLY call this from inside a workflow function, NEVER from a step.\n\n```typescript\nDBOS.recv<T>(topic?: string, timeoutSeconds?: number): Promise<T | null>\n```\n\n#### Messages Example\n\nMessages are especially useful for sending notifications to a workflow.\nFor example, in one demo, the checkout workflow, after redirecting customers to a payments page, must wait for a notification that the user has paid.\n\nTo wait for this notification, the payments workflow uses `recv()`, executing failure-handling code if the notification doesn\'t arrive in time:\n\n```javascript\n@DBOS.workflow()\nstatic async checkoutWorkflow(...): Promise<void> {\n  ...\n  const notification = await DBOS.recv<string>(PAYMENT_STATUS, timeout);\n  if (notification) {\n      ... // Handle the notification.\n  } else {\n      ... // Handle a timeout.\n  }\n}\n```\n\nAn endpoint waits for the payment processor to send the notification, then uses `send()` to forward it to the workflow:\n\n```javascript\n@DBOS.postApi(\'/payment_webhook\')\nstatic async paymentWebhook(): Promise<void> {\n  const notificationMessage = ... // Parse the notification.\n  const workflowID = ... // Retrieve the workflow ID from notification metadata.\n  await DBOS.send(workflow_id, notificationMessage, PAYMENT_STATUS);\n}\n```\n\n\nWhen using DBOS workflows, you should call any function that performs complex operations or accesses external APIs or services as a _step_.\nIf a workflow is interrupted, upon restart it automatically resumes execution from the **last completed step**.\n\nYou can use `DBOS.runStep` to call a function as a step.  For a function to be used as a step, it should have a return value that can be serialized as JSON, and should not have non-durable side effects. ALWAYS call steps this way unless otherwise specify.\n\n```javascript\nasync function generateRandomNumber() {\n  return Math.random();\n}\n\nasync function workflowFunction() {\n  const randomNumber = await DBOS.runStep(() => generateRandomNumber(), {name: "generateRandomNumber"});\n}\nconst workflow = DBOS.registerWorkflow(workflowFunction)\n```\n\nAlternatively, you can register a function as a step using `DBOS.registerStep`:\nNEVER do this unless specifically asked, ALWAYS use DBOS.runStep instead.\n\n```javascript\nasync function generateRandomNumber() {\n  return Math.random();\n}\nconst randomStep = DBOS.registerStep(generateRandomNumber);\n\nasync function workflowFunction() {\n  const randomNumber = await randomStep();\n}\nconst workflow = DBOS.registerWorkflow(workflowFunction)\n```\n\nOr use the `@DBOS.step()` decorator:\nNEVER do this unless specifically asked, ALWAYS use DBOS.runStep instead.\n\n```typescript\nexport class Example {\n  @DBOS.step()\n  static async generateRandomNumber() {\n    return Math.random();\n  }\n\n  @DBOS.workflow()\n  static async exampleWorkflow() {\n    await Example.generateRandomNumber();\n  }\n}\n```\n\n### Configurable Retries\n\nYou can optionally configure a step to automatically retry any exception a set number of times with exponential backoff.\nThis is useful for automatically handling transient failures, like making requests to unreliable APIs.\nRetries are configurable through arguments to the step decorator:\n\n```typescript\nexport interface StepConfig {\n  retriesAllowed?: boolean; // Should failures be retried? (default false)\n  intervalSeconds?: number; // Seconds to wait before the first retry attempt (default 1).\n  maxAttempts?: number;     // Maximum number of retry attempts (default 3). If errors occur more times than this, throw an exception.\n  backoffRate?: number;     // Multiplier by which the retry interval increases after a retry attempt (default 2).\n}\n```\n\nFor example, let\'s configure this step to retry exceptions (such as if `example.com` is temporarily down) up to 10 times:\n\n```javascript\nasync function fetchFunction() {\n    return await fetch("https://example.com").then(r => r.text());\n}\n\nasync function workflowFunction() {\n    const randomNumber = await DBOS.runStep(() => fetchFunction(), {\n        name: "fetchFunction",\n        retriesAllowed: true,\n        maxAttempts: 10\n    });\n}\n```\n\nOr if registering the step:\n\n```javascript\nasync function fetchFunction() {\n    return await fetch("https://example.com").then(r => r.text());\n}\nconst fetchStep = DBOS.registerStep(fetchFunction, {\n    retriesAllowed: true,\n    maxAttempts: 10\n});\n```\n\nOr if using decorators:\n\n```javascript\n@DBOS.step({retriesAllowed: true, maxAttempts: 10})\nstatic async exampleStep() {\n  return await fetch("https://example.com").then(r => r.text());\n}\n```\n\n### DBOS Queues\n\n\nQueues allow you to run functions with managed concurrency.\nThey are useful for controlling the number of functions run in parallel, or the rate at which functions are started.\n\nTo create a queue, specify its name:\n\n```javascript\nimport { DBOS, WorkflowQueue } from "@dbos-inc/dbos-sdk";\n\nconst queue = new WorkflowQueue("example_queue");\n```\n\nYou can then enqueue any DBOS workflow, step, or transaction.\nEnqueuing a function submits it for execution and returns a handle to it.\nQueued tasks are started in first-in, first-out (FIFO) order.\n\n```javascript\nconst queue = new WorkflowQueue("example_queue");\n\nclass Tasks {\n  @DBOS.workflow()\n  static async processTask(task) {\n    // ...\n  }\n}\n\nasync function main() {\n  const task = ...\n  const handle = await DBOS.startWorkflow(Tasks, {queueName: queue.name}).processTask(task)\n}\n```\n\n### Queue Example\n\nHere\'s an example of a workflow using a queue to process tasks concurrently:\n\n```javascript\nimport { DBOS, WorkflowQueue } from "@dbos-inc/dbos-sdk";\n\nconst queue = new WorkflowQueue("example_queue");\n\nasync function taskFunction(task) {\n    // ...\n}\nconst taskWorkflow = DBOS.registerWorkflow(taskFunction, {"name": "taskWorkflow"});\n\nasync function queueFunction(tasks) {\n  const handles = []\n  \n  // Enqueue each task so all tasks are processed concurrently.\n  for (const task of tasks) {\n    handles.push(await DBOS.startWorkflow(taskWorkflow, { queueName: queue.name })(task))\n  }\n\n  // Wait for each task to complete and retrieve its result.\n  // Return the results of all tasks.\n  const results = []\n  for (const h of handles) {\n    results.push(await h.getResult())\n  }\n  return results\n}\nconst queueWorkflow = DBOS.registerWorkflow(queueFunction, {"name": "queueWorkflow"})\n```\n\n### Managing Concurrency\n\nYou can control how many workflows from a queue run simultaneously by configuring concurrency limits.\nThis helps prevent resource exhaustion when workflows consume significant memory or processing power.\n\n#### Worker Concurrency\n\nWorker concurrency sets the maximum number of workflows from a queue that can run concurrently on a single DBOS process.\nThis is particularly useful for resource-intensive workflows to avoid exhausting the resources of any process.\nFor example, this queue has a worker concurrency of 5, so each process will run at most 5 workflows from this queue simultaneously:\n```javascript\nimport { DBOS, WorkflowQueue } from "@dbos-inc/dbos-sdk";\n\nconst queue = new WorkflowQueue("example_queue", { workerConcurrency: 5 });\n```\n\n#### Global Concurrency\n\nGlobal concurrency limits the total number of workflows from a queue that can run concurrently across all DBOS processes in your application.\nFor example, this queue will have a maximum of 10 workflows running simultaneously across your entire application.\n\n:::warning\nWorker concurrency limits are recommended for most use cases.\nTake care when using a global concurrency limit as any `PENDING` workflow on the queue counts toward the limit, including workflows from previous application versions\n:::\n\n```javascript\nimport { DBOS, WorkflowQueue } from "@dbos-inc/dbos-sdk";\n\nconst queue = new WorkflowQueue("example_queue", { concurrency: 10 });\n```\n\n### Rate Limiting\n\nYou can set _rate limits_ for a queue, limiting the number of functions that it can start in a given period.\nRate limits are global across all DBOS processes using this queue.\nFor example, this queue has a limit of 50 with a period of 30 seconds, so it may not start more than 50 functions in 30 seconds:\n\n```javascript\nconst queue = new WorkflowQueue("example_queue", { rateLimit: { limitPerPeriod: 50, periodSec: 30 } });\n```\n\nRate limits are especially useful when working with a rate-limited API, such as many LLM APIs.\n\n### Setting Timeouts\n\nYou can set a timeout for an enqueued workflow by passing a `timeoutMS` argument to `DBOS.startWorkflow`.\nWhen the timeout expires, the workflow **and all its children** are cancelled.\nCancelling a workflow sets its status to `CANCELLED` and preempts its execution at the beginning of its next step.\n\nTimeouts are **start-to-completion**: a workflow\'s timeout does not begin until the workflow is dequeued and starts execution.\nAlso, timeouts are **durable**: they are stored in the database and persist across restarts, so workflows can have very long timeouts.\n\nExample syntax:\n\n```javascript\nconst queue = new WorkflowQueue("example_queue");\n\nasync function taskFunction(task) {\n    // ...\n}\nconst taskWorkflow = DBOS.registerWorkflow(taskFunction, {"name": "taskWorkflow"});\n\nasync function main() {\n  const task = ...\n  const timeout = ... // Timeout in milliseconds\n  const handle = await DBOS.startWorkflow(taskWorkflow, {queueName: queue.name, timeoutMS: timeout})(task);\n}\n```\n\n### Deduplication\n\nYou can set a deduplication ID for an enqueued workflow as an argument to `DBOS.startWorkflow`.\nAt any given time, only one workflow with a specific deduplication ID can be enqueued in the specified queue.\nIf a workflow with a deduplication ID is currently enqueued or actively executing (status `ENQUEUED` or `PENDING`), subsequent workflow enqueue attempt with the same deduplication ID in the same queue will raise a `DBOSQueueDuplicatedError` exception.\n\nFor example, this is useful if you only want to have one workflow active at a time per user, set the deduplication ID to the user\'s ID.\n\nExample syntax:\n\n```javascript\nconst queue = new WorkflowQueue("example_queue");\n\nasync function taskFunction(task) {\n    // ...\n}\nconst taskWorkflow = DBOS.registerWorkflow(taskFunction, {"name": "taskWorkflow"});\n\nasync function main() {\n  const task = ...\n  const dedup: string = ...\n  try {\n    const handle = await DBOS.startWorkflow(taskWorkflow, {queueName: queue.name, enqueueOptions: {deduplicationID: dedup}})(task);\n  } catch (e) {\n    // Handle DBOSQueueDuplicatedError\n  }\n}\n```\n\n### Priority\n\nYou can set a priority for an enqueued workflow as an argument to `DBOS.startWorkflow`.\nWorkflows with the same priority are dequeued in **FIFO (first in, first out)** order. Priority values can range from `1` to `2,147,483,647`, where **a low number indicates a higher priority**.\nIf using priority, you must set `usePriority: true` on your queue.\n\n:::tip\nWorkflows without assigned priorities have the highest priority and are dequeued before workflows with assigned priorities.\n:::\n\nExample syntax:\n\n```javascript\nconst queue = new WorkflowQueue("example_queue", {usePriority: true});\n\nasync function taskFunction(task) {\n    // ...\n}\nconst taskWorkflow = DBOS.registerWorkflow(taskFunction, {"name": "taskWorkflow"});\n\nasync function main() {\n  const task = ...\n  const priority: number = ...\n  const handle = await DBOS.startWorkflow(taskWorkflow, {queueName: queue.name, enqueueOptions: {priority: priority}})(task);\n}\n```\n\n### In-Order Processing\n\nYou can use a queue with `concurrency=1` to guarantee sequential, in-order processing of events.\nOnly a single event will be processed at a time.\nFor example, this app processes events sequentially in the order of their arrival:\n\n```javascript\nimport { DBOS, WorkflowQueue } from "@dbos-inc/dbos-sdk";\nimport express from "express";\n\nconst serialQueue = new WorkflowQueue("in_order_queue", { concurrency: 1 });\nconst app = express();\n\nclass Tasks {\n  @DBOS.workflow()\n  static async processTask(task){\n    // ... process task\n  }\n}\n\napp.get("/events/:event", async (req, res) => {\n  await DBOS.startWorkflow(Tasks, {queueName: serialQueue.name}).processTask(req.params);\n  await res.send("Workflow Started!");\n});\n\n// Launch DBOS and start the server\nasync function main() {\n  await DBOS.launch();\n  app.listen(3000, () => {});\n}\n\nmain().catch(console.log);\n```\n\n### Enqueue with DBOSClient\n\nDBOSClient provides a way to programmatically interact with your DBOS application from external code.\nAmong other things, this allows you to enqueue workflows from outside your DBOS application.\n\nSince `DBOSClient` is designed to be used from outside your DBOS application, workflow and queue metadata must be specified explicitly.\n\nExample: \n\n```ts\nimport { DBOSClient } from "@dbos-inc/dbos-sdk";\n\nconst client = await DBOSClient.create({systemDatabaseUrl: process.env.DBOS_SYSTEM_DATABASE_URL});\n\ntype ProcessTask = typeof Tasks.processTask;\nawait client.enqueue<ProcessTask>(\n    {\n        workflowName: \'processTask\',\n        workflowClassName: \'Tasks\',\n        queueName: \'example_queue\',\n    }, \n    task);\n```\n\n## Classes\n\nYou can use class instance methods as workflows and steps.\nAny class instance method can be freely used as a step using the DBOS.step decorator or DBOS.runstep; there are no special requirements.\nTo use a class instance method as a workflow, you must use the DBOS.workflow decorator and the class must inherit from `ConfiguredInstance`.\nFor example:\n\n```typescript\nclass MyClass extends ConfiguredInstance {\n  cfg: MyConfig;\n  constructor(name: string, config: MyConfig) {\n    super(name);\n    this.cfg = cfg;\n  }\n\n  override async initialize() : Promise<void> {\n    // ... Validate this.cfg; will be called at DBOS.launch()\n  }\n\n  @DBOS.workflow()\n  async testWorkflow(p: string): Promise<void> {\n    // ... Operations that use this.cfg\n  }\n}\n\nconst myClassInstance = new MyClass(\'instanceA\');\n```\n\nWhen you create a new instance of such a class, the constructor for the base `ConfiguredInstance` must be called with a `name`.\nThis `name` should be unique among instances of the same class.\nAdditionally, all `ConfiguredInstance` classes must be instantiated before DBOS.launch() is called.\n\nThe reason for these requirements is to enable workflow recovery.  When you create a new instance of, DBOS stores it in a global registry indexed by `name`.  When DBOS needs to recover a workflow belonging to that class, it looks up the `name` so it can run the workflow using the right class instance.  While names are used by DBOS Transact internally to find the correct object instance across system restarts, they are also potentially useful for monitoring, tracing, and debugging.\nYou should AVOID using ConfiguredInstance if at all possible and instead use registerWorkflow on regular non-class functions.\n\n\n### Testing DBOS Functions\n\nUnless otherwise specified, recommend testing DBOS applications with jest.\n\nYou MUST use this beforeAll to reset DBOS between tests:\n\n```javascript\n  beforeAll(async () => {\n    DBOS.setConfig({\n      name: \'my-app\',\n      databaseUrl: process.env.DBOS_TESTING_DATABASE_URL,\n    });\n    await DBOS.launch();\n  });\n```\n\n\n### Logging\n\nALWAYS log errors like this:\n\n```typescript\n      DBOS.logger.error(`Error: ${(error as Error).message}`);\n```\n\n## Workflow Handles\n\nA workflow handle represents the state of a particular active or completed workflow execution.\nYou obtain a workflow handle when using `DBOS.startWorkflow` to start a workflow in the background.\nIf you know a workflow\'s identity, you can also retrieve its handle using `DBOS.retrieveWorkflow`.\n\nWorkflow handles have the following methods:\n\n### handle.workflowID\n\n```typescript\nhandle.workflowID(): string;\n```\n\nRetrieve the ID of the workflow.\n\n### handle.getResult\n\n```typescript\nhandle.getResult(): Promise<R>;\n```\n\nWait for the workflow to complete, then return its result.\n\n### handle.getStatus\n\n```typescript\nhandle.getStatus(): Promise<WorkflowStatus>;\n```\n\nRetrieve the WorkflowStatus of the workflow:\n\n### Workflow Status\n\nSome workflow introspection and management methods return a `WorkflowStatus`.\nThis object has the following definition:\n\n```typescript\nexport interface WorkflowStatus {\n  // The workflow ID\n  readonly workflowID: string;\n  // The workflow status. Must be one of ENQUEUED, PENDING, SUCCESS, ERROR, CANCELLED, or RETRIES_EXCEEDED\n  readonly status: string;\n  // The name of the workflow function.\n  readonly workflowName: string;\n  // The name of the workflow\'s class, if any\n  readonly workflowClassName: string; // The class name holding the workflow function.\n  // The name with which the workflow\'s class instance was configured, if any.\n  readonly workflowConfigName?: string;\n  // If the workflow was enqueued, the name of the queue.\n  readonly queueName?: string;\n  // The workflow\'s output, if any.\n  readonly output?: unknown;\n  // The error thrown by the workflow, if any.\n  readonly error?: unknown;\n  // The deserialized workflow inputs.\n  readonly input?: unknown[];\n  // The ID of the executor (process) that most recently executed this workflow.\n  readonly executorId?: string;\n  // The application version on which this workflow started.\n  readonly applicationVersion?: string;\n  // The number of times this workflow has been started.\n  readonly recoveryAttempts?: number;\n  // Workflow start time, as a UNIX epoch timestamp in milliseconds\n  readonly createdAt: number;\n  // Last time the workflow status was updated, as a UNIX epoch timestamp in milliseconds. For a completed workflow, this is the workflow completion timestamp.\n  readonly updatedAt?: number;\n  // The timeout specified for this workflow, if any. Timeouts are start-to-close.\n  readonly timeoutMS?: number | null;\n  // The deadline at which this workflow times out, if any. Not set until the workflow begins execution.\n  readonly deadlineEpochMS?: number;\n}\n```\n\n## DBOS Variables\n\n### DBOS.workflowID\n\n```typescript\nDBOS.workflowID: string | undefined;\n```\n\nReturn the ID of the current workflow, if in a workflow.\n\n### DBOS.stepID\n\n```typescript\nDBOS.stepID: string | undefined;\n```\n\nReturn the unique ID of the current step within a workflow.\n\n### DBOS.stepStatus\n\n```typescript\nDBOS.stepStatus: StepStatus | undefined;\n```\n\nReturn the status of the currently executing step.\nThis object has the following properties:\n\n```typescript\ninterface StepStatus {\n  // The unique ID of this step in its workflow.\n  stepID: number;\n  // For steps with automatic retries, which attempt number (zero-indexed) is currently executing.\n  currentAttempt?: number;\n  // For steps with automatic retries, the maximum number of attempts that will be made before the step fails.\n  maxAttempts?: number;\n}\n```\n\n\n## Workflow Management Methods\n\n### DBOS.listWorkflows\n\n```typescript\nDBOS.listWorkflows(\n  input: GetWorkflowsInput\n): Promise<WorkflowStatus[]>\n```\n\n```typescript\ninterface GetWorkflowsInput {\n  workflowIDs?: string[];\n  workflowName?: string;\n  status?: string;\n  startTime?: string;\n  endTime?: string;\n  applicationVersion?: string;\n  authenticatedUser?: string;\n  limit?: number;\n  offset?: number;\n  sortDesc?: boolean;\n}\n```\n\nRetrieve a list of WorkflowStatus of all workflows matching specified criteria.\n\n**Parameters:**\n- **workflowIDs**: Retrieve workflows with these IDs.\n- **workflowName**: Retrieve workflows with this name.\n- **status**: Retrieve workflows with this status (Must be `ENQUEUED`, `PENDING`, `SUCCESS`, `ERROR`, `CANCELLED`, or `RETRIES_EXCEEDED`)\n- **startTime**: Retrieve workflows started after this (RFC 3339-compliant) timestamp.\n- **endTime**: Retrieve workflows started before this (RFC 3339-compliant) timestamp.\n- **applicationVersion**: Retrieve workflows tagged with this application version.\n- **authenticatedUser**: Retrieve workflows run by this authenticated user.\n- **limit**: Retrieve up to this many workflows.\n- **offset**: Skip this many workflows from the results returned (for pagination).\n- **sortDesc**: Whether to sort the results in descending (`True`) or ascending (`False`) order by workflow start time.\n\n### DBOS.listQueuedWorkflows\n\n```typescript\nDBOS.listQueuedWorkflows(\n  input: GetQueuedWorkflowsInput\n): Promise<WorkflowStatus[]>\n```\n\n```typescript\ninterface GetQueuedWorkflowsInput {\n  workflowName?: string;\n  status?: string;\n  queueName?: number;\n  startTime?: string;\n  endTime?: string;\n  limit?: number;\n  offset?: number;\n  sortDesc?: boolean;\n}\n```\n\nRetrieve a list of WorkflowStatus of all **currently enqueued** workflows matching specified criteria.\n\n**Parameters:**\n- **workflowName**: Retrieve workflows with this name.\n- **status**: Retrieve workflows with this status (Must be `ENQUEUED`, `PENDING`, `SUCCESS`, `ERROR`, `CANCELLED`, or `RETRIES_EXCEEDED`)\n- **queueName**: Retrieve workflows running on this queue.\n- **startTime**: Retrieve workflows started after this (RFC 3339-compliant) timestamp.\n- **endTime**: Retrieve workflows started before this (RFC 3339-compliant) timestamp.\n- **limit**: Retrieve up to this many workflows.\n- **offset**: Skip this many workflows from the results returned (for pagination).\n- **sortDesc**: Whether to sort the results in descending (`True`) or ascending (`False`) order by workflow start time.\n\n### DBOS.listWorkflowSteps\n```typescript\nDBOS.listWorkflowSteps(\n  workflowID: string)\n: Promise<StepInfo[]>\n```\n\nRetrieve the steps of a workflow.\nThis is a list of `StepInfo` objects, with the following structure:\n\n```typescript\ninterface StepInfo {\n  // The unique ID of the step in the workflow. Zero-indexed.\n  readonly functionID: number;\n  // The name of the step\n  readonly name: string;\n  // The step\'s output, if any\n  readonly output: unknown;\n  // The error the step threw, if any\n  readonly error: Error | null;\n  // If the step starts or retrieves the result of a workflow, its ID\n  readonly childWorkflowID: string | null;\n}\n```\n\n### DBOS.cancelWorkflow\n\n```typescript\ncancelWorkflow(\n  workflowID: string\n): Promise<void>\n```\n\nCancel a workflow.\nThis sets is status to `CANCELLED`, removes it from its queue (if it is enqueued) and preempts its execution (interrupting it at the beginning of its next step)\n\n### DBOS.resumeWorkflow\n\n```typescript\nDBOS.resumeWorkflow<T>(\n  workflowID: string\n): Promise<WorkflowHandle<Awaited<T>>> \n```\n\nResume a workflow.\nThis immediately starts it from its last completed step.\nYou can use this to resume workflows that are cancelled or have exceeded their maximum recovery attempts.\nYou can also use this to start an enqueued workflow immediately, bypassing its queue.\n\n### DBOS.forkWorkflow\n\n```typescript\nstatic async forkWorkflow<T>(\n  workflowID: string,\n  startStep: number,\n  options?: { newWorkflowID?: string; applicationVersion?: string; timeoutMS?: number },\n): Promise<WorkflowHandle<Awaited<T>>>\n```\n\nStart a new execution of a workflow from a specific step.\nThe input step ID (`startStep`) must match the `functionID` of the step returned by `listWorkflowSteps`.\nThe specified `startStep` is the step from which the new workflow will start, so any steps whose ID is less than `startStep` will not be re-executed.\n\n**Parameters:**\n- **workflowID**: The ID of the workflow to fork.\n- **startStep**: The ID of the step from which to start the forked workflow. Must match the `functionID` of the step in the original workflow execution.\n- **newWorkflowID**: The ID of the new workflow created by the fork. If not specified, a random UUID is used.\n- **applicationVersion**: The application version on which the forked workflow will run. Useful for "patching" workflows that failed due to a bug in the previous application version.\n- **timeoutMS**: A timeout for the forked workflow in milliseconds.\n\n\n'})})]})}function f(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var o=t(6540);const s={},r=o.createContext(s);function a(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);