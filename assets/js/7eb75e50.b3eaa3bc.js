"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[519],{4932:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>w,frontMatter:()=>a,metadata:()=>o,toc:()=>u});const o=JSON.parse('{"id":"java/prompting","title":"AI Model Prompting","description":"You may want assistance from an AI model in building a DBOS application.","source":"@site/docs/java/prompting.md","sourceDirName":"java","slug":"/java/prompting","permalink":"/java/prompting","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":30,"frontMatter":{"sidebar_position":30,"title":"AI Model Prompting"},"sidebar":"tutorialSidebar","previous":{"title":"Add DBOS To Your App","permalink":"/java/integrating-dbos"},"next":{"title":"Workflows","permalink":"/java/tutorials/workflow-tutorial"}}');var r=t(4848),i=t(8453);const a={sidebar_position:30,title:"AI Model Prompting"},s=void 0,l={},u=[{value:"How To Use",id:"how-to-use",level:2},{value:"Prompt",id:"prompt",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"You may want assistance from an AI model in building a DBOS application.\nTo make sure your model has the latest information on how to use DBOS, provide it with this prompt."}),"\n",(0,r.jsxs)(n.p,{children:["You may also want to use the ",(0,r.jsx)(n.a,{href:"/integrations/mcp",children:"DBOS MCP server"})," so your model can directly access your application's workflows and steps."]}),"\n",(0,r.jsx)(n.h2,{id:"how-to-use",children:"How To Use"}),"\n",(0,r.jsx)(n.p,{children:"First, use the click-to-copy button in the top right of the code block to copy the full prompt to your clipboard.\nThen, paste into your AI tool of choice (for example OpenAI's ChatGPT or Anthropic's Claude).\nThis adds the prompt to your AI model's context, giving it up-to-date instructions on how to build an application with DBOS."}),"\n",(0,r.jsx)(n.p,{children:"If you are using an AI-powered IDE, you can add this prompt to your project's context.\nFor example:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Claude Code: Add the prompt, or a link to it, to your CLAUDE.md file."}),"\n",(0,r.jsxs)(n.li,{children:["Cursor: Add the prompt to ",(0,r.jsx)(n.a,{href:"https://docs.cursor.com/context/rules-for-ai",children:"your project rules"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Zed: Copy the prompt to a file in your project, then use the ",(0,r.jsx)(n.a,{href:"https://zed.dev/docs/assistant/commands?highlight=%2Ffile#file",children:(0,r.jsx)(n.code,{children:"/file"})})," command to add the file to your context."]}),"\n",(0,r.jsxs)(n.li,{children:["GitHub Copilot: Create a ",(0,r.jsx)(n.a,{href:"https://docs.github.com/en/copilot/customizing-copilot/adding-repository-custom-instructions-for-github-copilot",children:(0,r.jsx)(n.code,{children:".github/copilot-instructions.md"})})," file in your repository and add the prompt to it."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"prompt",children:"Prompt"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-markdown",children:'# Build Reliable Applications With DBOS\n\n## Guidelines\n\n- Respond in a friendly and concise manner\n- Ask clarifying questions when requirements are ambiguous\n- Generate code in Java using the DBOS library.\n- You MUST import all methods and classes used in the code you generate\n- DBOS does NOT stand for anything.\n\n## Workflow Guidelines\n\nWorkflows provide durable execution so you can write programs that are resilient to any failure.  In the event of any failure, execution will resume where it left off.\nWorkflows are ordinary Java methods that are comprised of steps, which are also ordinary Java methods.  Steps are the restart unit for the workflow, their results are checkpointed to the database.\nWhen using DBOS workflows, you should call any function that performs complex operations or accesses external APIs or services as a step using DBOS.runStep or @Step, that way the step will be skipped if execution resumes.\nSteps that are used once can be made as lambdas and called with DBOS.runStep().  Steps that are reused can be declared as instance methods annotated with @Step.\n\nIf a workflow is interrupted for any reason (e.g., an executor restarts or crashes), when your program restarts the workflow automatically resumes execution from the last completed step.\n\n- If asked to add DBOS to existing code, you MUST ask which function to make a workflow. Do NOT recommend any changes until they have told you what function to make a workflow. Do NOT make a function a workflow unless SPECIFICALLY requested.\n- When making a function a workflow, you should make all functions it calls steps. Do NOT change the functions in any way.\n- Do NOT make functions steps unless they are DIRECTLY called by a workflow.\n- If the workflow function performs a non-deterministic action, you MUST move that action to its own function and make that function a step, or wrap it as a lambda with DBOS.runStep. Examples of non-deterministic actions include accessing an external API or service, accessing files on disk, generating a random number, of getting the current time.\n- DBOS workflows and steps should NOT have side effects in memory outside of their own scope. They can access instance or static variables, but they should NOT create or update static, instance, or other variables outside their scope.\n- Do NOT call any DBOS context method (DBOS.send, DBOS.recv, DBOS.startWorkflow, DBOS.getEvent) from a step.  Those do their own checkpointing.\n- Do NOT start workflows from inside a step.\n- Do NOT call DBOS.setEvent and DBOS.recv from outside a workflow function.\n\n## Serializability requirements\nWorkflow method arguments, and step and workflow function return values, are serialized as JSON using jackson.  Help the user with any annotations or mapping necessary to get jackson to work seamlessly.\n\nFor example, the following annotation is sometimes necessary:\n```java\n  @com.fasterxml.jackson.annotation.JsonProperty(access = JsonProperty.Access.READ_ONLY)\n```\n\n## Getting set up\nWhile it is not necessary to use Gradle, Gradle should be suggested for new projects.  Gradle 8 or later should be suggested.  Java 21 should be suggested, but any Java 17 or later can be used if the user requests that.\n\nThe main addition to any gradle project is additional dependencies:\n```groovy\ndependencies {\n    implementation \'dev.dbos:transact:0.6+\'\n    implementation \'ch.qos.logback:logback-classic:1.5.18\'\n}\n```\n\nThe application will also need a Postgres database.  If there is not one already, it can be set up using standard approaches, or with Docker:\n```shell\ndocker run -d \\\n  --name dbos-postgres \\\n  -e POSTGRES_PASSWORD=dbos \\\n  -p 5432:5432 \\\n  postgres:17\n```\n\nFor convenience, the database credentials should be set in the environment, or passed in to the environment for any shell command that launches DBOS.\n```\nexport PGUSER=postgres\nexport PGPASSWORD=dbos\nexport DBOS_SYSTEM_JDBC_URL=jdbc:postgresql://localhost:5432/<application name>\n```\n\nOnce some code hase been added to the project, the typical gradlew commands can be used to build and run it.\n\n```shell\n./gradlew assemble\n./gradlew run\n```\n\n\n## Use of Spring\nDBOS examples often use Spring boot, and there are examples of integrating it with the DBOS lifecycle, however DBOS is just a library and can be used by itself, or with other frameworks.\n\nIf spring is used, the DBOS lifecycle must be captured in a SmartLifecycle:\n```java\nimport org.springframework.context.SmartLifecycle;\nimport org.springframework.context.annotation.Lazy;\nimport org.springframework.stereotype.Component;\n\nimport dev.dbos.transact.DBOS;\nimport dev.dbos.transact.config.DBOSConfig;\n\nimport java.util.Objects;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@Component\n@Lazy(false)\npublic class DBOSLifecycle implements SmartLifecycle {\n\n    private static final Logger log = LoggerFactory.getLogger(DBOSLifecycle.class);\n    private volatile boolean running = false;\n\n    @Override\n    public void start() {\n        String databaseUrl = System.getenv("DBOS_SYSTEM_JDBC_URL");\n        if (databaseUrl == null || databaseUrl.isEmpty()) {\n            databaseUrl = "jdbc:postgresql://localhost:5432/<app name goes here>";\n        }\n        var config = DBOSConfig.defaults("dbos-starter")\n                .withDatabaseUrl(databaseUrl)\n                .withDbUser(Objects.requireNonNullElse(System.getenv("PGUSER"), "postgres"))\n                .withDbPassword(Objects.requireNonNullElse(System.getenv("PGPASSWORD"), "dbos"))\n                .withAdminServer(true)\n                .withAdminServerPort(3001);\n        DBOS.configure(config);\n\n        log.info("Launch DBOS");\n        DBOS.launch();\n        running = true;\n    }\n\n    @Override\n    public void stop() {\n        log.info("Shut Down DBOS");\n        try {\n            DBOS.shutdown();\n        } finally {\n            running = false;\n        }\n    }\n\n    @Override public boolean isRunning() { return running; }\n\n    @Override public boolean isAutoStartup() { return true; }\n\n    // Start BEFORE the web server (default is 0). Lower = earlier.\n    @Override public int getPhase() { return -1; }\n}\n```\n\nAny DBOS workflow and step classes MAY also be configured as beans to ensure that they are registered and proxies are created (DBOSAppService is just an example, use the user\'s classes instead):\n```java\n@Configuration\npublic class DBOSAppConfig {\n\n    @Bean\n    @Primary\n    public DBOSAppService dbosAppService(DSLContext dslContext) {\n        var impl = new DBOSAppServiceImpl(dslContext);\n\t    var proxy = DBOS.registerWorkflows(DBOSAppService.class, impl);\n        impl.setDBOSAppService(proxy);\n        return proxy;\n    }\n\n}\n```\n\n## DBOS Lifecycle Guidelines\n\nDBOS should be installed and imported from the `dev.dbos.transact` package.  Use any of the following imports if they are necessary.\n```java\nimport dev.dbos.transact.DBOS;\nimport dev.dbos.transact.DBOSClient;\nimport dev.dbos.transact.ForkOptions;\nimport dev.dbos.transact.ListWorkflowsInput;\nimport dev.dbos.transact.StartWorkflowOptions;\nimport dev.dbos.transact.config.DBOSConfig;\nimport dev.dbos.transact.workflow.Queue;\nimport dev.dbos.transact.workflow.Scheduled;\nimport dev.dbos.transact.workflow.Step;\nimport dev.dbos.transact.workflow.StepOptions;\nimport dev.dbos.transact.workflow.Timeout;\nimport dev.dbos.transact.workflow.Workflow;\nimport dev.dbos.transact.workflow.WorkflowHandle;\nimport dev.dbos.transact.workflow.WorkflowState;\nimport dev.dbos.transact.workflow.WorkflowStatus;\n```\n\nAny DBOS program MUST call DBOS.configure and DBOS.launch somewhere.  For simple cases, this can be in its main function, like so.\nYou MUST use this default configuration (changing the name \'dbos-java-starter\' to the real app name as appropriate) unless otherwise specified.\n\n```java\n    public static void main(String[] args) throws Exception {\n        Logger root = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);\n        root.setLevel(Level.INFO);\n        DBOSConfig config = DBOSConfig.defaults("dbos-java-starter")\n            .withDatabaseUrl(System.getenv("DBOS_SYSTEM_JDBC_URL"))\n            .withDbUser(System.getenv("PGUSER"))\n            .withDbPassword(System.getenv("PGPASSWORD"));\n        DBOS.configure(config);\n        Example proxy = DBOS.registerWorkflows(Example.class, new ExampleImpl());\n        DBOS.launch();\n    }\n```\n\n## Workflow and Steps Examples\n\nSimple example:\n\nUse of background execution:\n\nUse of queues:\n\n### Scheduled Workflow\n\nYou can schedule DBOS workflows.\nTo do this, use the the @Scheduled annotation on a @Workflow method.  For example:\n\n- A scheduled workflow MUST specify a schedule.  This uses the Spring 5.3 CronExpression format.\n- It MUST take in two arguments, scheduled and actual time the workflow was started. Both are of type Instant.\n\n```java\n@Workflow\n@Scheduled(cron = "0 * * * * *") // Run at the beginning of every minute\npublic void everyMinute(Instant scheduled, Instant actual) {\n    logger.info("I am a workflow scheduled to run once a minute. ");\n}\n```\n\n#### @Scheduled\n\n```java\npublic @interface Scheduled {\n  String cron();\n}\n```\n\nAn annotation that can be applied to a workflow to schedule it on a cron schedule.\n\n**Parameters:**\n- **cron**: The schedule, expressed in Spring 5.3+ CronExpression syntax.\n\n\n## Workflow Documentation\n\nWorkflows provide **durable execution** so you can write programs that are **resilient to any failure**.\nWorkflows are comprised of steps, which wrap ordinary Java functions.\nIf a workflow is interrupted for any reason (e.g., an executor restarts or crashes), when your program restarts the workflow automatically resumes execution from the last completed step.\n\nThe recovery mechanism requires that workflow methods must be registered.  Registration creates a proxy that adds durability to the registered workflow.  For Java, this means defining both an interface and implementation class, annotating the implementation with @Workflow and @Step, and then calling DBOS.registerWorkflows.\n\n### @Workflow\n\n```java\npublic @interface Workflow {\n  String name();\n\n  int maxRecoveryAttempts();\n}\n```\n\nAn annotation that can be applied to a class method to mark it as a durable workflow.\n\n**Parameters:**\n- **name**: The workflow name. Must be unique.\n- **maxRecoveryAttempts**: Optionally configure the maximum number of times execution of a workflow may be attempted.\nThis acts as a dead letter queue so that a buggy workflow that crashes its application (for example, by running it out of memory) does not do so infinitely.\nIf a workflow exceeds this limit, its status is set to `MAX_RECOVERY_ATTEMPTS_EXCEEDED` and it may no longer be executed.\n\n## Methods\n\n### registerWorkflows\n\n```java\nstatic <T> T registerWorkflows(Class<T> interfaceClass, T implementation)\nstatic <T> T registerWorkflows(Class<T> interfaceClass, T implementation, String instanceName)\n```\n\nRegister the workflows in a class, returning a proxy object from which the class methods may be invoked as durable workflows.\nAll workflows must be registered before DBOS is launched.\n\n**Example Syntax:**\n\n```java\ninterface Example {\n    public void workflow();\n}\n\nclass ExampleImpl implements Example {\n    @Workflow(name="workflow")\n    public void workflow() {\n        return;\n    }\n}\n\nExample proxy = DBOS.registerWorkflows(Example.class, new ExampleImpl());\nproxy.workflow();\n```\n\n**Parameters:**\n- **interfaceClass**: The interface class whose workflows are to be registered.\n- **implementation**: An instance of the class whose workflows to register.\n- **instanceName**: A unique name for this class instance. Use only when you are creating multiple instances of a class and your workflow depends on class instance variables. When DBOS needs to recover a workflow belonging to that class, it looks up the class instance using `instanceName` so it can recover the workflow using the right instance of its class.\n\n## Starting Workflows In The Background\n\n```java\nstatic <T, E extends Exception> WorkflowHandle<T, E> startWorkflow(\n    ThrowingSupplier<T, E> workflow, \n    StartWorkflowOptions options\n)\n```\n\nStart a workflow in the background and return a handle to it.\nOptionally enqueue it on a DBOS queue.\nThe `startWorkflow` method resolves after the workflow is durably started; at this point the workflow is guaranteed to run to completion even if the app is interrupted.\n\n**Example Syntax**:\n\n```java\ninterface Example {\n    public void workflow();\n}\n\nclass ExampleImpl implements Example {\n    @Workflow(name="workflow")\n    public void workflow() {\n        return;\n    }\n}\n\nExample proxy = DBOS.registerWorkflows(Example.class, new ExampleImpl());\nDBOS.startWorkflow(() -> proxy.workflow(), new StartWorkflowOptions());\n```\n\n#### StartWorkflowOptions\n\n`StartWorkflowOptions` is a with-based configuration record for parameterizing `DBOS.startWorkflow`. All fields are optional.\n\n**Constructors:**\n```java\nnew StartWorkflowOptions()\n```\nCreate workflow options with all fields set to their defaults.\n\n**Methods:**\n- **`withWorkflowId(String workflowId)`** - Set the workflow ID of this workflow.\n\n- **`withQueue(Queue queue)`** - Instead of starting the workflow directly, enqueue it on this queue.\n\n- **`withTimeout(Duration timeout)`** / **`withTimeout(long value, TimeUnit unit)`** - Set a timeout for this workflow. When the timeout expires, the workflow **and all its children** are cancelled. Cancelling a workflow sets its status to `CANCELLED` and preempts its execution at the beginning of its next step.\n\n  Timeouts are **start-to-completion**: if a workflow is enqueued, the timeout does not begin until the workflow is dequeued and starts execution. Also, timeouts are **durable**: they are stored in the database and persist across restarts, so workflows can have very long timeouts.\n\n  Timeout deadlines are propagated to child workflows by default, so when a workflow\'s deadline expires all of its child workflows (and their children, and so on) are also cancelled. If you want to detach a child workflow from its parent\'s timeout, you can start it with `SetWorkflowTimeout(custom_timeout)` to override the propagated timeout. You can use `SetWorkflowTimeout(None)` to start a child workflow with no timeout.\n\n- **`withDeduplicationId(String deduplicationId)`** - May only be used when enqueuing. At any given time, only one workflow with a specific deduplication ID can be enqueued in the specified queue. If a workflow with a deduplication ID is currently enqueued or actively executing (status `ENQUEUED` or `PENDING`), subsequent workflow enqueue attempts with the same deduplication ID in the same queue will raise an exception.\n\n- **`withPriority(int priority)`** - May only be used when enqueuing. The priority of the enqueued workflow in the specified queue. Workflows with the same priority are dequeued in FIFO (first in, first out) order. Priority values can range from `1` to `2,147,483,647`, where a low number indicates a higher priority. Workflows without assigned priorities have the highest priority and are dequeued before workflows with assigned priorities.\n\n\nOne common use-case for workflows is building reliable background tasks that keep running even when your program is interrupted, restarted, or crashes.\nYou can use startWorkflow to start a workflow in the background.\nWhen you start a workflow this way, it returns a workflow handle, from which you can access information about the workflow or wait for it to complete and retrieve its result.\n\nHere\'s an example:\n\n```java\nclass ExampleImpl implements Example {\n    @Workflow(name = "backgroundTask")\n    public String backgroundTask(String input) {\n        // ...\n        return output;\n    }\n}\n\npublic void runWorkflowExample(Example proxy) throws Exception {\n    // Start the background task\n    WorkflowHandle<String, Exception> handle = DBOS.startWorkflow(\n        () -> proxy.backgroundTask("input"),\n        new StartWorkflowOptions()\n    );\n    // Wait for the background task to complete and retrieve its result\n    String result = handle.getResult();\n    System.out.println("Workflow result: " + result);\n}\n```\n\nAfter starting a workflow in the background, you can use retrieveWorkflow to retrieve a workflow\'s handle from its ID.\nYou can also retrieve a workflow\'s handle from outside of your DBOS application with DBOSClient.retrieveWorkflow.\n\nIf you need to run many workflows in the background and manage their concurrency or flow control, use queues.\n\n## Workflow IDs and Idempotency\n\nEvery time you execute a workflow, that execution is assigned a unique ID, by default a UUID.\nYou can access this ID from the DBOS.workflowId method.\nWorkflow IDs are useful for communicating with workflows and developing interactive workflows.\n\nYou can set the workflow ID of a workflow using `withWorkflowId` when calling `startWorkflow`.\nWorkflow IDs are **globally unique** within your application.\nAn assigned workflow ID acts as an idempotency key: if a workflow is called multiple times with the same ID, it executes only once.\nThis is useful if your operations have side effects like making a payment or sending an email.\nFor example:\n\n```java\nclass ExampleImpl implements Example {\n    @Workflow(name = "exampleWorkflow")\n    public String exampleWorkflow() {\n        System.out.println("Running workflow with ID: " + DBOS.workflowId());\n        // ...\n        return "success";\n    }\n}\n\npublic void example(Example proxy) throws Exception {\n    String myID = "unique-workflow-id-123";\n    WorkflowHandle<String, Exception> handle = DBOS.startWorkflow(\n        () -> proxy.exampleWorkflow(),\n        new StartWorkflowOptions().withWorkflowId(myID)\n    );\n    String result = handle.getResult();\n    System.out.println("Result: " + result);\n}\n```\n\n## Determinism\n\nWorkflows are in most respects normal Java methods.\nThey can have loops, branches, conditionals, and so on.\nHowever, a workflow method must be **deterministic**: if called multiple times with the same inputs, it should invoke the same steps with the same inputs in the same order (given the same return values from those steps).\nIf you need to perform a non-deterministic operation like accessing the database, calling a third-party API, generating a random number, or getting the local time, you shouldn\'t do it directly in a workflow method.\nInstead, you should do all non-deterministic operations in steps.\n\n:::warning\nJava\'s threading and concurrency APIs are non-deterministic. You should use them only inside steps.\n:::\n\nFor example, **don\'t do this**:\n\n```java\n@Workflow(name = "exampleWorkflow")\npublic String exampleWorkflow() {\n    int randomChoice = new Random().nextInt(2);\n    if (randomChoice == 0) {\n        return DBOS.runStep(() -> stepOne(), "stepOne");\n    } else {\n        return DBOS.runStep(() -> stepTwo(), "stepTwo");\n    }\n}\n```\n\nInstead, do this:\n\n```java\nprivate int generateChoice() {\n    return new Random().nextInt(2);\n}\n\n@Workflow(name = "exampleWorkflow")\npublic String exampleWorkflow() {\n    int randomChoice = DBOS.runStep(() -> generateChoice(), "generateChoice");\n    if (randomChoice == 0) {\n        return DBOS.runStep(() -> stepOne(), "stepOne");\n    } else {\n        return DBOS.runStep(() -> stepTwo(), "stepTwo");\n    }\n}\n```\n\n## Workflow Timeouts\n\nYou can set a timeout for a workflow using withTimeout in `StartWorkflowOptions`.\n\nWhen the timeout expires, the workflow and all its children are cancelled. Cancelling a workflow sets its status to CANCELLED and preempts its execution at the beginning of its next step. You can detach a child workflow from its parent\'s timeout by starting it with a custom timeout using `withTimeout`.\n\nTimeouts are **start-to-completion**: if a workflow is enqueued, the timeout does not begin until the workflow is dequeued and starts execution. Also, timeouts are durable: they are stored in the database and persist across restarts, so workflows can have very long timeouts.\n\n```java\n@Workflow(name = "exampleWorkflow")\npublic void exampleWorkflow() throws InterruptedException {\n    // Workflow implementation\n}\n\nWorkflowHandle<Void, InterruptedException> handle = DBOS.startWorkflow(\n    () -> proxy.exampleWorkflow(),\n    new StartWorkflowOptions().withTimeout(Duration.ofHours(12))\n);\n```\n\n## Durable Sleep\n\nYou can use DBOS.sleep to put your workflow to sleep for any period of time.\nThis sleep is **durable**. DBOS saves the wakeup time in the database so that even if the workflow is interrupted and restarted multiple times while sleeping, it still wakes up on schedule.\n\nSleeping is useful for scheduling work to run in the future (even days, weeks, or months from now).\nFor example:\n\n```java\npublic String runTask(String task) {\n    // Execute the task...\n    return "task completed";\n}\n\n@Workflow(name = "exampleWorkflow")\npublic String exampleWorkflow(float timeToSleepSeconds, String task) throws InterruptedException {\n    // Sleep for the specified duration\n    DBOS.sleep(Duration.ofMillis((long)(timeToSleepSeconds*1000)));\n\n    // Execute the task after sleeping\n    String result = DBOS.runStep(\n        () -> runTask(task),\n        "runTask"\n    );\n\n    return result;\n}\n```\n\n## Workflow Versioning and Recovery\n\nBecause DBOS recovers workflows by re-executing them using information saved in the database, a workflow cannot safely be recovered if its code has changed since the workflow was started.\nTo guard against this, DBOS _versions_ applications and their workflows.\nWhen DBOS is launched, it computes an application version from a hash of the source code of its workflows (this can be overridden through the `applicationVersion`) configuration parameter.\nAll workflows are tagged with the application version on which they started.\n\nWhen DBOS tries to recover workflows, it only recovers workflows whose version matches the current application version.\nThis prevents unsafe recovery of workflows that depend on different code.\nYou cannot change the version of a workflow, but you can use `DBOS.forkWorkflow` to restart a workflow from a specific step on a specific code version.\n\n\n## Workflow Communication\n\nDBOS provides a few different ways to communicate with your workflows.\nYou can:\n\n- Send messages to workflows\n- Publish events from workflows for clients to read\n\n## Workflow Messaging and Notifications\nYou can send messages to a specific workflow.\nThis is useful for signaling a workflow or sending notifications to it while it\'s running.\n\n<img src={require(\'@site/static/img/workflow-communication/workflow-messages.png\').default} alt="DBOS Steps" width="750" className="custom-img"/>\n\n#### Send\n\n```java\nstatic void send(String destinationId, Object message, String topic)\n```\n\nYou can call `DBOS.send()` to send a message to a workflow.\nMessages can optionally be associated with a topic and are queued on the receiver per topic.\n\nYou can also call `send` from outside of your DBOS application with the DBOS Client.\n\n#### Recv\n\n```java\nstatic Object recv(String topic, Duration timeout)\n```\n\nWorkflows can call `DBOS.recv()` to receive messages sent to them, optionally for a particular topic.\nEach call to `recv()` waits for and consumes the next message to arrive in the queue for the specified topic, returning `null` if the wait times out.\nIf the topic is not specified, this method only receives messages sent without a topic.\n\n#### Messages Example\n\nMessages are especially useful for sending notifications to a workflow.\nFor example, in a payments system, after redirecting customers to a payments page, the checkout workflow must wait for a notification that the user has paid.\n\nTo wait for this notification, the payments workflow uses `recv()`, executing failure-handling code if the notification doesn\'t arrive in time:\n\n```java\ninterface Checkout {\n    void checkoutWorkflow();\n}\n\nclass CheckoutImpl implements Checkout {\n    private static final String PAYMENT_STATUS = "payment_status";\n\n    @Workflow(name = "checkout-workflow")\n    public void checkoutWorkflow() {\n        // Validate the order, redirect the customer to a payments page,\n        // then wait for a notification.\n        String paymentStatus = (String) DBOS.recv(PAYMENT_STATUS, Duration.ofSeconds(60));\n        if (paymentStatus != null && paymentStatus.equals("paid")) {\n            // Handle a successful payment.\n        } else {\n            // Handle a failed payment or timeout.\n        }\n    }\n}\n```\n\nAn endpoint waits for the payment processor to send the notification, then uses `send()` to forward it to the workflow:\n\n```java\napp.post("/payment_webhook/{workflow_id}/{payment_status}", ctx -> {\n    String workflowId = ctx.pathParam("workflow_id");\n    String paymentStatus = ctx.pathParam("payment_status");\n    // Send the payment status to the checkout workflow.\n    DBOS.send(workflowId, paymentStatus, PAYMENT_STATUS);\n    ctx.result("Payment status sent");\n});\n```\n\n#### Reliability Guarantees\n\nAll messages are persisted to the database, so if `send` completes successfully, the destination workflow is guaranteed to be able to `recv` it.\nIf you\'re sending a message from a workflow, DBOS guarantees exactly-once delivery.\nIf you\'re sending a message from normal Java code, you can use a unique workflow ID to guarantee exactly-once delivery.\n\n## Workflow Events\n\nWorkflows can publish _events_, which are key-value pairs associated with the workflow.\nThey are useful for publishing information about the status of a workflow or to send a result to clients while the workflow is running.\n\n<img src={require(\'@site/static/img/workflow-communication/workflow-events.png\').default} alt="DBOS Steps" width="750" className="custom-img"/>\n\n#### setEvent\n\n```java\nstatic void setEvent(String key, Object value)\n```\n\nAny workflow can call `DBOS.setEvent` to publish a key-value pair, or update its value if it has already been published.\n\n#### getEvent\n\n```java\nstatic Object getEvent(String workflowId, String key, Duration timeout)\n```\n\nYou can call `DBOS.getEvent` to retrieve the value published by a particular workflow identity for a particular key.\nIf the event does not yet exist, this call waits for it to be published, returning `null` if the wait times out.\n\nYou can also call `getEvent` from outside of your DBOS application with DBOS Client.\n\n#### Events Example\n\nEvents are especially useful for writing interactive workflows that communicate information to their caller.\nFor example, in a checkout system, after validating an order, the checkout workflow needs to send the customer a unique payment ID.\nTo communicate the payment ID to the customer, it uses events.\n\nThe payments workflow emits the payment ID using `setEvent()`:\n\n```java\ninterface Checkout {\n    void checkoutWorkflow();\n}\n\nclass CheckoutImpl implements Checkout {\n    private static final String PAYMENT_ID = "payment_id";\n\n    @Workflow(name = "checkout-workflow")\n    public void checkoutWorkflow() {\n        // ... validation logic\n        String paymentId = generatePaymentId();\n        DBOS.setEvent(PAYMENT_ID, paymentId);\n        // ... continue processing\n    }\n}\n```\n\nThe handler that originally started the workflow uses `getEvent()` to await this payment ID, then returns it:\n\n```java\napp.post("/checkout/{idempotency_key}", ctx -> {\n    String idempotencyKey = ctx.pathParam("idempotency_key");\n\n    // Idempotently start the checkout workflow in the background.\n    WorkflowHandle<Void, RuntimeException> handle = DBOS.startWorkflow(\n        () -> checkoutProxy.checkoutWorkflow(),\n        new StartWorkflowOptions().withWorkflowId(idempotencyKey)\n    );\n\n    // Wait for the checkout workflow to send a payment ID, then return it.\n    String paymentId = (String) DBOS.getEvent(handle.workflowId(), PAYMENT_ID, Duration.ofSeconds(60));\n    if (paymentId == null) {\n        ctx.status(404);\n        ctx.result("Checkout failed to start");\n    } else {\n        ctx.result(paymentId);\n    }\n});\n```\n\nAll events are persisted to the database, so the latest version of an event is always retrievable.\nAdditionally, if `getEvent` is called in a workflow, the retrieved value is persisted in the database so workflow recovery can use that value, even if the event is later updated.\n\n\n### Reliability Guarantees\n\nWhen using DBOS workflows, you should call any method that performs complex operations or accesses external APIs or services as a _step_.\nIf a workflow is interrupted, upon restart it automatically resumes execution from the **last completed step**.\n\nYou can use `runStep` to call a method as a step.\nA step can return any serializable value and may throw checked or unchecked exceptions.\n\nHere\'s a simple example:\n\n```java\nclass ExampleImpl implements Example {\n\n    private int generateRandomNumber(int n) {\n        return new Random().nextInt(n);\n    }\n\n    @Workflow(name = "workflowFunction")\n    public int workflowFunction(int n) {\n        int randomNumber = DBOS.runStep(\n            () -> generateRandomNumber(n), // Run generateRandomNumber as a checkpointed step\n            "generateRandomNumber" // A name for the step\n        );\n        return randomNumber;\n    }\n}\n```\n\nYou should make a method a step if you\'re using it in a DBOS workflow and it performs a **nondeterministic** operation.\nA nondeterministic operation is one that may return different outputs given the same inputs.\nCommon nondeterministic operations include:\n\n- Accessing an external API or service.\n- Accessing files on disk.\n- Generating a random number.\n- Getting the current time.\n\nYou **cannot** call, start, or enqueue workflows from within steps.\nThese operations should be performed from workflow methods.\nYou can call one step from another step, but the called step becomes part of the calling step\'s execution rather than functioning as a separate step.\n\n## Configurable Retries\n\nYou can optionally configure a step to automatically retry any error a set number of times with exponential backoff.\nThis is useful for automatically handling transient failures, like making requests to unreliable APIs.\nRetries are configurable through step options that can be passed to `runStep`.\n\nAvailable retry configuration options include:\n- `withRetriesAllowed` - Whether to retry the step if it throws an exception (default: false).\n- `withMaxAttempts` - Maximum number of times this step is automatically retried on failure.\n- `withIntervalSeconds` - Initial delay between retries in seconds.\n- `withBackoffRate` - Exponential backoff multiplier between retries.\n\nFor example, let\'s write a step that fetches a website, and configure it to retry failures (such as if the site to be fetched is temporarily down) up to 10 times:\n\n```java\nclass ExampleImpl implements Example {\n\n    private String fetchStep(String url) throws Exception {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(url))\n            .build();\n\n        HttpResponse<String> response = client.send(\n            request,\n            HttpResponse.BodyHandlers.ofString()\n        );\n\n        return response.body();\n    }\n\n    @Workflow(name = "fetchWorkflow")\n    public String fetchWorkflow(String inputURL) throws Exception {\n        return DBOS.runStep(\n            () -> fetchStep(inputURL),\n            new StepOptions("fetchFunction")\n                .withRetriesAllowed(true)\n                .withMaxAttempts(10)\n                .withIntervalSeconds(0.5)\n                .withBackoffRate(2.0)\n        );\n    }\n}\n```\n\nIf a step exhausts all retry attempts, it throws an exception to the calling workflow.\n\n## Queues\n\nWorkflow queues ensure that workflow functions will be run, without starting them immediately.\nQueues are useful for controlling the number of workflows run in parallel, or the rate at which they are started.\n\nAll queues must be created before DBOS is launched, as this allows recovery to proceed correctly.\n\n### Queue\n\n```java\nnew Queue(String name)\n```\n\n```java\npublic record Queue(\n    String name,\n    Integer concurrency,\n    Integer workerConcurrency,\n    boolean priorityEnabled,\n    RateLimit rateLimit\n) { \n    public Queue withName(String name);\n    public Queue withConcurrency(Integer concurrency);\n    public Queue withWorkerConcurrency(Integer workerConcurrency);\n    public Queue withRateLimit(RateLimit rateLimit) {\n    public Queue withRateLimit(int limit, double period);\n    public Queue withPriorityEnabled(boolean priorityEnabled);\n}\n```\n\nCreate a new workflow queue with the specified name and optional configuration parameters.\nQueues must be created and registered with `DBOS.registerQueue` before DBOS is launched.\nYou can enqueue a workflow using the `withQueue` parameter of `startWorkflow`).\n\n**Parameters:**\n- **name**: The name of the queue. Must be unique among all queues in the application.\n- **workerConcurrency**: The maximum number of workflows from this queue that may run concurrently within a single DBOS process.\n- **concurrency**: The maximum number of workflows from this queue that may run concurrently. This concurrency limit is global across all DBOS processes using this queue.\n- **rateLimit**: A limit on the maximum number of functions (`limit`) that may be started in a given period (`period`).\n- **priorityEnabled**: Enable setting priority for workflows on this queue.\n\n**Example Syntax:**\n\n```java\nQueue queue = new Queue("example-queue")\n  .withWorkerConcurrency(1);\n```\n\n### DBOS.registerQueue\nQueues must be registered before DBOS is launched:\n\n```java\nstatic Queue registerQueue(Queue queue);\n```\n\n### Enqueueing from Another Application with DBOSClient\n\n`DBOSClient` provides a programmatic way to interact with your DBOS application from external code.\n\n## DBOSClient\n\n```java\nDBOSClient(String url, String user, String password)\n```\n\nConstruct the DBOSClient.\n\n**Parameters:**\n- **url**: The JDBC URL for your system database.\n- **user**: Your Postgres username or role.\n- **password**: The password for your Postgres user or role.\n\n## Workflow Interaction Methods\n\n### enqueueWorkflow\n\n```java\n<T, E extends Exception> WorkflowHandle<T, E> enqueueWorkflow(\n      EnqueueOptions options, Object[] args)\n```\n\nEnqueue a workflow and return a handle to it.\n\n**Parameters:**\n- **options**: Configuration for the enqueued workflow, as defined below.\n- **args**: An array of the workflow\'s arguments. These will be serialized and passed into the workflow when it is dequeued.\n\n**Example Syntax:**\n\nThis code enqueues workflow `exampleWorkflow` in class `com.example.ExampleImpl` on queue `example-queue` with arguments `argumentOne` and `argumentTwo`.\n\n```java\nvar client = new DBOSClient(dbUrl, dbUser, dbPassword);\nvar options =\n    new DBOSClient.EnqueueOptions(\n        "com.example.ExampleImpl", "exampleWorkflow", "example-queue");\nvar handle = client.enqueueWorkflow(options, new Object[]{"argumentOne", "argumentTwo"});\n```\n\n#### EnqueueOptions\n\n`EnqueueOptions` is a with-based configuration record for parameterizing `client.enqueueWorkflow`.\n\n\n**Constructors:**\n\n```java\npublic EnqueueOptions(String className, String workflowName, String queueName)\n```\n\nSpecify the name and class name of the workflow to enqueue and the name of the queue on which it is to be enqueued.\n\n**Methods:**\n\n- **`withWorkflowId(String workflowId)`**: Specify the idempotency ID to assign to the enqueued workflow.\n- **`withAppVersion(String appVersion)`**: The version of your application that should process this workflow. \nIf left undefined, it will be updated to the current version when the workflow is first dequeued.\n- **`withTimeout(Duration timeout)`**:  Set a timeout for the enqueued workflow. When the timeout expires, the workflow and all its children are cancelled. The timeout does not begin until the workflow is dequeued and starts execution.\n- **`withDeduplicationId(String deduplicationId)`**: At any given time, only one workflow with a specific deduplication ID can be enqueued in the specified queue. If a workflow with a deduplication ID is currently enqueued or actively executing (status `ENQUEUED` or `PENDING`), subsequent workflow enqueue attempt with the same deduplication ID in the same queue will raise an exception.\n- **`withPriority(Integer priority)`**: The priority of the enqueued workflow in the specified queue. Workflows with the same priority are dequeued in FIFO (first in, first out) order. Priority values can range from `1` to `2,147,483,647`, where a low number indicates a higher priority. Workflows without assigned priorities have the highest priority and are dequeued before workflows with assigned priorities.\n- **`withInstanceName(String name)`**: The enqueued workflow should run on this particular named class instance.\n\n\nYou can control how many workflows from a queue run simultaneously by configuring concurrency limits.\nThis helps prevent resource exhaustion when workflows consume significant memory or processing power.\n\n### Worker Concurrency\n\nWorker concurrency sets the maximum number of workflows from a queue that can run concurrently on a single DBOS process.\nThis is particularly useful for resource-intensive workflows to avoid exhausting the resources of any process.\nFor example, this queue has a worker concurrency of 5, so each process will run at most 5 workflows from this queue simultaneously:\n\n```java\nQueue queue = new Queue("example-queue")\n    .withWorkerConcurrency(5);\nDBOS.registerQueue(queue);\n```\n\n### Global Concurrency\n\nGlobal concurrency limits the total number of workflows from a queue that can run concurrently across all DBOS processes in your application.\nFor example, this queue will have a maximum of 10 workflows running simultaneously across your entire application.\n\n:::warning\nWorker concurrency limits are recommended for most use cases.\nTake care when using a global concurrency limit as any `PENDING` workflow on the queue counts toward the limit, including workflows from previous application versions.\n:::\n\n```java\nQueue queue = new Queue("example-queue")\n    .withConcurrency(10);\nDBOS.registerQueue(queue);\n```\n\n## Rate Limiting\n\nYou can set _rate limits_ for a queue, limiting the number of workflows that it can start in a given period.\nRate limits are global across all DBOS processes using this queue.\nFor example, this queue has a limit of 100 workflows with a period of 60 seconds, so it may not start more than 100 workflows in 60 seconds:\n\n```java\nQueue queue = new Queue("example-queue")\n    .withRateLimit(100, 60.0);  // 100 workflows per 60 seconds\nDBOS.registerQueue(queue);\n```\n\nRate limits are especially useful when working with a rate-limited API.\n\n## Deduplication\n\nYou can set a deduplication ID for an enqueued workflow using `withQueue` when calling `startWorkflow`.\nAt any given time, only one workflow with a specific deduplication ID can be enqueued in the specified queue.\nIf a workflow with a deduplication ID is currently enqueued or actively executing (status `ENQUEUED` or `PENDING`), subsequent workflow enqueue attempts with the same deduplication ID in the same queue will raise an exception.\n\nFor example, this is useful if you only want to have one workflow active at a time per user&mdash;set the deduplication ID to the user\'s ID.\n\n**Example syntax:**\n\n```java\n@Workflow(name = "taskWorkflow")\npublic String taskWorkflow(String task) {\n    // Process the task...\n    return "completed";\n}\n\npublic void example(Example proxy, String task, String userID) throws Exception {\n    // Use user ID for deduplication\n    WorkflowHandle<String, Exception> handle = DBOS.startWorkflow(\n        () -> proxy.taskWorkflow(task),\n        new StartWorkflowOptions().withQueue(queue).withDeduplicationId(userID)\n    );\n\n    String result = handle.getResult();\n    System.out.println("Workflow completed: " + result);\n}\n```\n\n## Priority\n\nYou can set a priority for an enqueued workflow using `withQueue`.\nWorkflows with the same priority are dequeued in **FIFO (first in, first out)** order. Priority values can range from `1` to `2,147,483,647`, where **a low number indicates a higher priority**.\nIf using priority, you must set `priorityEnabled` on your queue.\n\n:::tip\nWorkflows without assigned priorities have the highest priority and are dequeued before workflows with assigned priorities.\n:::\n\nTo use priorities in a queue, you must enable it when creating the queue:\n\n```java\nQueue queue = new Queue("example-queue")\n    .withPriorityEnabled(true);\nDBOS.registerQueue(queue);\n```\n\n**Example syntax:**\n\n```java\n@Workflow(name = "taskWorkflow")\npublic String taskWorkflow(String task) {\n    // Process the task...\n    return "completed";\n}\n\npublic void example(Example proxy, String task, int priority) throws Exception {\n    WorkflowHandle<String, Exception> handle = DBOS.startWorkflow(\n        () -> proxy.taskWorkflow(task),\n        new StartWorkflowOptions().withQueue(queue).withPriority(priority)\n    );\n\n    String result = handle.getResult();\n    System.out.println("Workflow completed: " + result);\n}\n```\n\n## Classes and Instances\n\nYou can use multiple instances of the same class containing workflow methods, but if you do, they must be named at the time they are registered with registerWorkflows.  This name allows workflow recovery to be directed to the correct instance.\n\n```java\nstatic <T> T registerWorkflows(Class<T> interfaceClass, T implementation, String instanceName)\n```\n\n## Workflow Handles\n\nStarting a workflow or retrieving it produces a WorkflowHandle for interacting with the workflow.\n\n```java\nstatic WorkflowHandle<T, E> retrieveWorkflow(String workflowId)\n```\n\nRetrieve the handle of a workflow.\n\n**Parameters**:\n- **workflowId**: The ID of the workflow whose handle to retrieve.\n\n```java\npublic interface WorkflowHandle<T, E extends Exception> {\n\n  String workflowId();\n\n  T getResult() throws E;\n\n  WorkflowStatus getStatus();\n}\n```\n\nWorkflowHandle provides methods to interact with a running or completed workflow.\nThe type parameters `T` and `E` represents the expected return type of the workflow and the checked exceptions it may throw.\nHandles can be used to wait for workflow completion, check status, and retrieve results. \n\n#### WorkflowHandle.getResult\n\n```java\nT getResult() throws E;\n```\n\nWait for the workflow to complete and return its result.\n\n#### WorkflowHandle.getStatus\n\n```java\nWorkflowStatus getStatus();\n```\n\nRetrieve the WorkflowStatus of the workflow.\n\n#### WorkflowHandle.workflowId\n\n```java\nString workflowId();\n```\n\nReturn the ID of the workflow underlying this handle.\n\n### Workflow Status\n\nSome workflow introspection and management methods return a `WorkflowStatus`.\nThis object has the following definition:\n\n```java\npublic record WorkflowStatus(\n    // The workflow ID\n    String workflowId,\n    // The workflow status. Must be one of ENQUEUED, PENDING, SUCCESS, ERROR, CANCELLED, or MAX_RECOVERY_ATTEMPTS_EXCEEDED\n    String status,\n    // The name of the workflow function\n    String name,\n    // The class of the workflow function\n    String className,\n    // The name given to the class instance, if any\n    String instanceName,\n    // The deserialized workflow input object\n    Object[] input,\n    // The workflow\'s output, if any\n    Object output,\n    // The error the workflow threw, if any\n    ErrorResult error,\n    // Workflow start time, as a Unix epoch timestamp in ms\n    Long createdAt,\n    // The last time the workflow status was updated, as a Unix epoch timestamp in ms\n    Long updatedAt,\n    // If this workflow was enqueued, on which queue\n    String queueName,\n    // The ID of the executor (process) that most recently executed this workflow\n    String executorId,\n    // The application version on which this workflow was started\n    String appVersion,\n    // The workflow timeout, if any\n    Long workflowTimeoutMs,\n    // The Unix epoch timestamp at which this workflow will time out, if any\n    Long workflowDeadlineEpochMs,\n    // The number of times this workflow has been started\n    Integer recoveryAttempts\n)\n```\n\n## DBOS Variables\n\n### workflowId\n\n```java\nstatic String workflowId()\n```\n\nRetrieve the ID of the current workflow. Returns `null` if not called from a workflow or step.\n\n### stepId\n\n```java\nstatic Integer stepId()\n```\n\nReturns the unique ID of the current step within its workflow. Returns `null` if not called from a step.\n\n### inWorkflow\n\n```java\nstatic boolean inWorkflow();\n```\n\nReturn `true` if the current calling context is executing a workflow, or `false` otherwise.\n\n### inStep\n\n```java\nstatic boolean inStep();\n```\n\nReturn `true` if the current calling context is executing a workflow step, or `false` otherwise.\n\n\n## Workflow Management Methods\n\n### listWorkflows\n\n```java\nstatic List<WorkflowStatus> listWorkflows(ListWorkflowsInput input)\n```\n\nRetrieve a list of WorkflowStatus of all workflows matching specified criteria.\n\n#### ListWorkflowsInput\n\n`ListWorkflowsInput` is a with-based configuration record for filtering and customizing workflow queries.  All fields are optional.\n\n**`with` Methods:**\n\n##### withWorkflowId\n```java\nListWorkflowsInput withWorkflowId(String workflowId)\n```\nAdd a workflow ID to filter by.\n\n##### withWorkflowIds\n```java\nListWorkflowsInput withWorkflowIds(List<String> workflowIDs)\n```\nAdd multiple workflow IDs to filter by.\n\n##### withClassName\n```java\nListWorkflowsInput withClassName(String className)\n```\nFilter workflows by the class name containing the workflow function.\n\n##### withInstanceName\n```java\nListWorkflowsInput withInstanceName(String instanceName)\n```\nFilter workflows by the instance name of the class.\n\n##### withWorkflowName\n```java\nListWorkflowsInput withWorkflowName(String workflowName)\n```\nFilter workflows by the workflow function name.\n\n##### withAuthenticatedUser\n```java\nListWorkflowsInput withAuthenticatedUser(String authenticatedUser)\n```\nFilter workflows run by this authenticated user.\n\n##### withStartTime\n```java\nListWorkflowsInput withStartTime(OffsetDateTime startTime)\n```\nRetrieve workflows started after this timestamp.\n\n##### withEndTime\n```java\nListWorkflowsInput withEndTime(OffsetDateTime endTime)\n```\nRetrieve workflows started before this timestamp.\n\n##### withStatus\n```java\nListWorkflowsInput withStatus(WorkflowState status)\nListWorkflowsInput withStatus(String status)\nListWorkflowsInput withStatuses(List<String> status)\n```\nFilter workflows by status. Status must be one of: `ENQUEUED`, `PENDING`, `SUCCESS`, `ERROR`, `CANCELLED`, or `MAX_RECOVERY_ATTEMPTS_EXCEEDED`.\n\n##### withApplicationVersion\n```java\nListWorkflowsInput withApplicationVersion(String applicationVersion)\n```\nRetrieve workflows tagged with this application version.\n\n##### withLimit\n```java\nListWorkflowsInput withLimit(Integer limit)\n```\nRetrieve up to this many workflows.\n\n##### withOffset\n```java\nListWorkflowsInput withOffset(Integer offset)\n```\nSkip this many workflows from the results returned (for pagination).\n\n##### withSortDesc\n```java\nListWorkflowsInput withSortDesc(Boolean sortDesc)\n```\nSort the results in descending (true) or ascending (false) order by workflow start time.\n\n##### withExecutorId\n```java\nListWorkflowsInput withExecutorId(String executorId)\n```\nRetrieve workflows that ran on this executor process.\n\n##### withQueueName\n```java\nListWorkflowsInput withQueueName(String queueName)\n```\nRetrieve workflows that were enqueued on this queue.\n\n##### withWorkflowIdPrefix\n```java\nListWorkflowsInput withWorkflowIdPrefix(String workflowIdPrefix)\n```\nFilter workflows whose IDs start with the specified prefix.\n\n##### withQueuesOnly\n```java\nListWorkflowsInput withQueuesOnly(Boolean queuedOnly)\n```\nSelect only workflows that were enqueued.\n\n##### withLoadInput\n```java\nListWorkflowsInput withLoadInput(Boolean value)\n```\nControls whether to load workflow input data (default: true).\n\n##### withLoadOutput\n```java\nListWorkflowsInput withLoadOutput(Boolean value)\n```\nControls whether to load workflow output data (results and errors) (default: true).\n\n\n### listWorkflowSteps\n\n```java\nstatic List<StepInfo> listWorkflowSteps(String workflowId)\n```\n\nRetrieve the execution steps of a workflow.\nThis is a list of `StepInfo` objects, with the following structure:\n\n```java\nStepInfo(\n    // The sequential ID of the step within the workflow\n    int functionId,\n    // The name of the step function\n    String functionName,\n    // The output returned by the step, if any\n    Object output,\n    // The error returned by the step, if any\n    ErrorResult error,\n    // If the step starts or retrieves the result of a workflow, its ID\n    String childWorkflowId\n)\n```\n\n### cancelWorkflow\n\n```java\nstatic cancelWorkflow(String workflowId)\n```\n\nCancel a workflow. This sets its status to `CANCELLED`, removes it from its queue (if it is enqueued) and preempts its execution (interrupting it at the beginning of its next step).\n\n### resumeWorkflow\n\n```java\nstatic <T, E extends Exception> WorkflowHandle<T, E> resumeWorkflow(String workflowId)\n```\n\nResume a workflow. This immediately starts it from its last completed step. You can use this to resume workflows that are cancelled or have exceeded their maximum recovery attempts. You can also use this to start an enqueued workflow immediately, bypassing its queue.\n\n### forkWorkflow\n\n```java\nstatic <T, E extends Exception> WorkflowHandle<T, E> forkWorkflow(\n      String workflowId, \n      int startStep, \n      ForkOptions options\n)\n```\n\n```java\npublic record ForkOptions(\n    String forkedWorkflowId, \n    String applicationVersion, \n    Duration timeout\n)\n{\n    ForkOptions withForkedWorkflowId(String forkedWorkflowId);\n    ForkOptions withApplicationVersion(String applicationVersion);\n    ForkOptions withTimeout(Duration timeout);\n}\n```\n\nStart a new execution of a workflow from a specific step. The input step ID (`startStep`) must match the step number of the step returned by workflow introspection. The specified `startStep` is the step from which the new workflow will start, so any steps whose ID is less than `startStep` will not be re-executed.\n\n**Parameters:**\n- **workflowId**: The ID of the workflow to fork\n- **startStep**: The step from which to fork the workflow\n- **options**:\n  - **forkedWorkflowId**: The workflow ID for the newly forked workflow (if not provided, generate a UUID)\n  - **applicationVersion**: The application version for the forked workflow (inherited from the original if not provided)\n  - **timeout**: A timeout for the forked workflow.\n\n\n## Configuring DBOS\n\nConfigure the DBOS singleton.\n\n**DBOSConfig**\n\n`DBOSConfig` is a with-based configuration record for configuring DBOS.\nThe application name, database URL, database user, and database password are required.\n\n\n**Constructor:**\n\n```java\nDBOSConfig.defaults(String appName)\n```\n\nCreate a DBOSConfig object.  This configuration can be adjusted by using `with` methods that produce new configurations.\n\n**With Methods:**\n\n- **`withAppName(String appName)`**: Your application\'s name. Required.\n\n- **`withDatabaseUrl(String databaseUrl)`**: The JDBC URL for your system database. Required. A valid JDBC URL is of the form `jdbc:postgresql://host:port/database`\n\n- **`withDbUser(String dbUser)`**: Your Postgres username or role. Required.\n\n- **`withDbPassword(String dbPassword)`**: The password for your Postgres user or role. Required.\n\n- **`withMaximumPoolSize(int maximumPoolSize)`**: The maximum size for the system database connection pool created by DBOS.\n\n- **`withConnectionTimeout(int connectionTimeout)`**: The connection timeout for the system database connection created by DBOS.\n\n- **`withAdminServer(boolean enable)`**: Whether to run an HTTP admin server for workflow management operations. Defaults to false.\n\n- **`withAdminServerPort(int port)`**: The port on which the admin server runs. Defaults to 3001.\n\n- **`withMigrate(boolean enable)`**: If true, attempt to apply migrations to the system database.  Defaults to true.\n\n- **`withConductorKey(String key)`**: An API key for DBOS Conductor. If provided, application is connected to Conductor. API keys can be created from the DBOS console.\n\n- **`withAppVersion(String appVersion)`**: The code version for this application and its workflows. Workflow versioning is documented here.\n\n'})})]})}function w(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var o=t(6540);const r={},i=o.createContext(r);function a(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);