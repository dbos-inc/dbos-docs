"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[8063],{6187:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>d,frontMatter:()=>c,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"typescript/tutorials/transaction-tutorial","title":"Transactions & Datasources","description":"Learn how to perform database operations","source":"@site/docs/typescript/tutorials/transaction-tutorial.md","sourceDirName":"typescript/tutorials","slug":"/typescript/tutorials/transaction-tutorial","permalink":"/typescript/tutorials/transaction-tutorial","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":30,"frontMatter":{"sidebar_position":30,"title":"Transactions & Datasources","description":"Learn how to perform database operations"},"sidebar":"tutorialSidebar","previous":{"title":"Steps","permalink":"/typescript/tutorials/step-tutorial"},"next":{"title":"Queues & Concurrency","permalink":"/typescript/tutorials/queue-tutorial"}}');var s=t(4848),r=t(8453);const c={sidebar_position:30,title:"Transactions & Datasources",description:"Learn how to perform database operations"},i=void 0,o={},l=[{value:"Installing Data Sources",id:"installing-data-sources",level:2},{value:"Using Datasources",id:"using-datasources",level:2},{value:"Registering Functions",id:"registering-functions",level:2},{value:"Using Decorators",id:"using-decorators",level:2},{value:"Installing the DBOS Schema",id:"installing-the-dbos-schema",level:3}];function u(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...e.components},{TabItem:t,Tabs:a}=n;return t||g("TabItem",!0),a||g("Tabs",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["DBOS Transactions are a special kind of step intended for database access.  They execute as a single ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Database_transaction",children:"database transaction"}),", atomically committing both user-defined changes and a DBOS checkpoint."]}),"\n",(0,s.jsxs)(n.p,{children:["You can perform transactions using datasources, which wrap database clients with DBOS-aware transaction logic.  Datasources are available for popular TypeScript libraries and expose the same interface as the underlying client. For example, the Knex datasource provides a ",(0,s.jsx)(n.code,{children:"Knex.Transaction"})," client, and the Drizzle datasource provides a Drizzle ",(0,s.jsx)(n.code,{children:"Transaction<>"})," client. This means you can use your existing database statements\u2014just use the transaction provided within the datasource."]}),"\n",(0,s.jsx)(n.h2,{id:"installing-data-sources",children:"Installing Data Sources"}),"\n",(0,s.jsx)(n.p,{children:"Each datasource is implemented in its own package, which must be installed before use."}),"\n",(0,s.jsxs)(a,{groupId:"database-clients",children:[(0,s.jsx)(t,{value:"knex",label:"Knex",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npm i @dbos-inc/knex-datasource\n"})})}),(0,s.jsx)(t,{value:"kysely",label:"Kysely",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npm i @dbos-inc/kysely-datasource\n"})})}),(0,s.jsx)(t,{value:"drizzle",label:"Drizzle",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npm i @dbos-inc/drizzle-datasource\n"})})}),(0,s.jsx)(t,{value:"typeorm",label:"TypeORM",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npm i @dbos-inc/typeorm-datasource\n"})})}),(0,s.jsx)(t,{value:"prisma",label:"Prisma",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npm i @dbos-inc/prisma-datasource\n"})})}),(0,s.jsx)(t,{value:"node-postgres",label:"node-postgres",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npm i @dbos-inc/nodepg-datasource\n"})})}),(0,s.jsx)(t,{value:"pg",label:"Postgres.js",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"npm i @dbos-inc/postgres-datasource\n"})})})]}),"\n",(0,s.jsx)(n.h2,{id:"using-datasources",children:"Using Datasources"}),"\n",(0,s.jsx)(n.p,{children:"Before using a datasource, you must configure and construct it:"}),"\n",(0,s.jsxs)(a,{groupId:"database-clients",children:[(0,s.jsx)(t,{value:"knex",label:"Knex",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const config = {client: 'pg', connection: process.env.DBOS_DATABASE_URL}\nconst dataSource = new KnexDataSource('app-db', config);\n"})})}),(0,s.jsx)(t,{value:"kysely",label:"Kysely",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const config = { connectionString: process.env.DBOS_DATABASE_URL };\nconst dataSource = new KyselyDataSource<Database>('app-db', config);\n"})})}),(0,s.jsx)(t,{value:"drizzle",label:"Drizzle",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export const config = { connectionString: process.env.DBOS_DATABASE_URL };\nconst dataSource = new DrizzleDataSource<NodePgDatabase>('app-db', config);\n"})})}),(0,s.jsx)(t,{value:"typeorm",label:"TypeORM",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const config = { connectionString: process.env.DBOS_DATABASE_URL };\nconst dataSource1 = TypeORMDataSource.createFromConfig('app-db', config, [/*entities*/]);\nconst dataSource2 = TypeORMDataSource.createFromDataSource('app-db-2', existingTypeOrmDS);\n"})})}),(0,s.jsx)(t,{value:"prisma",label:"Prisma",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"process.env['DATABASE_URL'] = process.env['DBOS_DATABASE_URL'];\nconst prismaClient = new PrismaClient();\nconst dataSource = new PrismaDataSource<PrismaClient>('app-db', prismaClient);\n"})})}),(0,s.jsx)(t,{value:"node-postgres",label:"node-postgres",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const dataSource = new NodePostgresDataSource('app-db', {connectionString: process.env.DBOS_DATABASE_URL});\n"})})}),(0,s.jsx)(t,{value:"pg",label:"Postgres.js",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const dataSource = new PostgresDataSource('app-db', {connection: {url: process.env.DBOS_DATABASE_URL}});\n"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["Note that the names ",(0,s.jsx)(n.code,{children:"dataSource"})," and ",(0,s.jsx)(n.code,{children:"app-db"})," are used throughout this page, but were chosen arbitrarily.  It is possible to use several datasource instances, with different names."]}),"\n",(0,s.jsxs)(n.p,{children:["You can run a function as a transaction using ",(0,s.jsx)(n.code,{children:"dataSource.runTransaction"}),".  The transaction function should use ",(0,s.jsx)(n.code,{children:"dataSource.client"})," as a client to access the database.  (Note that while some data source classes expose a static ",(0,s.jsx)(n.code,{children:"client"})," property, the data source object instance should be used to get the ",(0,s.jsx)(n.code,{children:"client"})," as the instance asserts that its client is actually available.)"]}),"\n",(0,s.jsx)(n.p,{children:"Examples:"}),"\n",(0,s.jsxs)(a,{groupId:"database-clients",children:[(0,s.jsx)(t,{value:"knex",label:"Knex",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async function insertFunction(user: string) {\n  const rows = await dataSource\n    .client<greetings>('greetings')\n    .insert({ name: user, greet_count: 1 })\n    .onConflict('name')\n    .merge({ greet_count: dataSource.client.raw('greetings.greet_count + 1') })\n    .returning('greet_count');\n  const row = rows.length > 0 ? rows[0] : undefined;\n\n  return { user, greet_count: row?.greet_count, now: Date.now() };\n}\n\nawait dataSource.runTransaction(() => insertFunction(user), { name: 'insertFunction' /*Transaction options go here*/ });\n"})})}),(0,s.jsx)(t,{value:"kysely",label:"Kysely",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async function insertFunction(user: string) {\n  const row = await dataSource.client\n    .insertInto('greetings')\n    .values({ name: user, greet_count: 1 })\n    .onConflict((oc) =>\n      oc.column('name').doUpdateSet({\n        greet_count: sql`greetings.greet_count + 1`,\n      }),\n    )\n    .returning('greet_count')\n    .executeTakeFirst();\n\n  return {\n    user,\n    greet_count: row?.greet_count!,\n    now: Date.now()\n  }\n}\n\nawait dataSource.runTransaction(() => insertFunction(user), { name: 'insertFunction' /*Transaction options go here*/ });\n"})})}),(0,s.jsx)(t,{value:"drizzle",label:"Drizzle",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async function insertFunction(user: string) {\n  const result = await dataSource.client\n    .insert(greetingsTable)\n    .values({ name: user, greet_count: 1 })\n    .onConflictDoUpdate({\n      target: greetingsTable.name,\n      set: {\n        greet_count: sql`${greetingsTable.greet_count} + 1`,\n      },\n    })\n    .returning({ greet_count: greetingsTable.greet_count });\n\n  const row = result.length > 0 ? result[0] : undefined;\n  return { user, greet_count: row?.greet_count, now: Date.now() };\n}\n\nawait dataSource.runTransaction(() => insertFunction(user), { name: 'insertFunction' /*Transaction options go here*/ });\n"})})}),(0,s.jsx)(t,{value:"typeorm",label:"TypeORM",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async function insertFunction(user: string) {\n  type Result = Array<{ greet_count: number }>;\n  const rows = await dataSource.entityManager.sql<Result>`\n     INSERT INTO greetings(name, greet_count) VALUES(${user}, 1)\n     ON CONFLICT(name) DO UPDATE SET greet_count = greetings.greet_count + 1\n     RETURNING greet_count`;\n\n  const row = rows.length > 0 ? rows[0] : undefined;\n  return { user, greet_count: row?.greet_count, now: Date.now() };\n}\n\nawait dataSource.runTransaction(() => insertFunction(user), { name: 'insertFunction' /*Transaction options go here*/ });\n"})})}),(0,s.jsx)(t,{value:"prisma",label:"Prisma",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async function insertFunction(user: string) {\n  const existing = await dataSource.client.dbosHello.findUnique({\n    where: { name: user },\n    select: { greet_count: true },\n  });\n\n  let greet_count: number;\n\n  if (!existing) {\n    const created = await dataSource.client.dbosHello.create({\n      data: { name: user, greet_count: 1 },\n      select: { greet_count: true },\n    });\n    greet_count = created.greet_count;\n  } else {\n    const updated = await dataSource.client.dbosHello.update({\n      where: { name: user },\n      data: { greet_count: { increment: 1 } },\n      select: { greet_count: true },\n    });\n    greet_count = updated.greet_count;\n  }\n\n  return {\n    user,\n    greet_count,\n    now: Date.now(),\n  };\n}\n\nawait dataSource.runTransaction(() => insertFunction(user), { name: 'insertFunction' /*Transaction options go here*/ });\n"})})}),(0,s.jsx)(t,{value:"node-postgres",label:"node-postgres",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async function insertFunction(user: string) {\n  const { rows } = await dataSource.client.query<Pick<greetings, 'greet_count'>>(\n    `INSERT INTO greetings(name, greet_count)\n     VALUES($1, 1)\n     ON CONFLICT(name)\n     DO UPDATE SET greet_count = greetings.greet_count + 1\n     RETURNING greet_count`,\n    [user],\n  );\n  const row = rows.length > 0 ? rows[0] : undefined;\n  return { user, greet_count: row?.greet_count, now: Date.now() };\n}\n\nawait dataSource.runTransaction(() => insertFunction(user), { name: 'insertFunction' /*Transaction options go here*/ });\n"})})}),(0,s.jsx)(t,{value:"pg",label:"Postgres.js",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async function insertFunction(user: string) {\n  const rows = await dataSource.client<Pick<greetings, 'greet_count'>[]>`\n    INSERT INTO greetings(name, greet_count)\n    VALUES(${user}, 1)\n    ON CONFLICT(name)\n    DO UPDATE SET greet_count = greetings.greet_count + 1\n    RETURNING greet_count`;\n  const row = rows.length > 0 ? rows[0] : undefined;\n  return { user, greet_count: row?.greet_count, now: Date.now() };\n}\n\nawait dataSource.runTransaction(() => insertFunction(user), { name: 'insertFunction' /*Transaction options go here*/ });\n"})})})]}),"\n",(0,s.jsx)(n.h2,{id:"registering-functions",children:"Registering Functions"}),"\n",(0,s.jsxs)(n.p,{children:["Alternatively, functions can be registered as transactions with ",(0,s.jsx)(n.code,{children:"dataSource.registerTransaction"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const insertRowTransaction = dataSource.registerTransaction(insertFunction, {/*Transaction options go here*/});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The function wrapper returned from ",(0,s.jsx)(n.code,{children:"dataSource.registerTransaction"})," has the same signature as the input function, and will automatically start a transaction with any name and transaction options provided."]}),"\n",(0,s.jsx)(n.h2,{id:"using-decorators",children:"Using Decorators"}),"\n",(0,s.jsxs)(n.p,{children:["Class member functions can be decorated with ",(0,s.jsx)(n.code,{children:"@dataSource.transaction()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@dataSource.transaction(/*Transaction options go here*/)\nstatic async insertRow() {\n  await dataSource.client. // Use library-specific client calls\n}\n\n@DBOS.workflow()\nstatic async transactionWorkflow() {\n  await Toolbox.insertRow()\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Such methods will be run inside datasource transactions when called."}),"\n",(0,s.jsx)(n.h3,{id:"installing-the-dbos-schema",children:"Installing the DBOS Schema"}),"\n",(0,s.jsxs)(n.p,{children:["DBOS datasources require an additional ",(0,s.jsx)(n.code,{children:"transaction_completion"})," table within the ",(0,s.jsx)(n.code,{children:"dbos"})," schema.  This table is used for recordkeeping, ensuring that each transaction is run exactly once."]}),"\n",(0,s.jsxs)(n.p,{children:["This table can be installed by running the ",(0,s.jsx)(n.code,{children:"initializeDBOSSchema"})," method of your datasource. You may do this as part of database schema migrations or at app startup. For example, here is a Knex migration file that installs the DBOS schema in Knex:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const {\n  KnexDataSource\n} = require('@dbos-inc/knex-datasource');\n\nexports.up = async function(knex) {\n  await KnexDataSource.initializeDBOSSchema(knex);\n};\n\nexports.down = async function(knex) {\n  await KnexDataSource.uninitializeDBOSSchema(knex);\n};\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}function g(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>i});var a=t(6540);const s={},r=a.createContext(s);function c(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);