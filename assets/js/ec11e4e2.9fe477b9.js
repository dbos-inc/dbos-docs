"use strict";(self.webpackChunkoperon_docs=self.webpackChunkoperon_docs||[]).push([[435],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(a),m=r,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return a?n.createElement(h,i(i({ref:t},c),{},{components:a})):n.createElement(h,i({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},8986:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const o={sidebar_position:4,title:"Decorators",description:"API reference for Operon decorators."},i="Operon Decorators",l={unversionedId:"api-reference/decorators",id:"api-reference/decorators",title:"Decorators",description:"API reference for Operon decorators.",source:"@site/docs/api-reference/decorators.md",sourceDirName:"api-reference",slug:"/api-reference/decorators",permalink:"/api-reference/decorators",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Decorators",description:"API reference for Operon decorators."},sidebar:"tutorialSidebar",previous:{title:"Operon Contexts",permalink:"/api-reference/contexts"},next:{title:"Testing Runtime",permalink:"/api-reference/testing-runtime"}},s={},p=[{value:"Background",id:"background",level:2},{value:"Decorator Implementations",id:"decorator-implementations",level:3},{value:"Typescript Compiler Flags",id:"typescript-compiler-flags",level:3},{value:"Decorator Locations",id:"decorator-locations",level:2},{value:"Class Decorators",id:"class-decorators",level:3},{value:"Function Decorators",id:"function-decorators",level:3},{value:"Parameter Decorators",id:"parameter-decorators",level:3},{value:"Decorators Reference",id:"decorators-reference",level:2},{value:"Operon Decorators",id:"operon-decorators-1",level:3},{value:"<code>@OperonWorkflow</code>",id:"operonworkflow",level:4},{value:"<code>@OperonTransaction</code>",id:"operontransaction",level:4},{value:"<code>@OperonCommunicator</code>",id:"operoncommunicator",level:4},{value:"HTTP API Registration Decorators",id:"http-api-registration-decorators",level:3},{value:"<code>@GetApi</code>",id:"getapi",level:4},{value:"<code>@PostApi</code>",id:"postapi",level:4},{value:"<code>@ArgSource</code>",id:"argsource",level:4},{value:"<code>@Authentication</code>",id:"authentication",level:4},{value:"<code>@KoaMiddleware</code>",id:"koamiddleware",level:4},{value:"Declarative Security Decorators",id:"declarative-security-decorators",level:3},{value:"<code>@RequiredRole</code>",id:"requiredrole",level:4},{value:"<code>@DefaultRequiredRole</code>",id:"defaultrequiredrole",level:4},{value:"Input Validation Decorators",id:"input-validation-decorators",level:3},{value:"<code>@ArgRequired</code>",id:"argrequired",level:4},{value:"<code>@DefaultArgRequired</code>",id:"defaultargrequired",level:4},{value:"<code>@ArgOptional</code>",id:"argoptional",level:4},{value:"<code>@DefaultArgOptional</code>",id:"defaultargoptional",level:4},{value:"<code>@ArgName</code>",id:"argname",level:4},{value:"<code>@ArgDate</code>",id:"argdate",level:4},{value:"<code>@ArgVarchar</code>",id:"argvarchar",level:4},{value:"Logging and Tracing Decorators",id:"logging-and-tracing-decorators",level:3},{value:"<code>@Debug</code>",id:"debug",level:4},{value:"<code>@SkipLogging</code>",id:"skiplogging",level:4},{value:"<code>@LogMask</code>",id:"logmask",level:4},{value:"Other Decorators",id:"other-decorators",level:3},{value:"TypeORM Decorators",id:"typeorm-decorators",level:4},{value:"<code>@OrmEntities</code>",id:"ormentities",level:5}],c={toc:p},d="wrapper";function u(e){let{components:t,...a}=e;return(0,r.kt)(d,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"operon-decorators"},"Operon Decorators"),(0,r.kt)("h2",{id:"background"},"Background"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/decorators.html"},"Decorators")," in TypeScript are a way to declaratively alter classes, functions, and parameters. Decorators precede the decorated class, function, or parameter, and begin with ",(0,r.kt)("inlineCode",{parentName:"p"},"@"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"  @Decorated\n  class decorated {\n  ...\n  }\n")),(0,r.kt)("p",null,"Decorators may or may not take arguments in parenthesis ",(0,r.kt)("inlineCode",{parentName:"p"},"()"),".  However, each specific decorator either requires or refuses parenthesis. In the following, adding ",(0,r.kt)("inlineCode",{parentName:"p"},"()")," after ",(0,r.kt)("inlineCode",{parentName:"p"},"@Required")," will lead to an error, as will omitting ",(0,r.kt)("inlineCode",{parentName:"p"},"()")," after ",(0,r.kt)("inlineCode",{parentName:"p"},"@LogMask"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"@Required @LogMask(LogMasks.HASH) password: string\n")),(0,r.kt)("p",null,"This concept is not new to TypeScript.  Python is another popular language with decorators prefixed with ",(0,r.kt)("inlineCode",{parentName:"p"},"@"),'.  In other languages, such as Java, similar declarations are called "annotations".'),(0,r.kt)("p",null,"While, in general, the order in which decorators are listed can affect the behavior, all decorators in the Operon API are order-independent.  So this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'  @OperonTransaction()\n  @PostApi("/follow")\n  static async doFollow(ctx: TransactionContext, followUid: string) {\n  ...\n  }\n')),(0,r.kt)("p",null,"is the same as this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'  @PostApi("/follow")\n  @OperonTransaction()\n  static async doFollow(ctx: TransactionContext, followUid: string) {\n  ...\n  }\n')),(0,r.kt)("h3",{id:"decorator-implementations"},"Decorator Implementations"),(0,r.kt)("p",null,"Work to add decorators to the TypeScript language and standards is currently ongoing, leaving things in a state of flux."),(0,r.kt)("p",null,'Whereas the most useful version of decorators implemented in the TypeScript compiler is "experimental" or "Stage 2" decorators, the language specifications have not caught up.  "Stage 3" decorators, which are specified and implemented, are missing two key features used in Operon:'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Parameter decorators"),(0,r.kt)("li",{parentName:"ul"},"Metadata about function argument types")),(0,r.kt)("p",null,'It is expected that Operon will be moved from "experimental"/"Stage 2" decorators to a standards-based implementation once the standards have caught up.  It is hoped that user code would not be affected in this transition.'),(0,r.kt)("h3",{id:"typescript-compiler-flags"},"Typescript Compiler Flags"),(0,r.kt)("p",null,'In order to use the "Stage 2" experimental decorators implemented by Operon, the following configuration needs to be given to the TypeScript compiler (usually via the file ',(0,r.kt)("inlineCode",{parentName:"p"},"tsconfig.json"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "compilerOptions": {\n    "experimentalDecorators": true,\n    "emitDecoratorMetadata": true,\n  }\n}\n')),(0,r.kt)("h2",{id:"decorator-locations"},"Decorator Locations"),(0,r.kt)("p",null,"Operon currently uses decorators at the class, function, or function parameter level.  (The language also supports decorators at the property or accessor level, but Operon currently doesn't use them.)"),(0,r.kt)("h3",{id:"class-decorators"},"Class Decorators"),(0,r.kt)("p",null,"Class decorators are affixed to a class, just before the keyword ",(0,r.kt)("inlineCode",{parentName:"p"},"class"),".  Operon decorators will be applied to all Operon functions in the class."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#authentication"},(0,r.kt)("inlineCode",{parentName:"a"},"@Authentication"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#defaultrequiredrole"},(0,r.kt)("inlineCode",{parentName:"a"},"@DefaultRequiredRole")))),(0,r.kt)("h3",{id:"function-decorators"},"Function Decorators"),(0,r.kt)("p",null,"Function decorators are affixed to a function, just before its name and modifiers (such as ",(0,r.kt)("inlineCode",{parentName:"p"},"async")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"static"),"). Operon function decorators apply to the decorated function and its parameters.  Examples of function-level decorators:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#operonworkflow"},(0,r.kt)("inlineCode",{parentName:"a"},"@OperonWorkflow"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#operontransaction"},(0,r.kt)("inlineCode",{parentName:"a"},"@OperonTransaction"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#operoncommunicator"},(0,r.kt)("inlineCode",{parentName:"a"},"@OperonCommunicator"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#requiredrole"},(0,r.kt)("inlineCode",{parentName:"a"},"@RequiredRole"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#getapi"},(0,r.kt)("inlineCode",{parentName:"a"},"@GetApi"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#postapi"},(0,r.kt)("inlineCode",{parentName:"a"},"@PostApi")))),(0,r.kt)("h3",{id:"parameter-decorators"},"Parameter Decorators"),(0,r.kt)("p",null,"Parameter decorators are affixed to a function parameter, just before its name.  Operon parameter decorators apply to the treatment of the parameter, and may affect how values are validated or logged.  Examples of parameter-level decorators:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#argname"},(0,r.kt)("inlineCode",{parentName:"a"},"@ArgName"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#argdate"},(0,r.kt)("inlineCode",{parentName:"a"},"@ArgDate"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#skiplogging"},(0,r.kt)("inlineCode",{parentName:"a"},"@SkipLogging"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#logmask"},(0,r.kt)("inlineCode",{parentName:"a"},"@LogMask")))),(0,r.kt)("h2",{id:"decorators-reference"},"Decorators Reference"),(0,r.kt)("h3",{id:"operon-decorators-1"},"Operon Decorators"),(0,r.kt)("h4",{id:"operonworkflow"},(0,r.kt)("inlineCode",{parentName:"h4"},"@OperonWorkflow")),(0,r.kt)("p",null,"Registers a function as an Operon workflow."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@OperonWorkflow()\nstatic async processWorkflow(wfCtxt: WorkflowContext, value: string) {\n  ...\n}\n")),(0,r.kt)("p",null,"The first argument to an Operon workflow function must be a ",(0,r.kt)("a",{parentName:"p",href:"/api-reference/contexts#workflowcontext"},(0,r.kt)("inlineCode",{parentName:"a"},"WorkflowContext")),".  This context can be used to invoke transactions and communicators, send and receive messages, and get other contextual information such as the authenticated user."),(0,r.kt)("h4",{id:"operontransaction"},(0,r.kt)("inlineCode",{parentName:"h4"},"@OperonTransaction")),(0,r.kt)("p",null,"Registers a function as an Operon transaction."),(0,r.kt)("p",null,"The first argument of the decorated function must be a ",(0,r.kt)("a",{parentName:"p",href:"/api-reference/contexts#transactioncontext"},(0,r.kt)("inlineCode",{parentName:"a"},"TransactionContext")),", which provides access to the database transaction."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@OperonTransaction({readOnly: true})\nstatic async doLogin(ctx: TransactionContext, username: string, ) {\n  ...\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@OperonTransaction()")," takes an optional ",(0,r.kt)("inlineCode",{parentName:"p"},"TransactionConfig")," to configure two aspects of the transaction: its isolation level and whether it is read only."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface TransactionConfig {\n  isolationLevel?: IsolationLevel;\n  readOnly?: boolean;\n}\n")),(0,r.kt)("p",null,"Operon supports declaration of the following values for ",(0,r.kt)("inlineCode",{parentName:"p"},"IsolationLevel"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"READ UNCOMMITTED")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"READ COMMITTED")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"REPEATABLE READ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SERIALIZABLE"))),(0,r.kt)("p",null,"The precise transaction semantics of these levels may vary with the capabilities of the Operon user database. For example, see ",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/current/transaction-iso.html"},"isolation levels in PostgreSQL"),"."),(0,r.kt)("h4",{id:"operoncommunicator"},(0,r.kt)("inlineCode",{parentName:"h4"},"@OperonCommunicator")),(0,r.kt)("p",null,"Registers a function as an Operon communicator."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@OperonCommunicator()\nstatic async doComms(commCtxt: CommunicatorContext) {\n  ...\n}\n")),(0,r.kt)("p",null,"The first argument to an Operon communicator function must be a ",(0,r.kt)("a",{parentName:"p",href:"/api-reference/contexts#communicatorcontext"},(0,r.kt)("inlineCode",{parentName:"a"},"CommunicatorContext")),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@OperonCommunicator()")," takes an optional ",(0,r.kt)("inlineCode",{parentName:"p"},"CommunicatorConfig"),", which allows a number of communicator properties to be specified:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface CommunicatorConfig {\n  retriesAllowed?: boolean; // Should failures be retried? (default true)\n  intervalSeconds?: number; // Seconds to wait before the first retry attempt (default 1).\n  maxAttempts?: number;     // Maximum number of retry attempts (default 3). If errors occur more times than this, throw an exception.\n  backoffRate?: number;     // Multiplier by which the retry interval increases after a retry attempt (default 2).\n}\n")),(0,r.kt)("h3",{id:"http-api-registration-decorators"},"HTTP API Registration Decorators"),(0,r.kt)("h4",{id:"getapi"},(0,r.kt)("inlineCode",{parentName:"h4"},"@GetApi")),(0,r.kt)("p",null,"Associates a function with an endpoint name, such as an HTTP URL accessed with GET."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'@GetApi("/hello")\nstatic async hello(_ctx: HandlerContext) {\n  return { message: "hello!" };\n}\n')),(0,r.kt)("p",null,"The first argument to a handler function must be an ",(0,r.kt)("a",{parentName:"p",href:"/api-reference/contexts#operoncontext"},(0,r.kt)("inlineCode",{parentName:"a"},"OperonContext")),", but may more specifically be a ",(0,r.kt)("a",{parentName:"p",href:"/api-reference/contexts#handlercontext"},(0,r.kt)("inlineCode",{parentName:"a"},"HandlerContext")),", which contains more details about the incoming request, and provides the ability to invoke workflows and transactions."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@GetApi")," decorator can be combined with ",(0,r.kt)("inlineCode",{parentName:"p"},"@OperonTransaction")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"@OperonWorkflow")," to invoke transactions and workflows."),(0,r.kt)("p",null,"Endpoints path may have placeholders, which are parts of the URL mapped to function arguments.\nThese are represented by a section of the path prefixed with a ",(0,r.kt)("inlineCode",{parentName:"p"},":"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'@GetApi("/post/:id")\nstatic async getPost(ctx: TransactionContext, id: string) {\n  ...\n}\n')),(0,r.kt)("h4",{id:"postapi"},(0,r.kt)("inlineCode",{parentName:"h4"},"@PostApi")),(0,r.kt)("p",null,"Associates a function with an endpoint name, such as an HTTP URL accessed with POST."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'@PostApi("/testpost")\n  static async testpost(_ctx: HandlerContext, name: string) {\n  return `hello ${name}`;\n}\n')),(0,r.kt)("p",null,"The first argument to a handler function must be an ",(0,r.kt)("a",{parentName:"p",href:"/api-reference/contexts#operoncontext"},(0,r.kt)("inlineCode",{parentName:"a"},"OperonContext")),", but may more specifically be a ",(0,r.kt)("a",{parentName:"p",href:"/api-reference/contexts#handlercontext"},(0,r.kt)("inlineCode",{parentName:"a"},"HandlerContext")),", which contains more details about the incoming request, and provides the ability to invoke workflows and transactions."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@PostApi")," decorator can be combined with ",(0,r.kt)("inlineCode",{parentName:"p"},"@OperonTransaction")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"@OperonWorkflow")," to invoke transactions and workflows."),(0,r.kt)("h4",{id:"argsource"},(0,r.kt)("inlineCode",{parentName:"h4"},"@ArgSource")),(0,r.kt)("p",null,"Indicates where a function argument is to be sourced, when it could come from more than one place."),(0,r.kt)("p",null,"In the example below, ",(0,r.kt)("inlineCode",{parentName:"p"},"@ArgSource")," is used to indicate that the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," argument comes from the URL query string, rather than the posted message body."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'@PostApi("/workflow")\n@OperonWorkflow()\nstatic async testWorkflow(wfCtxt: WorkflowContext, @ArgSource(ArgSources.QUERY) name: string) {\n  const res = await wfCtxt.invoke(TestEndpoints).testTranscation(name);\n  return res;\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@ArgSource")," decorator takes one of the following values of ",(0,r.kt)("inlineCode",{parentName:"p"},"ArgSources"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DEFAULT"),": The default value. For GET requests, this means searching for query parameters; for POST requestsn, searching the request body."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"BODY"),": Indicates to search the parameter in the request body."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"QUERY"),": Indicates to search the parameter in the URL query string."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"URL"),": Indicates to search the parameter in the endpoint path (requires a path placeholder).")),(0,r.kt)("p",null,"Arguments sourced from an HTTP request generally get the name given in the code for the function.  However, if the name in the HTTP query string or body is different, ",(0,r.kt)("a",{parentName:"p",href:"#argname"},(0,r.kt)("inlineCode",{parentName:"a"},"@ArgName"))," may be used."),(0,r.kt)("h4",{id:"authentication"},(0,r.kt)("inlineCode",{parentName:"h4"},"@Authentication")),(0,r.kt)("p",null,"Configures the Operon HTTP server to perform authentication. All functions in the decorated class will use the provided function to act as an authentication middleware.\nThis middleware will make users' identity available to ",(0,r.kt)("a",{parentName:"p",href:"./contexts"},"Operon Contexts"),". Here is an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"async function exampleAuthMiddlware (ctx: MiddlewareContext) {\n  if (ctx.requiredRole.length > 0) {\n    const { userid } = ctx.koaContext.request.query;\n    const uid = userid?.toString();\n\n    if (!uid || uid.length === 0) {\n      const err = new OperonNotAuthorizedError(\"Not logged in.\", 401);\n      throw err;\n    }\n    else {\n      if (uid === 'bad_person') {\n        throw new OperonNotAuthorizedError(\"Go away.\", 401);\n      }\n      return {\n        authenticatedUser: uid,\n        authenticatedRoles: (uid === 'a_real_user' ? ['user'] : ['other'])\n      };\n    }\n  }\n}\n\n@Authentication(exampleAuthMiddlware)\nclass OperationEndpoints {\n  @GetApi(\"/requireduser\")\n  @RequiredRole(['user'])\n  static async checkAuth(ctxt: HandlerContext) {\n    return `Please say hello to ${ctxt.authenticatedUser}`;\n  }\n}\n")),(0,r.kt)("p",null,"The interface for the authentication middleware is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * Authentication middleware executing before requests reach functions.\n * Can implement arbitrary authentication and authorization logic.\n * Should throw an error or return an instance of `OperonHttpAuthReturn`\n */\nexport type OperonHttpAuthMiddleware = (ctx: MiddlewareContext) => Promise<OperonHttpAuthReturn | void>;\n\nexport interface OperonHttpAuthReturn {\n  authenticatedUser: string;\n  authenticatedRoles: string[];\n}\n\nexport interface MiddlewareContext {\n  koaContext: Koa.Context;\n  name: string;             // Function (handler, transaction, workflow) name\n  requiredRole: string[];   // Role required for the invoked Operon operation, if empty perhaps auth is not required\n}\n")),(0,r.kt)("h4",{id:"koamiddleware"},(0,r.kt)("inlineCode",{parentName:"h4"},"@KoaMiddleware")),(0,r.kt)("p",null,"Configures the Operon HTTP server allow insertion of arbitrary Koa middlewares. All functions in the decorated class will use the provided middleware list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const exampleMiddleware: Koa.Middleware = async (ctx, next) => {\n  await next();\n};\n\n@KoaMiddleware(exampleMiddleware)\nclass OperationEndpoints{\n  ...\n}\n")),(0,r.kt)("h3",{id:"declarative-security-decorators"},"Declarative Security Decorators"),(0,r.kt)("p",null,"Operon supports declarative, role-based security. Functions can be decorated with a list of roles (as strings) and execution of the function is forbidden unless the authenticated user has at least one role in the list. A list of roles can also be provided as a class-level default with ",(0,r.kt)("inlineCode",{parentName:"p"},"@DefaultRequiredRole()"),", in which case it applies to any Operon function in the class. Functions can override the defaults with ",(0,r.kt)("inlineCode",{parentName:"p"},"@RequiredRole()"),"."),(0,r.kt)("h4",{id:"requiredrole"},(0,r.kt)("inlineCode",{parentName:"h4"},"@RequiredRole")),(0,r.kt)("p",null,"List the required roles for the decorated function. In order to execute the function, the authenticated user must have at least one role on the specified list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@RequiredRole(['user','guest'])\n@GetApi(\"/hello\")\nstatic async helloUser(_ctx: HandlerContext) {\n  return { message: \"hello registered user or guest!\" };\n}\n")),(0,r.kt)("h4",{id:"defaultrequiredrole"},(0,r.kt)("inlineCode",{parentName:"h4"},"@DefaultRequiredRole")),(0,r.kt)("p",null,"List default required roles for all Operon functions in the class. This can be overridden at the function level with ",(0,r.kt)("inlineCode",{parentName:"p"},"@RequiredRole"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'@DefaultRequiredRole([\'user\'])\nclass OperationEndpoints {\n\n  // Authentication / authorization not required for this function\n  @RequiredRole([])\n  @GetApi("/hello")\n  static async hello(_ctx: HandlerContext) {\n    return { message: "hello!" };\n  }\n\n  // Role with elevated permissions required for this function\n  @RequiredRole([\'admin\'])\n  @GetApi("/helloadmin")\n  static async helloadmin(_ctx: HandlerContext) {\n    return { message: "hello admin!" };\n  }\n}\n')),(0,r.kt)("h3",{id:"input-validation-decorators"},"Input Validation Decorators"),(0,r.kt)("p",null,"A combination of Operon function and parameter decorators automatically provides rudimentary argument validation."),(0,r.kt)("p",null,"While the typescript compiler does some compile-time checks, it is possible (and likely) for programmers to pass user input directly through their code through the ",(0,r.kt)("inlineCode",{parentName:"p"},"any")," type or a series of poorly-validated casts.  The Operon function argument validation logic is able to check arguments exist and are of the right data types (or are close enough to be coerced through reasonable means)."),(0,r.kt)("p",null,"Note that this validation is basic, and is not a substitute for the kind of input validation that conforms to your business logic.  For example, a policy that user passwords should be 8 characters, and contain at least an uppercase, lowercase, and numeric character should be implemented in the web UI (for immediate feedback) and double-checked in your backend code (for security), whereas the Operon decorators will simply ensure that a password string was provided prior to function entry."),(0,r.kt)("p",null,"These decorators also serve a second purpose, which is to make the type information available to Operon.  Uses of this include creating a per-function schema for tracing logs, or automatically producing a description of the function for integration purposes."),(0,r.kt)("p",null,"In simple cases (such as ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"number")," arguments), the programmer need not do any decorating to get the functionality.  However, where the data types have some options, such as maximum length, precision, etc., there are decorators to control the behavior."),(0,r.kt)("h4",{id:"argrequired"},(0,r.kt)("inlineCode",{parentName:"h4"},"@ArgRequired")),(0,r.kt)("p",null,"Ensures that the decorated function argument has a suitable value.  This is generally a default behavior, but see ",(0,r.kt)("a",{parentName:"p",href:"#defaultargrequired"},(0,r.kt)("inlineCode",{parentName:"a"},"@DefaultArgRequired"))," and ",(0,r.kt)("a",{parentName:"p",href:"#defaultargoptional"},(0,r.kt)("inlineCode",{parentName:"a"},"@DefaultArgOptional")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'@GetApi("/string")\nstatic async checkStringG(_ctx: HandlerContext, @ArgRequired v: string) {\n  ...\n}\n')),(0,r.kt)("h4",{id:"defaultargrequired"},(0,r.kt)("inlineCode",{parentName:"h4"},"@DefaultArgRequired")),(0,r.kt)("p",null,"Sets as the default policy that each argument of each registered function in the decorated class has a suitable value.  This is generally a default behavior, but see ",(0,r.kt)("a",{parentName:"p",href:"#argrequired"},(0,r.kt)("inlineCode",{parentName:"a"},"@ArgRequired")),", ",(0,r.kt)("a",{parentName:"p",href:"#argoptional"},(0,r.kt)("inlineCode",{parentName:"a"},"@ArgOptional"))," and ",(0,r.kt)("a",{parentName:"p",href:"#defaultargoptional"},(0,r.kt)("inlineCode",{parentName:"a"},"@DefaultArgOptional")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@DefaultArgRequired\nexport class User {}\n")),(0,r.kt)("h4",{id:"argoptional"},(0,r.kt)("inlineCode",{parentName:"h4"},"@ArgOptional")),(0,r.kt)("p",null,"Allows the argument to have an undefined value.  See also ",(0,r.kt)("a",{parentName:"p",href:"#defaultargrequired"},(0,r.kt)("inlineCode",{parentName:"a"},"@DefaultArgRequired"))," and ",(0,r.kt)("a",{parentName:"p",href:"#defaultargoptional"},(0,r.kt)("inlineCode",{parentName:"a"},"@DefaultArgOptional")),"."),(0,r.kt)("admonition",{title:"note",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"TypeScript/Javascript makes a distinction between ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),".  Databases and serializers often support only one way to represent an undefined/unknown value.  For this reason, Operon converts all ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," values to ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," prior to entry to the user function.  (",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," was chosen over ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," because it is much easier to work with in TypeScript.)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'@GetApi("/string")\nstatic async checkStringG(_ctx: HandlerContext, @ArgOptional v?: string) {\n  ...\n}\n')),(0,r.kt)("h4",{id:"defaultargoptional"},(0,r.kt)("inlineCode",{parentName:"h4"},"@DefaultArgOptional")),(0,r.kt)("p",null,"Sets as the default policy that each argument of each registered function in the decorated class may have undefined value.  See also ",(0,r.kt)("a",{parentName:"p",href:"#argrequired"},(0,r.kt)("inlineCode",{parentName:"a"},"@ArgRequired")),", ",(0,r.kt)("a",{parentName:"p",href:"#argoptional"},(0,r.kt)("inlineCode",{parentName:"a"},"@ArgOptional"))," and ",(0,r.kt)("a",{parentName:"p",href:"#defaultargrequired"},(0,r.kt)("inlineCode",{parentName:"a"},"@DefaultArgRequired")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@DefaultArgOptional\nexport class User {}\n")),(0,r.kt)("h4",{id:"argname"},(0,r.kt)("inlineCode",{parentName:"h4"},"@ArgName")),(0,r.kt)("p",null,"Assigns a name to the decorated parameter.  The name of an argument is, by default, taken from the code, but if there is a reason for a disparity (perhaps the function was refactored but the external name used in HTTP requests is to be kept consistent), the name can be overriden with this parameter decorator."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@GetApi(\"/string\")\nstatic async checkStringG(_ctx: HandlerContext, @ArgName('call_me_maybe') internal_name: string) {\n  ...\n}\n")),(0,r.kt)("h4",{id:"argdate"},(0,r.kt)("inlineCode",{parentName:"h4"},"@ArgDate")),(0,r.kt)("p",null,"Ensures that a Date argument has a suitable value.  This decorator currently accepts no configuration, but may be altered in the future to indicate whether it is a timestamp or plain date."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'@GetApi("/date")\nstatic async checkDateG(_ctx: HandlerContext, @ArgDate() v: Date) {\n  ...\n}\n')),(0,r.kt)("h4",{id:"argvarchar"},(0,r.kt)("inlineCode",{parentName:"h4"},"@ArgVarchar")),(0,r.kt)("p",null,"Ensures that a string argument has a suitable length.  This decorator requires a length parameter."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'@GetApi("/string")\nstatic async checkStringG(_ctx: HandlerContext, @ArgVarchar(10) v: string) {\n  ...\n}\n')),(0,r.kt)("h3",{id:"logging-and-tracing-decorators"},"Logging and Tracing Decorators"),(0,r.kt)("h4",{id:"debug"},(0,r.kt)("inlineCode",{parentName:"h4"},"@Debug")),(0,r.kt)("p",null,"Marks a function for debug tracing."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export class Operations\n{\n  @Debug\n  static async doOperation(_ctx: OperonContext) {\n    ...\n  }\n}\n")),(0,r.kt)("p",null,"This decorator will ensure the function is registered with Operon and benefit from its ",(0,r.kt)("a",{parentName:"p",href:"../tutorials/logging#tracing"},"tracing subsystem"),"."),(0,r.kt)("admonition",{title:"note",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"In the future, a different decorator may be suggested for the purpose of simply registering an Operon function, with separate control over which functions are traced.")),(0,r.kt)("h4",{id:"skiplogging"},(0,r.kt)("inlineCode",{parentName:"h4"},"@SkipLogging")),(0,r.kt)("p",null,"Prevents a function argument from being recorded in traces. This could be used if the argument is an opaque object, context, connection, service, or of sensitive nature. See also ",(0,r.kt)("a",{parentName:"p",href:"#logmask"},(0,r.kt)("inlineCode",{parentName:"a"},"@LogMask")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export class Operations\n{\n  @Debug\n  static async doOperation(_ctx: OperonContext, @SkipLogging notToBeRecorded: unknown) {\n    ...\n  }\n}\n")),(0,r.kt)("h4",{id:"logmask"},(0,r.kt)("inlineCode",{parentName:"h4"},"@LogMask")),(0,r.kt)("p",null,"Prevents an argument from being recorded in traces in plain text. This could be used if the argument is sensitive in nature, but may be useful for debugging or tracing. See also ",(0,r.kt)("a",{parentName:"p",href:"#skiplogging"},(0,r.kt)("inlineCode",{parentName:"a"},"@SkipLogging")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export class Operations\n{\n  @Debug\n  static async doOperation(_ctx: OperonContext, @LogMask(LogMasks.HASH) toBeHashed: string) {\n    ...\n  }\n}\n")),(0,r.kt)("p",null,"Values of ",(0,r.kt)("inlineCode",{parentName:"p"},"LogMasks"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"NONE"),": No masking."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HASH"),": When logging the value, substitute its (not cryptographically secure) hash."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SKIP"),": Do not include the parameter in the log.  See ",(0,r.kt)("a",{parentName:"li",href:"#skiplogging"},(0,r.kt)("inlineCode",{parentName:"a"},"@SkipLogging")),".")),(0,r.kt)("h3",{id:"other-decorators"},"Other Decorators"),(0,r.kt)("h4",{id:"typeorm-decorators"},"TypeORM Decorators"),(0,r.kt)("h5",{id:"ormentities"},(0,r.kt)("inlineCode",{parentName:"h5"},"@OrmEntities")),(0,r.kt)("p",null,"Marks a class as using ORM entity classes.   (Currently this is used for ",(0,r.kt)("a",{parentName:"p",href:"https://typeorm.io"},"TypeORM")," integration only.)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@OrmEntities([OrmEntity1, OrmEntity2])\nexport class User {}\n")),(0,r.kt)("p",null,"This code will ensure that the TypeORM entity manager and repository knows about the entities in the list."))}u.isMDXComponent=!0}}]);