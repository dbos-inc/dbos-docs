"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[516],{130:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"typescript/reference/methods","title":"DBOS Methods & Variables","description":"DBOS Methods","source":"@site/docs/typescript/reference/methods.md","sourceDirName":"typescript/reference","slug":"/typescript/reference/methods","permalink":"/typescript/reference/methods","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":30,"frontMatter":{"sidebar_position":30,"title":"DBOS Methods & Variables"},"sidebar":"tutorialSidebar","previous":{"title":"Workflows & Steps","permalink":"/typescript/reference/workflows-steps"},"next":{"title":"Queues","permalink":"/typescript/reference/queues"}}');var t=s(4848),o=s(8453);const i={sidebar_position:30,title:"DBOS Methods & Variables"},l=void 0,d={},a=[{value:"DBOS Methods",id:"dbos-methods",level:2},{value:"DBOS.startWorkflow",id:"dbosstartworkflow",level:3},{value:"DBOS.send",id:"dbossend",level:3},{value:"DBOS.recv",id:"dbosrecv",level:3},{value:"DBOS.setEvent",id:"dbossetevent",level:3},{value:"DBOS.getEvent",id:"dbosgetevent",level:3},{value:"DBOS.sleep",id:"dbossleep",level:3},{value:"DBOS.now",id:"dbosnow",level:3},{value:"DBOS.randomUUID",id:"dbosrandomuuid",level:3},{value:"DBOS.writeStream",id:"dboswritestream",level:3},{value:"DBOS.closeStream",id:"dbosclosestream",level:3},{value:"DBOS.readStream",id:"dbosreadstream",level:3},{value:"DBOS.retrieveWorkflow",id:"dbosretrieveworkflow",level:3},{value:"Workflow Management Methods",id:"workflow-management-methods",level:2},{value:"DBOS.listWorkflows",id:"dboslistworkflows",level:3},{value:"DBOS.listQueuedWorkflows",id:"dboslistqueuedworkflows",level:3},{value:"DBOS.listWorkflowSteps",id:"dboslistworkflowsteps",level:3},{value:"DBOS.cancelWorkflow",id:"dboscancelworkflow",level:3},{value:"DBOS.resumeWorkflow",id:"dbosresumeworkflow",level:3},{value:"DBOS.forkWorkflow",id:"dbosforkworkflow",level:3},{value:"Workflow Status",id:"workflow-status",level:3},{value:"Debouncing",id:"debouncing",level:2},{value:"Debouncer",id:"debouncer",level:3},{value:"debouncer.debounce",id:"debouncerdebounce",level:3},{value:"DBOS Variables",id:"dbos-variables",level:2},{value:"DBOS.logger",id:"dboslogger",level:3},{value:"DBOS.workflowID",id:"dbosworkflowid",level:3},{value:"DBOS.isInStep()",id:"dbosisinstep",level:3},{value:"DBOS.stepID",id:"dbosstepid",level:3},{value:"DBOS.stepStatus",id:"dbosstepstatus",level:3},{value:"DBOS.isInTransaction()",id:"dbosisintransaction",level:3},{value:"DBOS.span",id:"dbosspan",level:3},{value:"DBOS.applicationVersion",id:"dbosapplicationversion",level:3},{value:"Workflow Handles",id:"workflow-handles",level:2},{value:"handle.workflowID",id:"handleworkflowid",level:3},{value:"handle.getResult",id:"handlegetresult",level:3},{value:"handle.getStatus",id:"handlegetstatus",level:3}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"dbos-methods",children:"DBOS Methods"}),"\n",(0,t.jsx)(n.h3,{id:"dbosstartworkflow",children:"DBOS.startWorkflow"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"static startWorkflow<Args extends unknown[], Return>(\n  target: (...args: Args) => Promise<Return>,\n  params?: StartWorkflowParams,\n): (...args: Args) => Promise<WorkflowHandle<Return>>;\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface StartWorkflowParams {\n  workflowID?: string;\n  queueName?: string;\n  timeoutMS?: number | null;\n  enqueueOptions?: EnqueueOptions;\n}\n\nexport interface EnqueueOptions {\n  deduplicationID?: string;\n  priority?: number;\n  queuePartitionKey?: string;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Start a workflow in the background and return a ",(0,t.jsx)(n.a,{href:"#workflow-handles",children:"handle"})," to it.\nOptionally enqueue it on a DBOS queue.\nThe ",(0,t.jsx)(n.code,{children:"DBOS.startWorkflow"})," method resolves after the workflow is durably started; at this point the workflow is guaranteed to run to completion even if the app is interrupted."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example syntax:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"async function example(input: number) {\n    // Call steps\n}\nconst exampleWorkflow = DBOS.registerWorkflow(example);\n\nconst input = 10;\nconst handle = await DBOS.startWorkflow(exampleWorkflow)(input);\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or if using decorators:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export class Example {\n  @DBOS.workflow()\n  static async exampleWorkflow(input: number) {\n    // Call steps\n  }\n}\n\nconst input = 10;\nconst handle = await DBOS.startWorkflow(Example).exampleWorkflow(input);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"target"}),": The workflow to start."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"workflowID"}),": An ID to assign to the workflow. If not specified, a random UUID is generated."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"queueName"}),": The name of the queue on which to enqueue this workflow, if any."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"timeoutMS"}),": The timeout of this workflow in milliseconds."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"enqueueOptions"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"deduplicationID"}),": At any given time, only one workflow with a specific deduplication ID can be enqueued in the specified queue. If a workflow with a deduplication ID is currently enqueued or actively executing (status ",(0,t.jsx)(n.code,{children:"ENQUEUED"})," or ",(0,t.jsx)(n.code,{children:"PENDING"}),"), subsequent workflow enqueue attempt with the same deduplication ID in the same queue will raise a ",(0,t.jsx)(n.code,{children:"DBOSQueueDuplicatedError"})," exception."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"priority"}),": The priority of the enqueued workflow in the specified queue. Workflows with the same priority are dequeued in ",(0,t.jsx)(n.strong,{children:"FIFO (first in, first out)"})," order. Priority values can range from ",(0,t.jsx)(n.code,{children:"1"})," to ",(0,t.jsx)(n.code,{children:"2,147,483,647"}),", where ",(0,t.jsx)(n.strong,{children:"a low number indicates a higher priority"}),". Workflows without assigned priorities have the highest priority and are dequeued before workflows with assigned priorities."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"queuePartitionKey"}),": The queue partition in which to enqueue this workflow. Use if and only if the queue is partitioned (",(0,t.jsx)(n.code,{children:"partitionQueue: true"}),"). In partitioned queues, all flow control (including concurrency and rate limits) is applied to individual partitions instead of the queue as a whole."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"dbossend",children:"DBOS.send"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.send<T>(\n  destinationID: string, \n  message: T, \n  topic?: string, \n  idempotencyKey?: string\n): Promise<void>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Send a message to the workflow identified by ",(0,t.jsx)(n.code,{children:"destinationID"}),".\nMessages can optionally be associated with a topic."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"destinationID"}),": The workflow to which to send the message."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"message"}),": The message to send. Must be serializable."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"topic"}),": A topic with which to associate the message. Messages are enqueued per-topic on the receiver."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"idempotencyKey"}),": If ",(0,t.jsx)(n.code,{children:"DBOS.send"})," is called from outside a workflow and an idempotency key is set, the message will only be sent once no matter how many times ",(0,t.jsx)(n.code,{children:"DBOS.send"})," is called with this key."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"dbosrecv",children:"DBOS.recv"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"recv<T>(\n  topic?: string,\n  timeoutSeconds?: number\n): Promise<T | null>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Receive and return a message sent to this workflow.\nCan only be called from within a workflow.\nMessages are dequeued first-in, first-out from a queue associated with the topic.\nCalls to ",(0,t.jsx)(n.code,{children:"recv"})," wait for the next message in the queue, returning ",(0,t.jsx)(n.code,{children:"null"})," if the wait times out.\nIf no topic is specified, ",(0,t.jsx)(n.code,{children:"recv"})," can only access messages sent without a topic."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"topic"}),": A topic queue on which to wait."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"timeoutSeconds"}),": A timeout in seconds. If the wait times out, return ",(0,t.jsx)(n.code,{children:"null"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The first message enqueued on the input topic, or ",(0,t.jsx)(n.code,{children:"null"})," if the wait times out."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"dbossetevent",children:"DBOS.setEvent"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.setEvent<T>(\n  key: string,\n  value: T\n): Promise<void>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Create and associate with this workflow an event with key ",(0,t.jsx)(n.code,{children:"key"})," and value ",(0,t.jsx)(n.code,{children:"value"}),".\nIf the event already exists, update its value.\nCan only be called from within a workflow."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"key"}),": The key of the event."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"value"}),": The value of the event. Must be serializable."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"dbosgetevent",children:"DBOS.getEvent"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.getEvent<T>(\n  workflowID: string,\n  key: string,\n  timeoutSeconds?: number\n): Promise<T | null>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Retrieve the latest value of an event published by the workflow identified by ",(0,t.jsx)(n.code,{children:"workflowID"})," to the key ",(0,t.jsx)(n.code,{children:"key"}),".\nIf the event does not yet exist, wait for it to be published, returning ",(0,t.jsx)(n.code,{children:"null"})," if the wait times out."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"workflowID"}),": The identifier of the workflow whose events to retrieve."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"key"}),": The key of the event to retrieve."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"timeoutSeconds"}),": A timeout in seconds. If the wait times out, return ",(0,t.jsx)(n.code,{children:"null"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"dbossleep",children:"DBOS.sleep"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.sleep(\n    durationMS: number,\n): Promise<void>;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Sleep for the given number of milliseconds.\nMay only be called from within a workflow.\nThis sleep is durable\u2014it records its intended wake-up time in the database so if it is interrupted and recovers, it still wakes up at the intended time."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"durationMS"}),": The number of milliseconds to sleep."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"dbosnow",children:"DBOS.now"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.now(): Promise<number>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns the current time, in the manner of ",(0,t.jsx)(n.code,{children:"Date.now()"}),", checkpointed as a step."]}),"\n",(0,t.jsx)(n.h3,{id:"dbosrandomuuid",children:"DBOS.randomUUID"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.randomUUID(): Promise<string>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns a random UUID, in the manner of ",(0,t.jsx)(n.code,{children:"node:crypto"}),", checkpointed as a step."]}),"\n",(0,t.jsx)(n.h3,{id:"dboswritestream",children:"DBOS.writeStream"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.writeStream<T>(\n  key: string, \n  value: T\n): Promise<void>\n"})}),"\n",(0,t.jsx)(n.p,{children:"Write a value to a stream.\nA workflow may have any number of streams, each identified by a unique key.\nCan only be called from within a workflow or step."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"key"}),": The stream key/name within the workflow."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"value"}),": A serializable value to write to the stream."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"dbosclosestream",children:"DBOS.closeStream"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.closeStream(\n  key: string\n): Promise<void>\n"})}),"\n",(0,t.jsx)(n.p,{children:"Close a stream identified by a key.\nAfter this is called, no more values can be written to the stream.\nCan only be called from within a workflow."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"key"}),": The stream key/name within the workflow."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"dbosreadstream",children:"DBOS.readStream"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.readStream<T>(\n  workflowID: string, \n  key: string\n): AsyncGenerator<T, void, unknown>\n"})}),"\n",(0,t.jsx)(n.p,{children:"Read values from a stream as an async generator.\nThis function reads values from a stream identified by the workflowID and key,\nyielding each value in order until the stream is closed or the workflow terminates."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"workflowID"}),": The workflow instance ID that owns the stream."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"key"}),": The stream key/name within the workflow."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"An async generator that yields each value in the stream until the stream is closed."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example syntax:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'for await (const value of DBOS.readStream(workflowID, "example_key")) {\n  console.log(`Received: ${JSON.stringify(value)}`);\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"dbosretrieveworkflow",children:"DBOS.retrieveWorkflow"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.retrieveWorkflow<T>(\n  workflowID: string,\n): WorkflowHandle<Awaited<T>> \n"})}),"\n",(0,t.jsxs)(n.p,{children:["Retrieve the ",(0,t.jsx)(n.a,{href:"#workflow-handles",children:"handle"})," of a workflow."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"workflowID"}),": The ID of the workflow whose handle to retrieve."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"workflow-management-methods",children:"Workflow Management Methods"}),"\n",(0,t.jsx)(n.h3,{id:"dboslistworkflows",children:"DBOS.listWorkflows"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.listWorkflows(\n  input: GetWorkflowsInput\n): Promise<WorkflowStatus[]>\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface GetWorkflowsInput {\n  workflowIDs?: string[];\n  workflowName?: string;\n  status?: string;\n  startTime?: string;\n  endTime?: string;\n  applicationVersion?: string;\n  authenticatedUser?: string;\n  limit?: number;\n  offset?: number;\n  sortDesc?: boolean;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Retrieve a list of ",(0,t.jsx)(n.a,{href:"#workflow-status",children:(0,t.jsx)(n.code,{children:"WorkflowStatus"})})," of all workflows matching specified criteria."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"workflowIDs"}),": Retrieve workflows with these IDs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"workflowName"}),": Retrieve workflows with this name."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"status"}),": Retrieve workflows with this status (Must be ",(0,t.jsx)(n.code,{children:"ENQUEUED"}),", ",(0,t.jsx)(n.code,{children:"PENDING"}),", ",(0,t.jsx)(n.code,{children:"SUCCESS"}),", ",(0,t.jsx)(n.code,{children:"ERROR"}),", ",(0,t.jsx)(n.code,{children:"CANCELLED"}),", or ",(0,t.jsx)(n.code,{children:"RETRIES_EXCEEDED"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"startTime"}),": Retrieve workflows started after this (RFC 3339-compliant) timestamp."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"endTime"}),": Retrieve workflows started before this (RFC 3339-compliant) timestamp."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"applicationVersion"}),": Retrieve workflows tagged with this application version."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"authenticatedUser"}),": Retrieve workflows run by this authenticated user."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"limit"}),": Retrieve up to this many workflows."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"offset"}),": Skip this many workflows from the results returned (for pagination)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"sortDesc"}),": Whether to sort the results in descending (",(0,t.jsx)(n.code,{children:"True"}),") or ascending (",(0,t.jsx)(n.code,{children:"False"}),") order by workflow start time."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"dboslistqueuedworkflows",children:"DBOS.listQueuedWorkflows"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.listQueuedWorkflows(\n  input: GetQueuedWorkflowsInput\n): Promise<WorkflowStatus[]>\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface GetQueuedWorkflowsInput {\n  workflowName?: string;\n  status?: string;\n  queueName?: number;\n  startTime?: string;\n  endTime?: string;\n  limit?: number;\n  offset?: number;\n  sortDesc?: boolean;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Retrieve a list of ",(0,t.jsx)(n.a,{href:"#workflow-status",children:(0,t.jsx)(n.code,{children:"WorkflowStatus"})})," of all ",(0,t.jsx)(n.strong,{children:"currently enqueued"})," workflows matching specified criteria."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"workflowName"}),": Retrieve workflows with this name."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"status"}),": Retrieve workflows with this status (Must be ",(0,t.jsx)(n.code,{children:"ENQUEUED"}),", ",(0,t.jsx)(n.code,{children:"PENDING"}),", ",(0,t.jsx)(n.code,{children:"SUCCESS"}),", ",(0,t.jsx)(n.code,{children:"ERROR"}),", ",(0,t.jsx)(n.code,{children:"CANCELLED"}),", or ",(0,t.jsx)(n.code,{children:"RETRIES_EXCEEDED"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"queueName"}),": Retrieve workflows running on this queue."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"startTime"}),": Retrieve workflows started after this (RFC 3339-compliant) timestamp."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"endTime"}),": Retrieve workflows started before this (RFC 3339-compliant) timestamp."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"limit"}),": Retrieve up to this many workflows."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"offset"}),": Skip this many workflows from the results returned (for pagination)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"sortDesc"}),": Whether to sort the results in descending (",(0,t.jsx)(n.code,{children:"True"}),") or ascending (",(0,t.jsx)(n.code,{children:"False"}),") order by workflow start time."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"dboslistworkflowsteps",children:"DBOS.listWorkflowSteps"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.listWorkflowSteps(\n  workflowID: string)\n: Promise<StepInfo[]>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Retrieve the steps of a workflow.\nThis is a list of ",(0,t.jsx)(n.code,{children:"StepInfo"})," objects, with the following structure:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface StepInfo {\n  // The unique ID of the step in the workflow. Zero-indexed.\n  readonly functionID: number;\n  // The name of the step\n  readonly name: string;\n  // The step's output, if any\n  readonly output: unknown;\n  // The error the step threw, if any\n  readonly error: Error | null;\n  // If the step starts or retrieves the result of a workflow, its ID\n  readonly childWorkflowID: string | null;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"dboscancelworkflow",children:"DBOS.cancelWorkflow"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"cancelWorkflow(\n  workflowID: string\n): Promise<void>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Cancel a workflow.\nThis sets is status to ",(0,t.jsx)(n.code,{children:"CANCELLED"}),", removes it from its queue (if it is enqueued) and preempts its execution (interrupting it at the beginning of its next step)"]}),"\n",(0,t.jsx)(n.h3,{id:"dbosresumeworkflow",children:"DBOS.resumeWorkflow"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.resumeWorkflow<T>(\n  workflowID: string\n): Promise<WorkflowHandle<Awaited<T>>> \n"})}),"\n",(0,t.jsx)(n.p,{children:"Resume a workflow.\nThis immediately starts it from its last completed step.\nYou can use this to resume workflows that are cancelled or have exceeded their maximum recovery attempts.\nYou can also use this to start an enqueued workflow immediately, bypassing its queue."}),"\n",(0,t.jsx)(n.h3,{id:"dbosforkworkflow",children:"DBOS.forkWorkflow"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"static async forkWorkflow<T>(\n  workflowID: string,\n  startStep: number,\n  options?: { newWorkflowID?: string; applicationVersion?: string; timeoutMS?: number },\n): Promise<WorkflowHandle<Awaited<T>>>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Start a new execution of a workflow from a specific step.\nThe input step ID (",(0,t.jsx)(n.code,{children:"startStep"}),") must match the ",(0,t.jsx)(n.code,{children:"functionID"})," of the step returned by ",(0,t.jsx)(n.code,{children:"listWorkflowSteps"}),".\nThe specified ",(0,t.jsx)(n.code,{children:"startStep"})," is the step from which the new workflow will start, so any steps whose ID is less than ",(0,t.jsx)(n.code,{children:"startStep"})," will not be re-executed."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"workflowID"}),": The ID of the workflow to fork."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"startStep"}),": The ID of the step from which to start the forked workflow. Must match the ",(0,t.jsx)(n.code,{children:"functionID"})," of the step in the original workflow execution."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"newWorkflowID"}),": The ID of the new workflow created by the fork. If not specified, a random UUID is used."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"applicationVersion"}),': The application version on which the forked workflow will run. Useful for "patching" workflows that failed due to a bug in the previous application version.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"timeoutMS"}),": A timeout for the forked workflow in milliseconds."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"workflow-status",children:"Workflow Status"}),"\n",(0,t.jsxs)(n.p,{children:["Some workflow introspection and management methods return a ",(0,t.jsx)(n.code,{children:"WorkflowStatus"}),".\nThis object has the following definition:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export interface WorkflowStatus {\n  // The workflow ID\n  readonly workflowID: string;\n  // The workflow status. Must be one of ENQUEUED, PENDING, SUCCESS, ERROR, CANCELLED, or RETRIES_EXCEEDED\n  readonly status: string;\n  // The name of the workflow function.\n  readonly workflowName: string;\n  // The name of the workflow's class, if any\n  readonly workflowClassName: string; // The class name holding the workflow function.\n  // The name with which the workflow's class instance was configured, if any.\n  readonly workflowConfigName?: string;\n  // If the workflow was enqueued, the name of the queue.\n  readonly queueName?: string;\n  // The workflow's output, if any.\n  readonly output?: unknown;\n  // The error thrown by the workflow, if any.\n  readonly error?: unknown;\n  // The deserialized workflow inputs.\n  readonly input?: unknown[];\n  // The ID of the executor (process) that most recently executed this workflow.\n  readonly executorId?: string;\n  // The application version on which this workflow started.\n  readonly applicationVersion?: string;\n  // The number of times this workflow has been started.\n  readonly recoveryAttempts?: number;\n  // Workflow start time, as a UNIX epoch timestamp in milliseconds\n  readonly createdAt: number;\n  // Last time the workflow status was updated, as a UNIX epoch timestamp in milliseconds. For a completed workflow, this is the workflow completion timestamp.\n  readonly updatedAt?: number;\n  // The timeout specified for this workflow, if any. Timeouts are start-to-close.\n  readonly timeoutMS?: number | null;\n  // The deadline at which this workflow times out, if any. Not set until the workflow begins execution.\n  readonly deadlineEpochMS?: number;\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"debouncing",children:"Debouncing"}),"\n",(0,t.jsxs)(n.p,{children:["You can create a ",(0,t.jsx)(n.code,{children:"Debouncer"})," to debounce your workflows.\nDebouncing delays workflow execution until some time has passed since the workflow has last been called.\nThis is useful for preventing wasted work when a workflow may be triggered multiple times in quick succession.\nFor example, if a user is editing an input field, you can debounce their changes to execute a processing workflow only after they haven't edited the field for some time:"]}),"\n",(0,t.jsx)(n.h3,{id:"debouncer",children:"Debouncer"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"new Debouncer<Args extends unknown[], Return>(\n  params: DebouncerConfig<Args, Return>\n)\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface DebouncerConfig<Args extends unknown[], Return> {\n  workflow: (...args: Args) => Promise<Return>;\n  startWorkflowParams?: StartWorkflowParams;\n  debounceTimeoutMs?: number;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"workflow"}),": The workflow to debounce. Note that workflows from ",(0,t.jsx)(n.a,{href:"/typescript/reference/workflows-steps#instance-method-workflows",children:"configured instances"})," cannot be debounced."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"startWorkflowParams"}),": Optional workflow parameters, as in ",(0,t.jsx)(n.a,{href:"#dbosstartworkflow",children:(0,t.jsx)(n.code,{children:"startWorkflow"})}),". Applied to all workflows started from this debouncer."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"debounceTimeoutMs"}),": After this time elapses since the first time a workflow is submitted from this debouncer, the workflow is started regardless of the debounce period."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"debouncerdebounce",children:"debouncer.debounce"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"debouncer.debounce(\n  debounceKey: string,\n  debouncePeriodMs: number,\n  ...args: Args\n): Promise<WorkflowHandle<Return>>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Submit a workflow for execution but delay it by ",(0,t.jsx)(n.code,{children:"debouncePeriodMs"}),".\nReturns a handle to the workflow.\nThe workflow may be debounced again, which further delays its execution (up to ",(0,t.jsx)(n.code,{children:"debounceTimeoutMs"}),").\nWhen the workflow eventually executes, it uses the ",(0,t.jsx)(n.strong,{children:"last"})," set of inputs passed into ",(0,t.jsx)(n.code,{children:"debounce"}),".\nAfter the workflow begins execution, the next call to ",(0,t.jsx)(n.code,{children:"debounce"})," starts the debouncing process again for a new workflow execution."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"debounceKey"}),": A key used to group workflow executions that will be debounced together. For example, if the debounce key is set to customer ID, each customer's workflows would be debounced separately."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"debouncePeriodMs"}),": Delay this workflow's execution by this period in milliseconds."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"...args"}),": Variadic workflow arguments."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example Syntax"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"async function processInput(userInput: string) {\n  ...\n}\nconst processInputWorkflow = DBOS.registerWorkflow(processInput);\n\n// Each time a user submits a new input, debounce the processInput workflow.\n// The workflow will wait until 60 seconds after the user stops submitting new inputs,\n// then process the last input submitted.\nconst debouncer = new Debouncer({\n  workflow: processInputWorkflow,\n});\n\nasync function onUserInputSubmit(userId: string, userInput: string) {\n  const debounceKey = userId;\n  const debouncePeriodMs = 60000; // 60 seconds\n  await debouncer.debounce(debounceKey, debouncePeriodMs, userInput);\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"dbos-variables",children:"DBOS Variables"}),"\n",(0,t.jsx)(n.h3,{id:"dboslogger",children:"DBOS.logger"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.logger: Logger;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Retrieve the DBOS logger.\nThis is a pre-configured Winston logger provided as a convenience.\nYou do not need to use it if you have your own logger."}),"\n",(0,t.jsx)(n.h3,{id:"dbosworkflowid",children:"DBOS.workflowID"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.workflowID: string | undefined;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Return the ID of the current workflow, if in a workflow."}),"\n",(0,t.jsx)(n.h3,{id:"dbosisinstep",children:"DBOS.isInStep()"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.isInStep(): boolean;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns true if called from within a step."}),"\n",(0,t.jsx)(n.h3,{id:"dbosstepid",children:"DBOS.stepID"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.stepID: string | undefined;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Return the unique ID of the current step within a workflow."}),"\n",(0,t.jsx)(n.h3,{id:"dbosstepstatus",children:"DBOS.stepStatus"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.stepStatus: StepStatus | undefined;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Return the status of the currently executing step.\nThis object has the following properties:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface StepStatus {\n  // The unique ID of this step in its workflow.\n  stepID: number;\n  // For steps with automatic retries, which attempt number (zero-indexed) is currently executing.\n  currentAttempt?: number;\n  // For steps with automatic retries, the maximum number of attempts that will be made before the step fails.\n  maxAttempts?: number;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"dbosisintransaction",children:"DBOS.isInTransaction()"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.isInTransaction(): boolean;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns true if called from within a datasource transaction."}),"\n",(0,t.jsx)(n.h3,{id:"dbosspan",children:"DBOS.span"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.span: Span | undefined\n"})}),"\n",(0,t.jsx)(n.p,{children:"Retrieve the OpenTelemetry span associated with the current workflow.\nYou can use this to set custom attributes in your span."}),"\n",(0,t.jsx)(n.h3,{id:"dbosapplicationversion",children:"DBOS.applicationVersion"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"DBOS.applicationVersion: string\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Return the current application version, as documented ",(0,t.jsx)(n.a,{href:"/typescript/tutorials/workflow-tutorial#workflow-versioning-and-recovery",children:"here"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"workflow-handles",children:"Workflow Handles"}),"\n",(0,t.jsxs)(n.p,{children:["A workflow handle represents the state of a particular active or completed workflow execution.\nYou obtain a workflow handle when using ",(0,t.jsx)(n.code,{children:"DBOS.startWorkflow"})," to start a workflow in the background.\nIf you know a workflow's identity, you can also retrieve its handle using ",(0,t.jsx)(n.code,{children:"DBOS.retrieveWorkflow"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Workflow handles have the following methods:"}),"\n",(0,t.jsx)(n.h3,{id:"handleworkflowid",children:"handle.workflowID"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"handle.workflowID(): string;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Retrieve the ID of the workflow."}),"\n",(0,t.jsx)(n.h3,{id:"handlegetresult",children:"handle.getResult"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"handle.getResult(): Promise<R>;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Wait for the workflow to complete, then return its result."}),"\n",(0,t.jsx)(n.h3,{id:"handlegetstatus",children:"handle.getStatus"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"handle.getStatus(): Promise<WorkflowStatus>;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Retrieve the ",(0,t.jsx)(n.a,{href:"#workflow-status",children:(0,t.jsx)(n.code,{children:"WorkflowStatus"})})," of the workflow."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>l});var r=s(6540);const t={},o=r.createContext(t);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);