"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[8837],{243:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"golang/reference/methods","title":"DBOS Methods & Variables","description":"Workflow Communication","source":"@site/docs/golang/reference/methods.md","sourceDirName":"golang/reference","slug":"/golang/reference/methods","permalink":"/golang/reference/methods","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":30,"frontMatter":{"sidebar_position":30,"title":"DBOS Methods & Variables","toc_max_heading_level":3},"sidebar":"tutorialSidebar","previous":{"title":"Workflows & Steps","permalink":"/golang/reference/workflows-steps"},"next":{"title":"Queues","permalink":"/golang/reference/queues"}}');var s=t(4848),o=t(8453);const i={sidebar_position:30,title:"DBOS Methods & Variables",toc_max_heading_level:3},l=void 0,a={},c=[{value:"Workflow Communication",id:"workflow-communication",level:2},{value:"GetEvent",id:"getevent",level:3},{value:"SetEvent",id:"setevent",level:3},{value:"Send",id:"send",level:3},{value:"Recv",id:"recv",level:3},{value:"Streams",id:"streams",level:2},{value:"WriteStream",id:"writestream",level:3},{value:"CloseStream",id:"closestream",level:3},{value:"ReadStream",id:"readstream",level:3},{value:"ReadStreamAsync",id:"readstreamasync",level:3},{value:"StreamValue",id:"streamvalue",level:3},{value:"Sleep",id:"sleep",level:2},{value:"Sleep",id:"sleep-1",level:3},{value:"Workflow Management Methods",id:"workflow-management-methods",level:2},{value:"RetrieveWorkflow",id:"retrieveworkflow",level:3},{value:"ListWorkflows",id:"listworkflows",level:3},{value:"WithAppVersion",id:"withappversion",level:4},{value:"WithEndTime",id:"withendtime",level:4},{value:"WithLimit",id:"withlimit",level:4},{value:"WithLoadInput",id:"withloadinput",level:4},{value:"WithLoadOutput",id:"withloadoutput",level:4},{value:"WithName",id:"withname",level:4},{value:"WithOffset",id:"withoffset",level:4},{value:"WithSortDesc",id:"withsortdesc",level:4},{value:"WithStartTime",id:"withstarttime",level:4},{value:"WithStatus",id:"withstatus",level:4},{value:"WithUser",id:"withuser",level:4},{value:"WithWorkflowIDs",id:"withworkflowids",level:4},{value:"WithWorkflowIDPrefix",id:"withworkflowidprefix",level:4},{value:"WithQueuesOnly",id:"withqueuesonly",level:4},{value:"GetWorkflowSteps",id:"getworkflowsteps",level:3},{value:"CancelWorkflow",id:"cancelworkflow",level:3},{value:"ResumeWorkflow",id:"resumeworkflow",level:3},{value:"ForkWorkflow",id:"forkworkflow",level:3},{value:"Workflow Status",id:"workflow-status",level:3},{value:"WorkflowStatusType",id:"workflowstatustype",level:4},{value:"DBOS Variables",id:"dbos-variables",level:2},{value:"GetWorkflowID",id:"getworkflowid",level:3},{value:"GetStepID",id:"getstepid",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"workflow-communication",children:"Workflow Communication"}),"\n",(0,s.jsx)(n.h3,{id:"getevent",children:"GetEvent"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func GetEvent[R any](ctx DBOSContext, targetWorkflowID, key string, timeout time.Duration) (R, error)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Retrieve the latest value of an event published by the workflow identified by ",(0,s.jsx)(n.code,{children:"targetWorkflowID"})," to the key ",(0,s.jsx)(n.code,{children:"key"}),".\nIf the event does not yet exist, wait for it to be published, returning an error if the wait times out."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"targetWorkflowID"}),": The identifier of the workflow whose events to retrieve."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"key"}),": The key of the event to retrieve."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"timeout"}),": A timeout. If the wait times out, return an error."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"setevent",children:"SetEvent"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func SetEvent[P any](ctx DBOSContext, key string, message P) error\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Create and associate with this workflow an event with key ",(0,s.jsx)(n.code,{children:"key"})," and value ",(0,s.jsx)(n.code,{children:"value"}),".\nIf the event already exists, update its value.\nCan only be called from within a workflow."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"key"}),": The key of the event."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"message"}),": The value of the event. Must be serializable."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"send",children:"Send"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func Send[P any](ctx DBOSContext, destinationID string, message P, topic string) error\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Send a message to the workflow identified by ",(0,s.jsx)(n.code,{children:"destinationID"}),".\nMessages can optionally be associated with a topic."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"destinationID"}),": The workflow to which to send the message."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"message"}),": The message to send. Must be serializable."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"topic"}),": A topic with which to associate the message. Messages are enqueued per-topic on the receiver."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"recv",children:"Recv"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func Recv[R any](ctx DBOSContext, topic string, timeout time.Duration) (R, error)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Receive and return a message sent to this workflow.\nCan only be called from within a workflow.\nMessages are dequeued first-in, first-out from a queue associated with the topic.\nCalls to ",(0,s.jsx)(n.code,{children:"recv"})," wait for the next message in the queue, returning an error if the wait times out."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"topic"}),": A topic queue on which to wait."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"timeoutSeconds"}),": A timeout in seconds. If the wait times out, return an error."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"streams",children:"Streams"}),"\n",(0,s.jsxs)(n.p,{children:["Workflows can stream data to clients in real time.\nStreams are durable, append-only, and ordered by offset.\nSee the ",(0,s.jsx)(n.a,{href:"/golang/tutorials/workflow-communication#workflow-streaming",children:"streaming tutorial"})," for usage examples."]}),"\n",(0,s.jsx)(n.h3,{id:"writestream",children:"WriteStream"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func WriteStream[P any](ctx DBOSContext, key string, value P) error\n"})}),"\n",(0,s.jsx)(n.p,{children:"Write a value to a durable stream.\nMay only be called from within a workflow or step.\nWrites from a workflow are exactly-once; writes from a step are at-least-once."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"key"}),": The stream key. A workflow can have multiple streams, each identified by a unique key."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"value"}),": The value to write. Must be serializable (json-encodable)."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"closestream",children:"CloseStream"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func CloseStream(ctx DBOSContext, key string) error\n"})}),"\n",(0,s.jsx)(n.p,{children:"Close a durable stream.\nMay only be called from within a workflow or step.\nAfter closing, no more values can be written to the stream.\nStreams are also automatically closed when the workflow terminates."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"key"}),": The stream key to close."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"readstream",children:"ReadStream"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func ReadStream[R any](ctx DBOSContext, workflowID string, key string) ([]R, bool, error)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Read all values from a durable stream.\nBlocks until the stream is closed or the workflow becomes inactive (status is not ",(0,s.jsx)(n.code,{children:"PENDING"})," or ",(0,s.jsx)(n.code,{children:"ENQUEUED"}),")."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"workflowID"}),": The ID of the workflow whose stream to read."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"key"}),": The stream key to read."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The values read from the stream."}),"\n",(0,s.jsx)(n.li,{children:"Whether the stream is closed."}),"\n",(0,s.jsx)(n.li,{children:"Any error that occurred."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"readstreamasync",children:"ReadStreamAsync"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func ReadStreamAsync[R any](ctx DBOSContext, workflowID string, key string) (<-chan StreamValue[R], error)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Read values from a durable stream asynchronously.\nReturns immediately with a channel that receives values as they are written to the stream.\nThe channel is closed when the stream is closed or an error occurs."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"workflowID"}),": The ID of the workflow whose stream to read."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"key"}),": The stream key to read."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A receive-only channel of ",(0,s.jsx)(n.a,{href:"#streamvalue",children:(0,s.jsx)(n.code,{children:"StreamValue[R]"})}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Any error that occurred during setup."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"streamvalue",children:"StreamValue"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"type StreamValue[R any] struct {\n    Value  R     // The stream value (zero value if error/closed)\n    Err    error // Error if one occurred (nil otherwise)\n    Closed bool  // Whether the stream is closed\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"StreamValue"})," holds a value, error, or closed status from an async stream read operation.\nWhen reading from the channel returned by ",(0,s.jsx)(n.code,{children:"ReadStreamAsync"}),", check ",(0,s.jsx)(n.code,{children:"Err"})," and ",(0,s.jsx)(n.code,{children:"Closed"})," before using ",(0,s.jsx)(n.code,{children:"Value"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"sleep",children:"Sleep"}),"\n",(0,s.jsx)(n.h3,{id:"sleep-1",children:"Sleep"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func Sleep(ctx DBOSContext, duration time.Duration) (time.Duration, error)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Sleep for the given duration.\nMay only be called from within a workflow.\nThis sleep is durable\u2014it records its intended wake-up time in the database so if it is interrupted and recovers, it still wakes up at the intended time."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"duration"}),": The duration to sleep."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"workflow-management-methods",children:"Workflow Management Methods"}),"\n",(0,s.jsx)(n.h3,{id:"retrieveworkflow",children:"RetrieveWorkflow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func RetrieveWorkflow[R any](ctx DBOSContext, workflowID string) (*workflowPollingHandle[R], error)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Retrieve the ",(0,s.jsx)(n.a,{href:"/golang/reference/workflows-steps#workflowhandle",children:"handle"})," of a workflow."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"workflowID"}),": The ID of the workflow whose handle to retrieve."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"listworkflows",children:"ListWorkflows"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func ListWorkflows(ctx DBOSContext, opts ...ListWorkflowsOption) ([]WorkflowStatus, error)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Retrieve a list of ",(0,s.jsx)(n.a,{href:"#workflow-status",children:(0,s.jsx)(n.code,{children:"WorkflowStatus"})})," of all workflows matching specified criteria."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// List all successful workflows from the last 24 hours\nworkflows, err := dbos.ListWorkflows(ctx,\n    dbos.WithStatus([]dbos.WorkflowStatusType{dbos.WorkflowStatusSuccess}),\n    dbos.WithStartTime(time.Now().Add(-24*time.Hour)),\n    dbos.WithLimit(100))\nif err != nil {\n    log.Fatal(err)\n}\n\n// List workflows by specific IDs without loading input/output data\nworkflows, err := dbos.ListWorkflows(ctx,\n    dbos.WithWorkflowIDs([]string{"workflow1", "workflow2"}),\n    dbos.WithLoadInput(false),\n    dbos.WithLoadOutput(false))\nif err != nil {\n    log.Fatal(err)\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"withappversion",children:"WithAppVersion"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func WithAppVersion(appVersion string) ListWorkflowsOption\n"})}),"\n",(0,s.jsx)(n.p,{children:"Retrieve workflows tagged with this application version."}),"\n",(0,s.jsx)(n.h4,{id:"withendtime",children:"WithEndTime"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func WithEndTime(endTime time.Time) ListWorkflowsOption\n"})}),"\n",(0,s.jsx)(n.p,{children:"Retrieve workflows started before this timestamp."}),"\n",(0,s.jsx)(n.h4,{id:"withlimit",children:"WithLimit"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func WithLimit(limit int) ListWorkflowsOption\n"})}),"\n",(0,s.jsx)(n.p,{children:"Retrieve up to this many workflows."}),"\n",(0,s.jsx)(n.h4,{id:"withloadinput",children:"WithLoadInput"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func WithLoadInput(loadInput bool) ListWorkflowsOption\n"})}),"\n",(0,s.jsx)(n.p,{children:"WithLoadInput controls whether to load workflow input data (default: true)."}),"\n",(0,s.jsx)(n.h4,{id:"withloadoutput",children:"WithLoadOutput"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func WithLoadOutput(loadOutput bool) ListWorkflowsOption\n"})}),"\n",(0,s.jsx)(n.p,{children:"WithLoadOutput controls whether to load workflow output data (default: true)."}),"\n",(0,s.jsx)(n.h4,{id:"withname",children:"WithName"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func WithName(name string) ListWorkflowsOption\n"})}),"\n",(0,s.jsx)(n.p,{children:"Filter workflows by the specified workflow function name."}),"\n",(0,s.jsx)(n.h4,{id:"withoffset",children:"WithOffset"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func WithOffset(offset int) ListWorkflowsOption\n"})}),"\n",(0,s.jsx)(n.p,{children:"Skip this many workflows from the results returned (for pagination)."}),"\n",(0,s.jsx)(n.h4,{id:"withsortdesc",children:"WithSortDesc"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func WithSortDesc(sortDesc bool) ListWorkflowsOption\n"})}),"\n",(0,s.jsx)(n.p,{children:"Sort the results in descending (true) or ascending (false) order by workflow start time."}),"\n",(0,s.jsx)(n.h4,{id:"withstarttime",children:"WithStartTime"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func WithStartTime(startTime time.Time) ListWorkflowsOption\n"})}),"\n",(0,s.jsx)(n.p,{children:"Retrieve workflows started after this timestamp."}),"\n",(0,s.jsx)(n.h4,{id:"withstatus",children:"WithStatus"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func WithStatus(status []WorkflowStatusType) ListWorkflowsOption\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Filter workflows by ",(0,s.jsx)(n.a,{href:"#workflowstatustype",children:"status"}),". Multiple statuses can be specified."]}),"\n",(0,s.jsx)(n.h4,{id:"withuser",children:"WithUser"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func WithUser(user string) ListWorkflowsOption\n"})}),"\n",(0,s.jsx)(n.p,{children:"Filter workflows run by this authenticated user."}),"\n",(0,s.jsx)(n.h4,{id:"withworkflowids",children:"WithWorkflowIDs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func WithWorkflowIDs(workflowIDs []string) ListWorkflowsOption\n"})}),"\n",(0,s.jsx)(n.p,{children:"Filter workflows by specific workflow IDs."}),"\n",(0,s.jsx)(n.h4,{id:"withworkflowidprefix",children:"WithWorkflowIDPrefix"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func WithWorkflowIDPrefix(prefix string) ListWorkflowsOption\n"})}),"\n",(0,s.jsx)(n.p,{children:"Filter workflows whose IDs start with the specified prefix."}),"\n",(0,s.jsx)(n.h4,{id:"withqueuesonly",children:"WithQueuesOnly"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func WithQueuesOnly() ListWorkflowsOption\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Return only workflows that are currently in a queue (queue name is not null, status is ",(0,s.jsx)(n.code,{children:"ENQUEUED"})," or ",(0,s.jsx)(n.code,{children:"PENDING"}),")."]}),"\n",(0,s.jsx)(n.h3,{id:"getworkflowsteps",children:"GetWorkflowSteps"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func GetWorkflowSteps(ctx DBOSContext, workflowID string) ([]StepInfo, error)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["GetWorkflowSteps retrieves the execution steps of a workflow.\nThis is a list of ",(0,s.jsx)(n.code,{children:"StepInfo"})," objects, with the following structure:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"type StepInfo struct {\n    StepID          int    // The sequential ID of the step within the workflow\n    StepName        string // The name of the step function\n    Output          any    // The output returned by the step (if any)\n    Error           error  // The error returned by the step (if any)\n    ChildWorkflowID string  // If the step starts or retrieves the result of a workflow, its ID\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"workflowID"}),": The ID of the workflow to cancel."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"cancelworkflow",children:"CancelWorkflow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func CancelWorkflow(ctx DBOSContext, workflowID string) error\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Cancel a workflow. This sets its status to ",(0,s.jsx)(n.code,{children:"CANCELLED"}),", removes it from its queue (if it is enqueued) and preempts its execution (interrupting it at the beginning of its next step)."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"workflowID"}),": The ID of the workflow to cancel."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"resumeworkflow",children:"ResumeWorkflow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func ResumeWorkflow[R any](ctx DBOSContext, workflowID string) (*WorkflowHandle[R], error)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Resume a workflow. This immediately starts it from its last completed step. You can use this to resume workflows that are cancelled or have exceeded their maximum recovery attempts. You can also use this to start an enqueued workflow immediately, bypassing its queue."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"workflowID"}),": The ID of the workflow to resume."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"forkworkflow",children:"ForkWorkflow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func ForkWorkflow[R any](ctx DBOSContext, input ForkWorkflowInput) (WorkflowHandle[R], error)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Start a new execution of a workflow from a specific step. The input step ID (",(0,s.jsx)(n.code,{children:"startStep"}),") must match the step number of the step returned by workflow introspection. The specified ",(0,s.jsx)(n.code,{children:"startStep"})," is the step from which the new workflow will start, so any steps whose ID is less than ",(0,s.jsx)(n.code,{children:"startStep"})," will not be re-executed."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"input"}),": A ",(0,s.jsx)(n.code,{children:"ForkWorkflowInput"})," struct where ",(0,s.jsx)(n.code,{children:"OriginalWorkflowID"})," is mandatory."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"type ForkWorkflowInput struct {\n    OriginalWorkflowID string // Required: The UUID of the original workflow to fork from\n    ForkedWorkflowID   string // Optional: Custom workflow ID for the forked workflow (auto-generated if empty)\n    StartStep          uint   // Optional: Step to start the forked workflow from (default: 0)\n    ApplicationVersion string // Optional: Application version for the forked workflow (inherits from original if empty)\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"workflow-status",children:"Workflow Status"}),"\n",(0,s.jsxs)(n.p,{children:["Some workflow introspection and management methods return a ",(0,s.jsx)(n.code,{children:"WorkflowStatus"}),".\nThis object has the following definition:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'type WorkflowStatus struct {\n    ID                 string             `json:"workflow_uuid"`       // Unique identifier for the workflow\n    Status             WorkflowStatusType `json:"status"`              // Current execution status\n    Name               string             `json:"name"`                // Function name of the workflow\n    AuthenticatedUser  *string            `json:"authenticated_user"`  // User who initiated the workflow (if applicable)\n    AssumedRole        *string            `json:"assumed_role"`        // Role assumed during execution (if applicable)\n    AuthenticatedRoles *string            `json:"authenticated_roles"` // Roles available to the user (if applicable)\n    Output             any                `json:"output"`              // Workflow output (available after completion)\n    Error              error              `json:"error"`               // Error information (if status is ERROR)\n    ExecutorID         string             `json:"executor_id"`         // ID of the executor running this workflow\n    CreatedAt          time.Time          `json:"created_at"`          // When the workflow was created\n    UpdatedAt          time.Time          `json:"updated_at"`          // When the workflow status was last updated\n    ApplicationVersion string             `json:"application_version"` // Version of the application that created this workflow\n    ApplicationID      string             `json:"application_id"`      // Application identifier\n    Attempts           int                `json:"attempts"`            // Number of execution attempts\n    QueueName          string             `json:"queue_name"`          // Queue name (if workflow was enqueued)\n    Timeout            time.Duration      `json:"timeout"`             // Workflow timeout duration\n    Deadline           time.Time          `json:"deadline"`            // Absolute deadline for workflow completion\n    StartedAt          time.Time          `json:"started_at"`          // When the workflow execution actually started\n    DeduplicationID    string             `json:"deduplication_id"`    // Deduplication identifier (if applicable)\n    Input              any                `json:"input"`               // Input parameters passed to the workflow\n    Priority           int                `json:"priority"`            // Execution priority (lower numbers have higher priority)\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"workflowstatustype",children:"WorkflowStatusType"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"WorkflowStatusType"})," represents the execution status of a workflow:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'type WorkflowStatusType string\n\nconst (\n    WorkflowStatusPending                     WorkflowStatusType = "PENDING"                        // Workflow is running or ready to run\n    WorkflowStatusEnqueued                    WorkflowStatusType = "ENQUEUED"                       // Workflow is queued and waiting for execution\n    WorkflowStatusSuccess                     WorkflowStatusType = "SUCCESS"                        // Workflow completed successfully\n    WorkflowStatusError                       WorkflowStatusType = "ERROR"                          // Workflow completed with an error\n    WorkflowStatusCancelled                   WorkflowStatusType = "CANCELLED"                      // Workflow was cancelled (manually or due to timeout)\n    WorkflowStatusMaxRecoveryAttemptsExceeded WorkflowStatusType = "MAX_RECOVERY_ATTEMPTS_EXCEEDED" // Workflow exceeded maximum retry attempts\n)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"dbos-variables",children:"DBOS Variables"}),"\n",(0,s.jsx)(n.h3,{id:"getworkflowid",children:"GetWorkflowID"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func GetWorkflowID(ctx DBOSContext) (string, error)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Return the ID of the current workflow, if in a workflow. Returns an error if not called from within a workflow context."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"getstepid",children:"GetStepID"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"func GetStepID(ctx DBOSContext) (int, error)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Return the unique ID of the current step within a workflow. Returns an error if not called from within a step context."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ctx"}),": The DBOS context."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var r=t(6540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);