"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[9155],{2598:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"typescript/reference/workflows-steps","title":"Workflows & Steps","description":"Workflows","source":"@site/docs/typescript/reference/workflows-steps.md","sourceDirName":"typescript/reference","slug":"/typescript/reference/workflows-steps","permalink":"/typescript/reference/workflows-steps","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":20,"frontMatter":{"sidebar_position":20,"title":"Workflows & Steps"},"sidebar":"tutorialSidebar","previous":{"title":"DBOS Lifecycle","permalink":"/typescript/reference/dbos-class"},"next":{"title":"DBOS Methods & Variables","permalink":"/typescript/reference/methods"}}');var r=s(4848),o=s(8453);const i={sidebar_position:20,title:"Workflows & Steps"},l=void 0,c={},a=[{value:"Workflows",id:"workflows",level:2},{value:"DBOS.workflow",id:"dbosworkflow",level:3},{value:"DBOS.registerWorkflow",id:"dbosregisterworkflow",level:3},{value:"DBOS.scheduled",id:"dbosscheduled",level:3},{value:"DBOS.registerScheduled",id:"dbosregisterscheduled",level:3},{value:"Steps",id:"steps",level:2},{value:"DBOS.step",id:"dbosstep",level:3},{value:"DBOS.registerStep",id:"dbosregisterstep",level:3},{value:"DBOS.runStep",id:"dbosrunstep",level:3},{value:"Instance Method Workflows",id:"instance-method-workflows",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"workflows",children:"Workflows"}),"\n",(0,r.jsx)(n.h3,{id:"dbosworkflow",children:"DBOS.workflow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"DBOS.workflow(\n    config: WorkflowConfig = {}\n)\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"export interface WorkflowConfig {\n  maxRecoveryAttempts?: number;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"A decorator that marks a function as a DBOS durable workflow."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"export class Example {\n  @DBOS.workflow()\n  static async exampleWorkflow() {\n    await Example.stepOne();\n    await Example.stepTwo();\n  }\n}\n\n// The workflow function can be called normally\nawait Example.exampleWorkflow();\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"config"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"max_recovery_attempts"}),": The maximum number of times the workflow may be attempted.\nThis acts as a ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Dead_letter_queue",children:"dead letter queue"})," so that a buggy workflow that crashes its application (for example, by running it out of memory) does not do so infinitely.\nIf a workflow exceeds this limit, its status is set to ",(0,r.jsx)(n.code,{children:"RETRIES_EXCEEDED"})," and it is no longer automatically recovered."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"dbosregisterworkflow",children:"DBOS.registerWorkflow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"DBOS.registerWorkflow<This, Args extends unknown[], Return>(\n    func: (this: This, ...args: Args) => Promise<Return>,\n    config?: FunctionName & WorkflowConfig,\n  ): (this: This, ...args: Args) => Promise<Return> => Promise<Return> \n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface FunctionName {\n  name?: string;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Wrap a function in a DBOS workflow.\nReturns the wrapped function."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'async function exampleWorkflowFunction() {\n  await stepOne();\n  await stepTwo();\n}\n\nconst workflow = DBOS.registerWorkflow(exampleWorkflowFunction, {"name": "exampleWorkflow"})\n// The registered workflow can be called normally\nawait workflow();\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"func"}),": The function to be wrapped in a workflow."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"name"}),": A name to give the workflow."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"config"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"name"}),": The name with which to register the workflow. Defaults to the function name."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"max_recovery_attempts"}),": The maximum number of times the workflow may be attempted.\nThis acts as a ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Dead_letter_queue",children:"dead letter queue"})," so that a buggy workflow that crashes its application (for example, by running it out of memory) does not do so infinitely.\nIf a workflow exceeds this limit, its status is set to ",(0,r.jsx)(n.code,{children:"RETRIES_EXCEEDED"})," and it is no longer automatically recovered."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"dbosscheduled",children:"DBOS.scheduled"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"DBOS.scheduled(\n  schedulerConfig: SchedulerConfig\n);\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class SchedulerConfig {\n  crontab: string;\n  mode?: SchedulerMode = SchedulerMode.ExactlyOncePerIntervalWhenActive;\n  queueName?: string;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["A decorator directing DBOS to run a workflow on a schedule specified using ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Cron",children:"crontab"})," syntax.\nSee ",(0,r.jsx)(n.a,{href:"https://docs.gitlab.com/ee/topics/cron/",children:"here"})," for a guide to cron syntax and ",(0,r.jsx)(n.a,{href:"https://crontab.guru/",children:"here"})," for a crontab editor."]}),"\n",(0,r.jsxs)(n.p,{children:["The annotated function must take in two parameters: The time that the run was scheduled (as a ",(0,r.jsx)(n.code,{children:"Date"}),") and the time that the run was actually started (also a ",(0,r.jsx)(n.code,{children:"Date"}),").\nFor example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { DBOS } from '@dbos-inc/dbos-sdk';\n\nclass ScheduledExample{\n  @DBOS.workflow()\n  @DBOS.scheduled({crontab: '*/30 * * * * *'})\n  static async scheduledWorkflow(schedTime: Date, startTime: Date) {\n    DBOS.logger.info(`I am a workflow scheduled to run every 30 seconds`);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"schedulerConfig"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"crontab"}),": The schedule in ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Cron",children:"crontab"})," syntax.\nThe DBOS variant contains 5 or 6 items, separated by spaces:"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:" \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 second (optional)\n \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 minute\n \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 hour\n \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of month\n \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500 month\n \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500 day of week\n \u2502 \u2502 \u2502 \u2502 \u2502 \u2502\n \u2502 \u2502 \u2502 \u2502 \u2502 \u2502\n * * * * * *\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"mode"}),":  Whether or not to retroactively start workflows that were scheduled during times when the app was not running. Set to ",(0,r.jsx)(n.code,{children:"SchedulerMode.ExactlyOncePerInterval"})," to enable this behavior."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"queueName"}),": If set, workflows will be enqueued on the named queue, rather than being started immediately."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"dbosregisterscheduled",children:"DBOS.registerScheduled"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"registerScheduled<This, Return>(\n    func: (this: This, ...args: ScheduledArgs) => Promise<Return>,\n    config: SchedulerConfig,\n)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Register a workflow to run on a schedule.\nThe semantics are the same as for the ",(0,r.jsx)(n.a,{href:"#dbosscheduled",children:(0,r.jsx)(n.code,{children:"DBOS.scheduled"})})," decorator.\nFor example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"async function scheduledFunction(schedTime: Date, startTime: Date) {\n    DBOS.logger.info(`I am a workflow scheduled to run every 30 seconds`);\n}\n\nconst scheduledWorkflow = DBOS.registerWorkflow(scheduledFunction);\nDBOS.registerScheduled(scheduledWorkflow, {crontab: '*/30 * * * * *'});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"steps",children:"Steps"}),"\n",(0,r.jsx)(n.h3,{id:"dbosstep",children:"DBOS.step"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"DBOS.step(\n    config: StepConfig = {}\n)\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface StepConfig {\n  retriesAllowed?: boolean;\n  intervalSeconds?: number;\n  maxAttempts?: number;\n  backoffRate?: number;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"A decorator that marks a function as a step in a durable workflow."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'export class Example {\n  @DBOS.step()\n  static async stepOne() {\n    DBOS.logger.info("Step one completed!");\n  }\n\n  @DBOS.step()\n  static async stepTwo() {\n    DBOS.logger.info("Step two completed!");\n  }\n\n  // Call steps from workflows\n  @DBOS.workflow()\n  static async exampleWorkflow() {\n    await Toolbox.stepOne();\n    await Toolbox.stepTwo();\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"config"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"retriesAllowed"}),": Whether to retry the step if it throws an exception."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"intervalSeconds"}),": How long to wait before the initial retry."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"maxAttempts"}),": How many times to retry a step that is throwing exceptions."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"backoffRate"}),": How much to multiplicatively increase ",(0,r.jsx)(n.code,{children:"intervalSeconds"})," between retries."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"dbosregisterstep",children:"DBOS.registerStep"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"DBOS.registerStep<This, Args extends unknown[], Return>(\n    func: (this: This, ...args: Args) => Promise<Return>,\n    config: StepConfig & FunctionName = {},\n): (this: This, ...args: Args) => Promise<Return>\n"})}),"\n",(0,r.jsx)(n.p,{children:"Wrap a function in a step to safely call it from a durable workflow.\nReturns the wrapped function."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'async function stepOneFunction() {\n  DBOS.logger.info("Step one completed!");\n}\nconst stepOne = DBOS.registerStep(stepOneFunction, {"name": "stepOne"});\n\nasync function stepTwoFunction() {\n  DBOS.logger.info("Step two completed!");\n}\nconst stepTwo = DBOS.registerStep(stepTwoFunction, {"name": "stepTwo"});\n\n// Call steps from workflows\nasync function workflowFunction() {\n  await stepOne();\n  await stepTwo();\n}\nconst workflow = DBOS.registerWorkflow(workflowFunction, {"name": "exampleWorkflow"})\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"func"}),": The function to be wrapped in a step."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"config"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"name"}),": A name to give the step. If not provided, use the function name."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"retriesAllowed"}),": Whether to retry the step if it throws an exception."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"intervalSeconds"}),": How long to wait before the initial retry."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"maxAttempts"}),": How many times to retry a step that is throwing exceptions."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"backoffRate"}),": How much to multiplicatively increase ",(0,r.jsx)(n.code,{children:"intervalSeconds"})," between retries."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"dbosrunstep",children:"DBOS.runStep"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"runStep<Return>(\n  func: () => Promise<Return>,\n  config: StepConfig & { name?: string } = {}\n): Promise<Return>\n"})}),"\n",(0,r.jsx)(n.p,{children:"Run a function as a step in a workflow.\nCan only be called from a durable workflow.\nReturns the output of the step."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'async function stepOne() {\n  DBOS.logger.info("Step one completed!");\n}\n\nasync function stepTwo() {\n  DBOS.logger.info("Step two completed!");\n}\n\n// Use DBOS.runStep to run any function as a step\nasync function exampleWorkflow() {\n  await DBOS.runStep(() => stepOne(), {name: "stepOne"});\n  await DBOS.runStep(() => stepTwo(), {name: "stepTwo"});\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"func"}),": The function to run as a step."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"config"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"name"}),": A name to give the step."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"retriesAllowed"}),": Whether to retry the step if it throws an exception."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"intervalSeconds"}),": How long to wait before the initial retry."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"maxAttempts"}),": How many times to retry a step that is throwing exceptions."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"backoffRate"}),": How much to multiplicatively increase ",(0,r.jsx)(n.code,{children:"intervalSeconds"})," between retries."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"instance-method-workflows",children:"Instance Method Workflows"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"abstract class ConfiguredInstance {\n  constructor(name: string)  \n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can register or decorate class instance methods.  However, if a class has any workflow methods, that class must inherit from ",(0,r.jsx)(n.code,{children:"ConfiguredInstance"}),", which takes an instance name and registers the instance."]}),"\n",(0,r.jsxs)(n.p,{children:["When you create a new instance of the class, the constructor for the base ",(0,r.jsx)(n.code,{children:"ConfiguredInstance"})," must be called with a ",(0,r.jsx)(n.code,{children:"name"}),".\nThis ",(0,r.jsx)(n.code,{children:"name"})," should be unique among instances of the same class.\nAdditionally, all ",(0,r.jsx)(n.code,{children:"ConfiguredInstance"})," classes must be instantiated before ",(0,r.jsx)(n.code,{children:"DBOS.launch()"})," is called."]}),"\n",(0,r.jsx)(n.p,{children:"For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class MyClass extends ConfiguredInstance {\n  cfg: MyConfig;\n  constructor(name: string, config: MyConfig) {\n    super(name);\n    this.cfg = cfg;\n  }\n\n  @DBOS.workflow()\n  async testWorkflow(p: string): Promise<void> {\n    // ... Operations that use this.cfg\n  }\n}\n\nconst myClassInstance = new MyClass('instanceA');\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The reason for these requirements is to enable workflow recovery.  When you create a new instance of, DBOS stores it in a global registry indexed by ",(0,r.jsx)(n.code,{children:"name"}),".  When DBOS needs to recover a workflow belonging to that class, it looks up the ",(0,r.jsx)(n.code,{children:"name"})," so it can run the workflow using the right class instance.  While names are used by DBOS Transact internally to find the correct object instance across system restarts, they are also potentially useful for monitoring, tracing, and debugging."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>l});var t=s(6540);const r={},o=t.createContext(r);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);