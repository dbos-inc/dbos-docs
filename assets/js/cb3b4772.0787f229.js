"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[992],{426:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var o=n(5893),r=n(1151);const i={sidebar_position:4,description:"Learn how DBOS workflows work"},s="How Workflows Work",a={id:"explanations/how-workflows-work",title:"How Workflows Work",description:"Learn how DBOS workflows work",source:"@site/docs/explanations/how-workflows-work.md",sourceDirName:"explanations",slug:"/explanations/how-workflows-work",permalink:"/explanations/how-workflows-work",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,description:"Learn how DBOS workflows work"},sidebar:"tutorialSidebar",previous:{title:"Core Concepts",permalink:"/explanations/core-concepts"},next:{title:"Application Lifecycle",permalink:"/explanations/application-lifecycle"}},l={},c=[{value:"Workflow Guarantees",id:"workflow-guarantees",level:3},{value:"Reliability Through Recording and Safe Re-execution",id:"reliability-through-recording-and-safe-re-execution",level:3},{value:"Reliability by Example",id:"reliability-by-example",level:3},{value:"Requirements for Workflows",id:"requirements-for-workflows",level:3}];function u(e){const t={a:"a",br:"br",code:"code",em:"em",h1:"h1",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"how-workflows-work",children:"How Workflows Work"}),"\n",(0,o.jsxs)(t.p,{children:["One of the most powerful features of DBOS is its ",(0,o.jsx)(t.a,{href:"../tutorials/workflow-tutorial#reliability-guarantees",children:"reliable workflows"}),", which are guaranteed to always run to completion with each function executing once and only once.\nIn this guide, we'll explain how DBOS makes workflows reliable."]}),"\n",(0,o.jsx)(t.h3,{id:"workflow-guarantees",children:"Workflow Guarantees"}),"\n",(0,o.jsxs)(t.p,{children:["To reiterate from our ",(0,o.jsx)(t.a,{href:"../tutorials/workflow-tutorial",children:"workflow tutorial"}),", workflows provide the following reliability guaranteees:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"They always run to completion.  If a server executing a workflow crashes and restarts, it resumes all incomplete workflows."}),"\n",(0,o.jsxs)(t.li,{children:["Transactions execute ",(0,o.jsx)(t.em,{children:"exactly once"}),".  Regardless of what failures occur during a workflow's execution, it executes each of its transactions once and only once."]}),"\n",(0,o.jsxs)(t.li,{children:["Communicators execute ",(0,o.jsx)(t.em,{children:"at least once"})," but are never re-executed after they successfully complete.  If a failure occurs inside a communicator, the communicator may be retried, but once a communicator has completed execution, DBOS guarantees it will never be re-executed regardless of what failures happen afterwards."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"reliability-through-recording-and-safe-re-execution",children:"Reliability Through Recording and Safe Re-execution"}),"\n",(0,o.jsxs)(t.p,{children:["To make workflows reliable, DBOS records every step they take in the database so it can safely re-execute them if they're interrupted.\nBefore a workflow starts, DBOS records its input.\nEach time a workflow executes a ",(0,o.jsx)(t.a,{href:"../tutorials/transaction-tutorial",children:"transaction"})," or ",(0,o.jsx)(t.a,{href:"../tutorials/communicator-tutorial",children:"communicator"}),", DBOS records its output (or the exception it threw, if any).\nWhen a workflow finishes, DBOS records its output."]}),"\n",(0,o.jsxs)(t.p,{children:["If a DBOS server crashes and restarts, it uses the information saved in the database to resume all unfinished workflows from where they left off.\nFirst, it finds all unfinished workflows: those with a recorded input, but no recorded output.\nThen, it restarts every unfinished workflow from the beginning, using its saved inputs.\nWhile re-executing an unfinished workflow, it checks before every function execution if the function has an output stored in the database, meaning it previously completed.\nIf it finds a saved output, it skips re-executing that function and instead uses the saved output.\nWhen the workflow gets to the first function that does not have a saved output and hence ",(0,o.jsx)(t.em,{children:"didn't"}),' previously complete, it executes normally, thus "resuming from where it left off."\nLet\'s look at how this procedure gets us all three of our guarantees.']}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Any interrupted workflow is re-executed until it completes, so workflows always run to completion."}),"\n",(0,o.jsx)(t.li,{children:"We record each transaction's output as part of the transaction and re-execute it only if and only if the output is not found, so transactions execute exactly once."}),"\n",(0,o.jsx)(t.li,{children:"We record each communicator's output after it completes and re-execute it if and only if the output is not found, so communicators execute at least once but are never re-executed after their completion."}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"reliability-by-example",children:"Reliability by Example"}),"\n",(0,o.jsx)(t.p,{children:"To make this clearer, let's look at a simplified checkout workflow for a ticketing site.\nIt first reserves a ticket in the database, then calls out to a third-party platform to process a payment.\nIf the payment doesn't go through, it releases the ticket."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"  @Workflow()\n  static async checkoutWorkflow(ctxt: WorkflowContext, ticketInfo: TicketInfo, paymentInfo: PaymentInfo) {\n    // Invoke a transaction to reserve the ticket\n    const reserved = await ctxt.invoke(Ticket).reserveTicket(ticketInfo)\n    if (!reserved) {\n      // If the ticket can't be reserved, return failure\n      return false\n    }\n    // Invoke a communicator to pay for the ticket\n    const paymentSuccessful = ctxt.invoke(Ticket).payment(paymentInfo)\n    if (paymentSuccessful) {\n      // If the payment succeeded, return success\n      return true\n    } else {\n      // If the payment didn't go through, invoke a transaction to undo the reservation and return failure\n      await ctxt.invoke(Ticket).undoReserveTicket(ticketInfo)\n      return false\n    }\n  }\n"})}),"\n",(0,o.jsxs)(t.p,{children:["To make this workflow reliable, DBOS automatically records in the database each step it takes.\nBefore starting, DBOS records its inputs.\nAs part of the ",(0,o.jsx)(t.code,{children:"reserveTicket"})," transaction, DBOS records whether the reservation succeeded or failed.\nAfter the ",(0,o.jsx)(t.code,{children:"payment"})," communicator completes, DBOS records whether the payment went through.\nAs part of the ",(0,o.jsx)(t.code,{children:"undoReserveTicket"})," transaction, DBOS records its completion."]}),"\n",(0,o.jsx)(t.p,{children:"Using this information, DBOS can resume the workflow if it is interrupted.\nLet's say a customer is trying to purchase a ticket and the following events happen:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Their reservation suceeds."}),"\n",(0,o.jsx)(t.li,{children:"Their payment fails."}),"\n",(0,o.jsx)(t.li,{children:"The server crashes while undoing the reservation (causing the database to automatically abort that transaction)."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["It's business-critical that we resume this workflow, as otherwise the customer would have reserved a ticket they never paid for.\nWhen the server restarts, DBOS re-executes the workflow from the beginning.\nWhen it gets to ",(0,o.jsx)(t.code,{children:"reserveTicket"}),", it checks the database and finds it previously succeeded, so instead of re-executing the transaction (and potentially reserving a second ticket), it simply returns ",(0,o.jsx)(t.code,{children:"true"}),".",(0,o.jsx)(t.br,{}),"\n","When it gets to ",(0,o.jsx)(t.code,{children:"payment"}),", it does the same thing, returning ",(0,o.jsx)(t.code,{children:"false"}),".\nFinally, it gets to ",(0,o.jsx)(t.code,{children:"undoReserveTicket"}),", sees no recorded output in the database, and executes the function normally, successfuly completing the workflow.\nFrom a user's perspective, the workflow has resumed from where it failed last time!"]}),"\n",(0,o.jsx)(t.h3,{id:"requirements-for-workflows",children:"Requirements for Workflows"}),"\n",(0,o.jsx)(t.p,{children:"For workflow recovery to work, they must meet two requirements."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsxs)(t.strong,{children:["First, workflows must be ",(0,o.jsx)(t.a,{href:"../tutorials/workflow-tutorial#determinism",children:"deterministic"})]}),": all code in the workflow function must do the same thing if called multiple times with the same input.\nIf you need to perform a non-deterministic operation like accessing the database, calling a third-party API, generating a random number, or getting the local time, you shouldn't do it directly in a workflow function.\nInstead, you should do all database operations in ",(0,o.jsx)(t.a,{href:"../tutorials/transaction-tutorial",children:"transactions"})," and all other non-deterministic operations in ",(0,o.jsx)(t.a,{href:"../tutorials/communicator-tutorial",children:"communicators"}),".\nThat way, DBOS can capture the output of the non-deterministic operation and avoid re-executing it."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Second, DBOS function should not have side effects in memory"}),".\nFor example, they shouldn't modify global variables.\nIf they do, we cannot guarantee those side effects are persisted during recovery for later functions in the same workflow.\nInstead, functions should return any values they want later functions to be aware of and should store all persistent state in the database."]})]})}function d(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>s});var o=n(7294);const r={},i=o.createContext(r);function s(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);