"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[9401],{5563:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"golang/tutorials/upgrading-workflows","title":"Upgrading Workflow Code","description":"A challenge encountered when operating long-running durable workflows in production is how to deploy breaking changes without disrupting in-progress workflows.","source":"@site/docs/golang/tutorials/upgrading-workflows.md","sourceDirName":"golang/tutorials","slug":"/golang/tutorials/upgrading-workflows","permalink":"/golang/tutorials/upgrading-workflows","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":65,"frontMatter":{"sidebar_position":65,"title":"Upgrading Workflow Code","toc_max_heading_level":3},"sidebar":"tutorialSidebar","previous":{"title":"Workflow Management","permalink":"/golang/tutorials/workflow-management"},"next":{"title":"Testing & Mocking","permalink":"/golang/tutorials/testing"}}');var o=r(4848),s=r(8453);const i={sidebar_position:65,title:"Upgrading Workflow Code",toc_max_heading_level:3},a=void 0,c={},l=[{value:"Patching",id:"patching",level:2},{value:"Deprecating and Removing Patches",id:"deprecating-and-removing-patches",level:3},{value:"How Patching Works",id:"how-patching-works",level:3},{value:"Versioning",id:"versioning",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["A challenge encountered when operating long-running durable workflows in production is ",(0,o.jsx)(n.strong,{children:"how to deploy breaking changes without disrupting in-progress workflows."}),"\nA breaking change to a workflow is one that changes which steps are run, or the order in which the steps are run.\nIf a breaking change was made to a workflow and that workflow is replayed by the recovery system, the checkpoints created by the previous version of the code may not match the steps called by the workflow in the new version of the code, causing recovery to fail."]}),"\n",(0,o.jsxs)(n.p,{children:["DBOS supports two strategies for safely upgrading workflow code: ",(0,o.jsx)(n.strong,{children:"patching"})," and ",(0,o.jsx)(n.strong,{children:"versioning"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"patching",children:"Patching"}),"\n",(0,o.jsxs)(n.p,{children:["In patching, the result of a call to ",(0,o.jsx)(n.a,{href:"/golang/reference/workflows-steps#patch",children:(0,o.jsx)(n.code,{children:"dbos.Patch()"})})," is used to conditionally execute the new code.\n",(0,o.jsx)(n.code,{children:"dbos.Patch()"})," returns ",(0,o.jsx)(n.code,{children:"true"})," for new calls (those executing after the breaking change) and ",(0,o.jsx)(n.code,{children:"false"})," for old calls (those that executed before the breaking change).\nTherefore, if ",(0,o.jsx)(n.code,{children:"dbos.Patch()"})," returns ",(0,o.jsx)(n.code,{children:"true"}),", the workflow should follow the new code path, otherwise it must follow the prior codepath."]}),"\n",(0,o.jsx)(n.p,{children:"To use patching, you must enable it in the configuration:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'dbosCtx, err := dbos.NewDBOSContext(context.Background(), dbos.Config{\n    DatabaseURL:    os.Getenv("DBOS_DATABASE_URL"),\n    AppName:        "my-app",\n    EnablePatching: true,\n})\n'})}),"\n",(0,o.jsx)(n.p,{children:"For example, let's say our original workflow is:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'func workflow(ctx dbos.DBOSContext, input string) (string, error) {\n    _, err := dbos.RunAsStep(ctx, func(stepCtx context.Context) (string, error) {\n        return foo(stepCtx)\n    })\n    if err != nil {\n        return "", err\n    }\n    _, err = dbos.RunAsStep(ctx, func(stepCtx context.Context) (string, error) {\n        return bar(stepCtx)\n    })\n    if err != nil {\n        return "", err\n    }\n    return "success", nil\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["We want to replace the call to ",(0,o.jsx)(n.code,{children:"foo()"})," with a call to ",(0,o.jsx)(n.code,{children:"baz()"}),".\nThis is a breaking change because it changes what steps run.\nWe can make this breaking change safely using a patch:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'func workflow(ctx dbos.DBOSContext, input string) (string, error) {\n    patched, err := dbos.Patch(ctx, "use-baz")\n    if err != nil {\n        return "", err\n    }\n    if patched {\n        _, err = dbos.RunAsStep(ctx, func(stepCtx context.Context) (string, error) {\n            return baz(stepCtx)\n        })\n    } else {\n        _, err = dbos.RunAsStep(ctx, func(stepCtx context.Context) (string, error) {\n            return foo(stepCtx)\n        })\n    }\n    if err != nil {\n        return "", err\n    }\n    _, err = dbos.RunAsStep(ctx, func(stepCtx context.Context) (string, error) {\n        return bar(stepCtx)\n    })\n    if err != nil {\n        return "", err\n    }\n    return "success", nil\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Now, new workflows will run ",(0,o.jsx)(n.code,{children:"baz()"}),", while old workflows will reexecute ",(0,o.jsx)(n.code,{children:"foo()"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Examples of workflows taking the old code:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Recovered workflows that executed up to or beyond the patch point"}),"\n",(0,o.jsx)(n.li,{children:"Workflows forked after the patch point"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Examples of workflows taking the new code:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Entirely new workflows"}),"\n",(0,o.jsx)(n.li,{children:"Recovered workflows that executed before the patch point"}),"\n",(0,o.jsx)(n.li,{children:"Workflows forked before the patch point"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"deprecating-and-removing-patches",children:"Deprecating and Removing Patches"}),"\n",(0,o.jsx)(n.p,{children:"Patches add complexity and runtime overhead; fortunately they don't need to stay in your code forever.\nOnce all workflows that started before you deployed the patch are complete, you can safely remove patches from your code."}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["You can use the ",(0,o.jsx)(n.a,{href:"/golang/tutorials/workflow-management#listing-workflows",children:"list workflows APIs"})," to see what workflows are still active."]})}),"\n",(0,o.jsxs)(n.p,{children:["First, you must deprecate the patch with ",(0,o.jsx)(n.a,{href:"/golang/reference/workflows-steps#deprecatepatch",children:(0,o.jsx)(n.code,{children:"dbos.DeprecatePatch()"})}),".\n",(0,o.jsx)(n.code,{children:"DeprecatePatch"})," must be used for a transition period prior to fully removing the patch, as it allows coexistence with any ongoing workflows that used ",(0,o.jsx)(n.code,{children:"Patch()"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"For example, here's how to deprecate the patch above:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'func workflow(ctx dbos.DBOSContext, input string) (string, error) {\n    _, err := dbos.DeprecatePatch(ctx, "use-baz") // always returns true\n    if err != nil {\n        return "", err\n    }\n    _, err = dbos.RunAsStep(ctx, func(stepCtx context.Context) (string, error) {\n        return baz(stepCtx)\n    })\n    if err != nil {\n        return "", err\n    }\n    _, err = dbos.RunAsStep(ctx, func(stepCtx context.Context) (string, error) {\n        return bar(stepCtx)\n    })\n    if err != nil {\n        return "", err\n    }\n    return "success", nil\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Then, when all workflows that started before you deprecated the patch are complete, you can remove the patch entirely:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'func workflow(ctx dbos.DBOSContext, input string) (string, error) {\n    _, err := dbos.RunAsStep(ctx, func(stepCtx context.Context) (string, error) {\n        return baz(stepCtx)\n    })\n    if err != nil {\n        return "", err\n    }\n    _, err = dbos.RunAsStep(ctx, func(stepCtx context.Context) (string, error) {\n        return bar(stepCtx)\n    })\n    if err != nil {\n        return "", err\n    }\n    return "success", nil\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"If any mistakes happen during the process (a breaking change is not patched, or a patch is deprecated or removed prematurely), the workflow will return an error pointing to the step where the problem occurred."}),"\n",(0,o.jsx)(n.h3,{id:"how-patching-works",children:"How Patching Works"}),"\n",(0,o.jsxs)(n.p,{children:["Under the hood, when you call ",(0,o.jsx)(n.code,{children:"dbos.Patch()"}),' from a workflow, it attempts to insert a "patch marker" at its current point in your workflow history (this is a new row in the ',(0,o.jsx)(n.code,{children:"operation_outputs"})," table in the DBOS ",(0,o.jsx)(n.a,{href:"/explanations/system-tables",children:"system database"}),").\nIf it successfully inserts the patch marker or if the patch marker is already present, then the workflow should take the patch codepath.\nIf there is already a record present in this point in your workflow history and it is not a patch marker, then the workflow must be old (it already continued past this point with old code), and ",(0,o.jsx)(n.code,{children:"dbos.Patch()"})," returns ",(0,o.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["When you deprecate a patch with ",(0,o.jsx)(n.code,{children:"dbos.DeprecatePatch()"}),", new workflows no longer insert patch markers into their workflow history.\nHowever, if a workflow contains the patch marker in its history, it continues past that patch marker, safely ignoring it.\nOnce all workflows with patch markers are complete, the patch may be safely removed."]}),"\n",(0,o.jsx)(n.h2,{id:"versioning",children:"Versioning"}),"\n",(0,o.jsxs)(n.p,{children:["When using versioning, DBOS ",(0,o.jsx)(n.strong,{children:"versions"})," applications and workflows, and only continues workflow execution with the same application version that started the workflow.\nAll workflows are tagged with the application version on which they started.\nBy default, application version is automatically computed from a hash of workflow source code.\nHowever, you can set your own version through configuration."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'dbosCtx, err := dbos.NewDBOSContext(context.Background(), dbos.Config{\n    DatabaseURL:        os.Getenv("DBOS_DATABASE_URL"),\n    AppName:            "my-app",\n    ApplicationVersion: "1.0.0",\n})\n'})}),"\n",(0,o.jsx)(n.p,{children:"When DBOS tries to recover workflows, it only recovers workflows whose version matches the current application version.\nThis prevents recovery of workflows that depend on different code."}),"\n",(0,o.jsxs)(n.p,{children:["When using versioning, we recommend ",(0,o.jsx)(n.strong,{children:"blue-green"})," code upgrades:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"When deploying a new version of your code, launch new processes running your new code version, but retain some processes running your old code version."}),"\n",(0,o.jsx)(n.li,{children:'Direct new traffic to your new processes while your old processes "drain" and complete all workflows of the old code version.'}),"\n",(0,o.jsxs)(n.li,{children:["Then, once all workflows of the old version are complete (you can use ",(0,o.jsx)(n.a,{href:"/golang/reference/methods#listworkflows",children:(0,o.jsx)(n.code,{children:"ListWorkflows"})})," to check), you can retire the old code version."]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var t=r(6540);const o={},s=t.createContext(o);function i(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);