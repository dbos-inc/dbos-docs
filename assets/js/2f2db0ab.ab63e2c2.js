"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[7870],{5483:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>f,frontMatter:()=>s,metadata:()=>o,toc:()=>u});const o=JSON.parse('{"id":"golang/prompting","title":"AI Model Prompting","description":"You may want assistance from an AI model in building a DBOS application.","source":"@site/docs/golang/prompting.md","sourceDirName":"golang","slug":"/golang/prompting","permalink":"/golang/prompting","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":30,"frontMatter":{"sidebar_position":30,"title":"AI Model Prompting"},"sidebar":"tutorialSidebar","previous":{"title":"Add DBOS To Your App","permalink":"/golang/integrating-dbos"},"next":{"title":"Workflows","permalink":"/golang/tutorials/workflow-tutorial"}}');var r=t(4848),i=t(8453);const s={sidebar_position:30,title:"AI Model Prompting"},a=void 0,l={},u=[{value:"How To Use",id:"how-to-use",level:2},{value:"Prompt",id:"prompt",level:2}];function c(n){const e={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:"You may want assistance from an AI model in building a DBOS application.\nTo make sure your model has the latest information on how to use DBOS, provide it with this prompt."}),"\n",(0,r.jsx)(e.h2,{id:"how-to-use",children:"How To Use"}),"\n",(0,r.jsx)(e.p,{children:"First, use the click-to-copy button in the top right of the code block to copy the full prompt to your clipboard.\nThen, paste into your AI tool of choice (for example OpenAI's ChatGPT or Anthropic's Claude).\nThis adds the prompt to your AI model's context, giving it up-to-date instructions on how to build an application with DBOS."}),"\n",(0,r.jsx)(e.p,{children:"If you are using an AI-powered IDE, you can add this prompt to your project's context.\nFor example:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Claude Code: Add the prompt, or a link to it, to your CLAUDE.md file."}),"\n",(0,r.jsxs)(e.li,{children:["Cursor: Add the prompt to ",(0,r.jsx)(e.a,{href:"https://docs.cursor.com/context/rules-for-ai",children:"your project rules"}),"."]}),"\n",(0,r.jsxs)(e.li,{children:["Zed: Copy the prompt to a file in your project, then use the ",(0,r.jsx)(e.a,{href:"https://zed.dev/docs/assistant/commands?highlight=%2Ffile#file",children:(0,r.jsx)(e.code,{children:"/file"})})," command to add the file to your context."]}),"\n",(0,r.jsxs)(e.li,{children:["GitHub Copilot: Create a ",(0,r.jsx)(e.a,{href:"https://docs.github.com/en/copilot/customizing-copilot/adding-repository-custom-instructions-for-github-copilot",children:(0,r.jsx)(e.code,{children:".github/copilot-instructions.md"})})," file in your repository and add the prompt to it."]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"prompt",children:"Prompt"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-markdown",children:'# Build Reliable Applications With DBOS\n\n## Guidelines\n\n- Respond in a friendly and concise manner\n- Ask clarifying questions when requirements are ambiguous\n- Generate code in Golang using the DBOS library.\n- You MUST import everything used in the code you generate\n- You SHALL keep all code in a single file unless otherwise specified.\n- DBOS does NOT stand for anything.\n\n## Workflow Guidelines\n\nWorkflows provide durable execution so you can write programs that are resilient to any failure.\nWorkflows are comprised of steps, which are ordinary Golang functions called with dbos.RunAsStep.\nWhen using DBOS workflows, you should call any function that performs complex operations or accesses external APIs or services as a step using dbos.RunAsStep.\n\nIf a workflow is interrupted for any reason (e.g., an executor restarts or crashes), when your program restarts the workflow automatically resumes execution from the last completed step.\n\n- If asked to add DBOS to existing code, you MUST ask which function to make a workflow. Do NOT recommend any changes until they have told you what function to make a workflow. Do NOT make a function a workflow unless SPECIFICALLY requested.\n- When making a function a workflow, you should make all functions it calls steps. Do NOT change the functions in any way.\n- Do NOT make functions steps unless they are DIRECTLY called by a workflow.\n- If the workflow function performs a non-deterministic action, you MUST move that action to its own function and make that function a step. Examples of non-deterministic actions include accessing an external API or service, accessing files on disk, generating a random number, of getting the current time.\n- Do NOT start goroutines from workflows or use select in workflows. For any complex parallel execution, you should instead use DBOS.RunWorkflow and DBOS queues to achieve the parallelism.\n- DBOS workflows and steps should NOT have side effects in memory outside of their own scope. They can access global variables, but they should NOT create or update global variables or variables outside their scope.\n- Do NOT call any DBOS context method (DBOS.Send, DBOS.Recv, DBOS.RunWorkflow, DBOS.RunAsStep, DBOS.Sleep, DBOS.SetEvent, DBOS.GetEvent) from a step.\n\n## DBOS Lifecycle Guidelines\n\nDBOS should be installed and imported from the `github.com/dbos-inc/dbos-transact-golang/dbos` package.\n\nDBOS programs MUST have a main file (typically \'main.go\') that creates all objects and workflow functions during startup.\n\nAny DBOS program MUST create and launch a DBOS context in their main function.\nAll workflows must be registered and queues created BEFORE DBOS is launched\n\n```go\nfunc main() {\n    dbosContext, err := dbos.NewDBOSContext(context.Background(), dbos.Config{\n        AppName:     "dbos-starter",\n        DatabaseURL: os.Getenv("DBOS_SYSTEM_DATABASE_URL"),\n    })\n    if err != nil {\n        panic(fmt.Sprintf("Initializing DBOS failed: %v", err))\n    }\n\n    dbos.RegisterWorkflow(dbosContext, workflow)\n\n    err = dbos.Launch(dbosContext)\n    if err != nil {\n        panic(fmt.Sprintf("Launching DBOS failed: %v", err))\n    }\n    defer dbos.Shutdown(dbosContext, 5 * time.Second)\n}\n```\n\nHere is an example main function using Gin:\n\n```go\nimport (\n    "context"\n    "fmt"\n    "net/http"\n    "os"\n    "time"\n\n    "github.com/dbos-inc/dbos-transact-golang/dbos"\n    "github.com/gin-gonic/gin"\n)\n\nfunc main() {\n    dbosContext, err := dbos.NewDBOSContext(context.Background(), dbos.Config{\n        AppName:     "dbos-starter",\n        DatabaseURL: os.Getenv("DBOS_SYSTEM_DATABASE_URL"),\n    })\n    if err != nil {\n        panic(fmt.Sprintf("Initializing DBOS failed: %v", err))\n    }\n\n    dbos.RegisterWorkflow(dbosContext, workflow)\n\n    err = dbos.Launch(dbosContext)\n    if err != nil {\n        panic(fmt.Sprintf("Launching DBOS failed: %v", err))\n    }\n    defer dbos.Shutdown(dbosContext, 5 * time.Second)\n\n    r := gin.Default()\n\n    r.GET("/", func(c *gin.Context) {\n        dbos.RunWorkflow(dbosContext, workflow, "")\n        if err != nil {\n            c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Error in DBOS workflow: %v", err)})\n            return\n        }\n        c.Status(http.StatusOK)\n    })\n\n    r.Run(":8080")\n}\n```\n\n## Workflow and Steps Examples\n\nSimple example:\n\n```go showLineNumbers title="main.go"\npackage main\n\nimport (\n    "context"\n    "fmt"\n    "os"\n    "time"\n\n    "github.com/dbos-inc/dbos-transact-golang/dbos"\n)\n\nfunc workflow(ctx dbos.DBOSContext, _ string) (string, error) {\n    _, err := dbos.RunAsStep(ctx, stepOne)\n    if err != nil {\n        return "failure", err\n    }\n    _, err = dbos.RunAsStep(ctx, stepTwo)\n    if err != nil {\n        return "failure", err\n    }\n    return "success", err\n}\n\nfunc stepOne(ctx context.Context) (string, error) {\n    fmt.Println("Step one completed")\n    return "success", nil\n}\n\nfunc stepTwo(ctx context.Context) (string, error) {\n    fmt.Println("Step two completed")\n    return "success", nil\n}\n\nfunc main() {\n    dbosContext, err := dbos.NewDBOSContext(context.Background(), dbos.Config{\n        AppName:     "dbos-starter",\n        DatabaseURL: os.Getenv("DBOS_SYSTEM_DATABASE_URL"),\n    })\n    if err != nil {\n        panic(fmt.Sprintf("Initializing DBOS failed: %v", err))\n    }\n\n    dbos.RegisterWorkflow(dbosContext, workflow)\n\n    err = dbos.Launch(dbosContext)\n    if err != nil {\n        panic(fmt.Sprintf("Launching DBOS failed: %v", err))\n    }\n    defer dbos.Shutdown(dbosContext, 5 * time.Second)\n\n    handle, err := dbos.RunWorkflow(dbosContext, workflow, "")\n    if err != nil {\n        panic(fmt.Sprintf("Error in DBOS workflow: %v", err))\n    }\n    result, err := handle.GetResult()\n    if err != nil {\n        panic(fmt.Sprintf("Error in DBOS workflow: %v", err))\n    }\n    fmt.Println("Workflow result:", result)\n}\n```\n\nExample with Gin:\n\n```go showLineNumbers title="main.go"\npackage main\n\nimport (\n    "context"\n    "fmt"\n    "net/http"\n    "os"\n    "time"\n\n    "github.com/dbos-inc/dbos-transact-golang/dbos"\n    "github.com/gin-gonic/gin"\n)\n\nfunc workflow(ctx dbos.DBOSContext, _ string) (string, error) {\n    _, err := dbos.RunAsStep(ctx, stepOne)\n    if err != nil {\n        return "failure", err\n    }\n    for range 5 {\n        fmt.Println("Press Control + C to stop the app...")\n        dbos.Sleep(ctx, time.Second)\n    }\n    _, err = dbos.RunAsStep(ctx, stepTwo)\n    if err != nil {\n        return "failure", err\n    }\n    return "success", err\n}\n\nfunc stepOne(ctx context.Context) (string, error) {\n    fmt.Println("Step one completed")\n    return "success", nil\n}\n\nfunc stepTwo(ctx context.Context) (string, error) {\n    fmt.Println("Step two completed")\n    return "success", nil\n}\n\nfunc main() {\n    dbosContext, err := dbos.NewDBOSContext(context.Background(), dbos.Config{\n        AppName:     "dbos-starter",\n        DatabaseURL: os.Getenv("DBOS_SYSTEM_DATABASE_URL"),\n    })\n    if err != nil {\n        panic(fmt.Sprintf("Initializing DBOS failed: %v", err))\n    }\n\n    dbos.RegisterWorkflow(dbosContext, workflow)\n\n    err = dbos.Launch(dbosContext)\n    if err != nil {\n        panic(fmt.Sprintf("Launching DBOS failed: %v", err))\n    }\n    defer dbos.Shutdown(dbosContext, 5 * time.Second)\n\n    r := gin.Default()\n\n    r.GET("/", func(c *gin.Context) {\n        dbos.RunWorkflow(dbosContext, workflow, "")\n        if err != nil {\n            c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Error in DBOS workflow: %v", err)})\n            return\n        }\n        c.Status(http.StatusOK)\n    })\n\n    r.Run(":8080")\n}\n```\n\nExample with queues:\n\n```go showLineNumbers title="main.go"\npackage main\n\nimport (\n    "context"\n    "fmt"\n    "net/http"\n    "os"\n    "time"\n\n    "github.com/dbos-inc/dbos-transact-golang/dbos"\n    "github.com/gin-gonic/gin"\n)\n\nfunc taskWorkflow(ctx dbos.DBOSContext, i int) (int, error) {\n    dbos.Sleep(ctx, 5*time.Second)\n    fmt.Printf("Task %d completed\\n", i)\n    return i, nil\n}\n\nfunc queueWorkflow(ctx dbos.DBOSContext, queue dbos.WorkflowQueue) (int, error) {\n    fmt.Println("Enqueuing tasks")\n    handles := make([]dbos.WorkflowHandle[int], 10)\n    for i := range 10 {\n        handle, err := dbos.RunWorkflow(ctx, taskWorkflow, i, dbos.WithQueue(queue.Name))\n        if err != nil {\n            return 0, err\n        }\n        handles[i] = handle\n    }\n    results := make([]int, 10)\n    for i, handle := range handles {\n        result, err := handle.GetResult()\n        if err != nil {\n            return 0, err\n        }\n        results[i] = result\n    }\n    fmt.Printf("Successfully completed %d tasks\\n", len(results))\n    return len(results), nil\n}\n\nfunc main() {\n    dbosContext, err := dbos.NewDBOSContext(context.Background(), dbos.Config{\n        AppName:     "dbos-starter",\n        DatabaseURL: os.Getenv("DBOS_SYSTEM_DATABASE_URL"),\n    })\n    if err != nil {\n        panic(fmt.Sprintf("Initializing DBOS failed: %v", err))\n    }\n\n    queue := dbos.NewWorkflowQueue(dbosContext, "queue")\n    dbos.RegisterWorkflow(dbosContext, queueWorkflow)\n    dbos.RegisterWorkflow(dbosContext, taskWorkflow)\n\n    err = dbos.Launch(dbosContext)\n    if err != nil {\n        panic(fmt.Sprintf("Launching DBOS failed: %v", err))\n    }\n    defer dbos.Shutdown(dbosContext, 5 * time.Second)\n\n    r := gin.Default()\n\n    r.GET("/", func(c *gin.Context) {\n        dbos.RunWorkflow(dbosContext, queueWorkflow, queue)\n        if err != nil {\n            c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Error in DBOS workflow: %v", err)})\n            return\n        }\n        c.Status(http.StatusOK)\n    })\n\n    r.Run(":8080")\n}\n```\n\n## Workflow Documentation\n\nWorkflows provide **durable execution** so you can write programs that are **resilient to any failure**.\nWorkflows are comprised of steps, which wrap ordinary Go functions.\nIf a workflow is interrupted for any reason (e.g., an executor restarts or crashes), when your program restarts the workflow automatically resumes execution from the last completed step.\n\nTo write a workflow, register a Go function with `RegisterWorkflow`.\nWorkflow registration must happen before launching the DBOS context with `dbos.Launch()`\nThe function\'s signature must match:\n\n```go\ntype Workflow[P any, R any] func(ctx DBOSContext, input P) (R, error)\n```\n\nIn other words, a workflow must take in a DBOS context and one other input of any serializable (json-encodable) type and must return one output of any serializable type and error.\n\nFor example:\n\n```go\nfunc stepOne(ctx context.Context) (string, error) {\n    fmt.Println("Step one completed")\n    return "success", nil\n}\n\nfunc stepTwo(ctx context.Context) (string, error) {\n    fmt.Println("Step two completed")\n    return "success", nil\n}\n\nfunc workflow(ctx dbos.DBOSContext, _ string) (string, error) {\n    _, err := dbos.RunAsStep(ctx, stepOne)\n    if err != nil {\n        return "failure", err\n    }\n    _, err = dbos.RunAsStep(ctx, stepTwo)\n    if err != nil {\n        return "failure", err\n    }\n    return "success", err\n}\n\nfunc main() {\n    ... // Create the DBOS context\n    dbos.RegisterWorkflow(dbosContext, workflow)\n    ... // Launch DBOS after registering all workflows\n}\n```\n\nCall workflows with `RunWorkflow`.\nThis starts the workflow in the background and returns a workflow handle from which you can access information about the workflow or wait for it to complete and return its result.\n\nHere\'s an example:\n\n```go\nfunc runWorkflowExample(dbosContext dbos.DBOSContext, input string) error {\n    handle, err := dbos.RunWorkflow(dbosContext, workflow, input)\n    if err != nil {\n        return err\n    }\n    result, err := handle.GetResult()\n    if err != nil {\n        return err\n    }\n    fmt.Println("Workflow result:", result)\n    return nil\n}\n```\n\n### Workflow IDs and Idempotency\n\nEvery time you execute a workflow, that execution is assigned a unique ID, by default a UUID.\nYou can access this ID through `GetWorkflowID`, or from the handle\'s `GetWorkflowID` method.\nWorkflow IDs are useful for communicating with workflows and developing interactive workflows.\n\nYou can set the workflow ID of a workflow using `WithWorkflowID` when calling `RunWorkflow`.\nWorkflow IDs must be **globally unique** for your application.\nAn assigned workflow ID acts as an idempotency key: if a workflow is called multiple times with the same ID, it executes only once.\nThis is useful if your operations have side effects like making a payment or sending an email.\nFor example:\n\n```go\nfunc exampleWorkflow(ctx dbos.DBOSContext, input string) (string, error) {\n    workflowID, err := dbos.GetWorkflowID(ctx)\n    if err != nil {\n        return "", err\n    }\n    fmt.Printf("Running workflow with ID: %s\\n", workflowID)\n    // ...\n    return "success", nil\n}\n\nfunc example(dbosContext dbos.DBOSContext, input string) error {    \n    myID := "unique-workflow-id-123"\n    handle, err := dbos.RunWorkflow(dbosContext, exampleWorkflow, input, dbos.WithWorkflowID(myID))\n    if err != nil {\n        log.Fatal(err)\n    }\n    result, err := handle.GetResult()\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println("Result:", result)\n    return nil\n}\n```\n\n### Determinism\n\nWorkflows are in most respects normal Go functions.\nThey can have loops, branches, conditionals, and so on.\nHowever, a workflow function must be **deterministic**: if called multiple times with the same inputs, it should invoke the same steps with the same inputs in the same order (given the same return values from those steps).\nIf you need to perform a non-deterministic operation like accessing the database, calling a third-party API, generating a random number, or getting the local time, you shouldn\'t do it directly in a workflow function.\nInstead, you should do all database operations in non-deterministic operations in steps.\n\n:::warning\nGo\'s goroutine scheduler and `select` operation are non-deterministic. You should use them only inside steps.\n:::\n\nFor example, **don\'t do this**:\n\n```go\nfunc exampleWorkflow(ctx dbos.DBOSContext, input string) (string, error) {\n    randomChoice := rand.Intn(2)\n    if randomChoice == 0 {\n        return dbos.RunAsStep(ctx, stepOne)\n    } else {\n        return dbos.RunAsStep(ctx, stepTwo)\n    }\n}\n```\n\nInstead, do this:\n\n```go\nfunc generateChoice(ctx context.Context) (int, error) {\n    return rand.Intn(2), nil\n}\n\nfunc exampleWorkflow(ctx dbos.DBOSContext, input string) (string, error) {\n    randomChoice, err := dbos.RunAsStep(ctx, generateChoice)\n    if err != nil {\n        return "", err\n    }\n    if randomChoice == 0 {\n        return dbos.RunAsStep(ctx, stepOne)\n    } else {\n        return dbos.RunAsStep(ctx, stepTwo)\n    }\n}\n```\n\n### Workflow Timeouts\n\nYou can set a timeout for a workflow using its input `DBOSContext`. Use `WithTimeout` to obtain a cancellable `DBOSContext`, as you would with a normal `context.Context`.\n\nWhen the timeout expires, the workflow and all its children are cancelled. Cancelling a workflow sets its status to CANCELLED and preempts its execution at the beginning of its next step. You can detach a child workflow by passing it an uncancellable context, which you can obtain with `WithoutCancel`.\n\nTimeouts are **start-to-completion**: if a workflow is enqueued, the timeout does not begin until the workflow is dequeued and starts execution. Also, timeouts are durable: they are stored in the database and persist across restarts, so workflows can have very long timeouts.\n\n```go\nfunc exampleWorkflow(ctx dbos.DBOSContext, input string) (string, error) {}\n\ntimeoutCtx, cancelFunc := dbos.WithTimeout(dbosCtx, 12*time.Hour)\nhandle, err := RunWorkflow(timeoutCtx, exampleWorkflow, "wait-for-cancel")\n```\n\nYou can also manually cancel the workflow by calling its `cancel` function (or calling CancelWorkflow).\n\n\n### Durable Sleep\n\nYou can use `Sleep` to put your workflow to sleep for any period of time.\nThis sleep is **durable**&mdash;DBOS saves the wakeup time in the database so that even if the workflow is interrupted and restarted multiple times while sleeping, it still wakes up on schedule.\n\nSleeping is useful for scheduling a workflow to run in the future (even days, weeks, or months from now).\nFor example:\n\n```go\nfunc runTask(ctx dbos.DBOSContext, task string) (string, error) {\n\t// Execute the task...\n\treturn "task completed", nil\n}\n\nfunc exampleWorkflow(ctx dbos.DBOSContext, input struct {\n\tTimeToSleep time.Duration\n\tTask        string\n}) (string, error) {\n\t// Sleep for the specified duration\n\t_, err := dbos.Sleep(ctx, input.TimeToSleep)\n\tif err != nil {\n\t\treturn "", err\n\t}\n\n\t// Execute the task after sleeping\n\tresult, err := dbos.RunAsStep(\n\t\tctx,\n\t\tfunc(stepCtx context.Context) (string, error) {\n\t\t\treturn runTask(ctx, input.Task)\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn "", err\n\t}\n\n\treturn result, nil\n}\n\n```\n\n### Scheduled Workflows\n\nYou can schedule workflows to run automatically at specified times using cron syntax with seconds precision.\nScheduled workflows are useful for running recurring tasks like data backups, report generation, or cleanup operations.\n\nTo create a scheduled workflow, use `WithSchedule` when registering your workflow.\nThe workflow must have a single `time.Time` input parameter, representing the scheduled execution time.\n\n**Example syntax:**\n\n```go\nfunc frequentTask(ctx dbos.DBOSContext, scheduledTime time.Time) (string, error) {\n    fmt.Printf("Performing a scheduled task at: %s\\n", scheduledTime.Format(time.RFC3339))\n    ... // Perform a scheduled task operations\n    return result, nil\n}\n\nfunc dailyBackup(ctx dbos.DBOSContext, scheduledTime time.Time) (string, error) {\n    fmt.Printf("Running daily backup at: %s\\n", scheduledTime.Format(time.RFC3339))\n    ... // Perform daily backup operations\n    return result, nil\n}\n\nfunc main() {\n    dbosContext := ... // Initialize DBOS\n\n    // Register a workflow to run daily at 2:00 AM\n    dbos.RegisterWorkflow(dbosContext, dailyBackup, \n        dbos.WithSchedule("0 0 2 * * *")) // Cron: daily at 2:00 AM\n    \n    // Register a workflow to run every 15 minutes\n    dbos.RegisterWorkflow(dbosContext, frequentTask,\n        dbos.WithSchedule("0 */15 * * * * ")) // Cron: every 15 minutes\n    \n    // Launch DBOS - scheduled workflows will start automatically\n    err := dbos.Launch(dbosContext)\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n```\n\n### Workflow Versioning and Recovery\n\nBecause DBOS recovers workflows by re-executing them using information saved in the database, a workflow cannot safely be recovered if its code has changed since the workflow was started.\nTo guard against this, DBOS _versions_ applications and their workflows.\nWhen DBOS is launched, it computes an application version from a hash of the application source code (this can be overridden through configuration).\nAll workflows are tagged with the application version on which they started.\n\nWhen DBOS tries to recover workflows, it only recovers workflows whose version matches the current application version.\nThis prevents unsafe recovery of workflows that depend on different code.\nYou cannot change the version of a workflow, but you can use `ForkWorkflow` to restart a workflow from a specific step on a specific code version.\n\nFor more information on managing workflow recovery when self-hosting production DBOS applications, check out the guide.\n\n\n## Steps\n\nWhen using DBOS workflows, you should call any function that performs complex operations or accesses external APIs or services as a _step_.\nIf a workflow is interrupted, upon restart it automatically resumes execution from the **last completed step**.\n\nYou can use `RunAsStep` to call a function as a step.\nFor a function to be used as a step, it should return a serializable (json-encodable) value and an error and have this signature:\n\n```go\ntype Step[R any] func(ctx context.Context) (R, error)\n```\n\nHere\'s a simple example:\n\n```go\nfunc generateRandomNumber(ctx context.Context) (int, error) {\n    return rand.Int(), nil\n}\n\nfunc workflowFunction(ctx dbos.DBOSContext, n int) (int, error) {\n    randomNumber, err := dbos.RunAsStep(\n        ctx,\n        generateRandomNumber,\n        dbos.WithStepName("generateRandomNumber"),\n    )\n    if err != nil {\n        return 0, err\n    }\n    return randomNumber, nil\n}\n```\n\nYou can pass arguments into a step by wrapping it in an anonymous function, like this:\n\n```go\nfunc generateRandomNumber(ctx context.Context, n int) (int, error) {\n    return rand.IntN(n), nil\n}\n\nfunc workflowFunction(ctx dbos.DBOSContext, n int) (int, error) {\n    randomNumber, err := dbos.RunAsStep(\n        ctx,\n        func(stepCtx context.Context) (int, error) {\n            return generateRandomNumber(stepCtx, n)\n        },\n        dbos.WithStepName("generateRandomNumber")\n    )\n    if err != nil {\n        return 0, err\n    }\n    return randomNumber, nil\n}\n```\n\nYou should make a function a step if you\'re using it in a DBOS workflow and it performs a **nondeterministic** operation.\nA nondeterministic operation is one that may return different outputs given the same inputs.\nCommon nondeterministic operations include:\n\n- Accessing an external API or service, like serving a file from AWS S3, calling an external API like Stripe, or accessing an external data store like Elasticsearch.\n- Accessing files on disk.\n- Generating a random number.\n- Getting the current time.\n\nYou **cannot** call, start, or enqueue workflows from within steps.\nYou also cannot call DBOS methods like `Send` or `SetEvent` from within steps.\nThese operations should be performed from workflow functions.\nYou can call one step from another step, but the called step becomes part of the calling step\'s execution rather than functioning as a separate step.\n\n### Configurable Retries\n\nYou can optionally configure a step to automatically retry any error a set number of times with exponential backoff.\nThis is useful for automatically handling transient failures, like making requests to unreliable APIs.\nRetries are configurable through step options that can be passed to `RunAsStep`.\n\nAvailable retry configuration options include:\n- `WithStepName` - Custom name for the step (default to the Go runtime reflection value)\n- `WithStepMaxRetries` - Maximum number of times this step is automatically retried on failure (default 0)\n- `WithMaxInterval` - Maximum delay between retries (default 5s)\n- `WithBackoffFactor` - Exponential backoff multiplier between retries (default 2.0)\n- `WithBaseInterval` - Initial delay between retries (default 100ms)\n\nFor example, let\'s configure this step to retry failures (such as if the site to be fetched is temporarily down) up to 10 times:\n\n```go\nfunc fetchStep(ctx context.Context, url string) (string, error) {\n    resp, err := http.Get(url)\n    if err != nil {\n        return "", err\n    }\n    defer resp.Body.Close()\n\n    body, err := io.ReadAll(resp.Body)\n    if err != nil {\n        return "", err\n    }\n\n    return string(body), nil\n}\n\nfunc fetchWorkflow(ctx dbos.DBOSContext, inputURL string) (string, error) {\n    return dbos.RunAsStep(\n        ctx,\n        func(stepCtx context.Context) (string, error) {\n            return fetchStep(stepCtx, inputURL)\n        },\n        dbos.WithStepName("fetchFunction"),\n        dbos.WithStepMaxRetries(10),\n        dbos.WithMaxInterval(30*time.Second),\n        dbos.WithBackoffFactor(2.0),\n        dbos.WithBaseInterval(500*time.Millisecond),\n    )\n}\n```\n\nIf a step exhausts all retry attempts, it returns an error to the calling workflow.\n\n## Workflow Communication\n\nDBOS provides a few different ways to communicate with your workflows.\nYou can:\n\n- Send messages to workflows\n- Publish events from workflows for clients to read\n\n\n### Workflow Messaging and Notifications\nYou can send messages to a specific workflow.\nThis is useful for signaling a workflow or sending notifications to it while it\'s running.\n\n<img src={require(\'@site/static/img/workflow-communication/workflow-messages.png\').default} alt="DBOS Steps" width="750" className="custom-img"/>\n\n### Send\n\n```go\nfunc SendP any error\n```\n\nYou can call `Send()` to send a message to a workflow.\nMessages can optionally be associated with a topic and are queued on the receiver per topic.\n\n### Recv\n\n```go\nfunc RecvR any (R, error)\n```\n\nWorkflows can call `Recv()` to receive messages sent to them, optionally for a particular topic.\nEach call to `Recv()` waits for and consumes the next message to arrive in the queue for the specified topic, returning an error if the wait times out.\nIf the topic is not specified, this method only receives messages sent without a topic.\n\n### Messages Example\n\nMessages are especially useful for sending notifications to a workflow.\nFor example, in an e-commerce application, the checkout workflow, after redirecting customers to a secure payments service, must wait for a notification from that service that the payment has finished processing.\n\nTo wait for this notification, the payments workflow uses `Recv()`, executing failure-handling code if the notification doesn\'t arrive in time:\n\n```go\nconst PaymentStatusTopic = "payment_status"\n\nfunc checkoutWorkflow(ctx dbos.DBOSContext, orderData OrderData) (string, error) {\n    // Process initial checkout steps...\n\n    // Wait for payment notification with a 5-minute timeout\n    notification, err := dbos.RecvPaymentNotification\n    if err != nil {\n        ... // Handle timeout or other errors\n    }\n\n    // Handle the notification\n    if notification.Status == "completed" {\n      ... // Handle the notification.\n    } else {\n      ... // Handle a failure\n    }\n}\n```\n\nA webhook waits for the payment processor to send the notification, then uses `Send()` to forward it to the workflow:\n\n```go\nfunc paymentWebhookHandler(w http.ResponseWriter, r *http.Request) {\n    // Parse the notification from the payment processor\n    notification := ...\n    // Retrieve the workflow ID from notification metadata\n    workflowID := ...\n\n    // Send the notification to the waiting workflow\n    err := dbos.Send(dbosContext, workflowID, notification, PaymentStatusTopic)\n    if err != nil {\n        http.Error(w, "Failed to send notification", http.StatusInternalServerError)\n        return\n    }\n}\n```\n\n### Reliability Guarantees\n\nAll messages are persisted to the database, so if `Send` completes successfully, the destination workflow is guaranteed to be able to `Recv` it.\nIf you\'re sending a message from a workflow, DBOS guarantees exactly-once delivery.\n\n### Workflow Events\n\nWorkflows can publish _events_, which are key-value pairs associated with the workflow.\nThey are useful for publishing information about the status of a workflow or to send a result to clients while the workflow is running.\n\n<img src={require(\'@site/static/img/workflow-communication/workflow-events.png\').default} alt="DBOS Steps" width="750" className="custom-img"/>\n\n### SetEvent\n\n```go\nfunc SetEventP any error\n```\n\nAny workflow can call `SetEvent` to publish a key-value pair, or update its value if has already been published.\n\n### GetEvent\n\n```go\nfunc GetEventR any (R, error)\n```\n\nYou can call `GetEvent` to retrieve the value published by a particular workflow ID for a particular key.\nIf the event does not yet exist, this call waits for it to be published, returning an error if the wait times out.\n\n### Events Example\n\nEvents are especially useful for writing interactive workflows that communicate information to their caller.\nFor example, in an e-commerce application, the checkout workflow, after validating an order, directs the customer to a secure payments service to handle credit card processing.\nTo communicate the payments URL to the customer, it uses events.\n\nThe checkout workflow emits the payments URL using `SetEvent()`:\n\n```go\nconst PaymentURLKey = "payment_url"\n\nfunc checkoutWorkflow(ctx dbos.DBOSContext, orderData OrderData) (string, error) {\n    // Process order validation...\n\n    paymentsURL := ...\n    err := dbos.SetEvent(ctx, PaymentURLKey, paymentsURL)\n    if err != nil {\n        return "", fmt.Errorf("failed to set payment URL event: %w", err)\n    }\n\n    // Continue with checkout process...\n}\n```\n\nThe HTTP handler that originally started the workflow uses `GetEvent()` to await this URL, then redirects the customer to it:\n\n```go\nfunc webCheckoutHandler(dbosContext dbos.DBOSContext, w http.ResponseWriter, r *http.Request) {\n    orderData := parseOrderData(r) // Parse order from request\n\n    handle, err := dbos.RunWorkflow(dbosContext, checkoutWorkflow, orderData)\n    if err != nil {\n        http.Error(w, "Failed to start checkout", http.StatusInternalServerError)\n        return\n    }\n\n    // Wait up to 30 seconds for the payment URL event\n    url, err := dbos.GetEventstring, PaymentURLKey, 30*time.Second)\n    if err != nil {\n        // Handle a timeout\n    }\n\n    // Redirect the customer\n}\n```\n\n### Reliability Guarantees\n\nAll events are persisted to the database, so the latest version of an event is always retrievable.\nAdditionally, if `GetEvent` is called in a workflow, the retrieved value is persisted in the database so workflow recovery can use that value, even if the event is later updated.\n\n\n## Queues\n\n\nYou can use queues to run many workflows at once with managed concurrency.\nQueues provide _flow control_, letting you manage how many workflows run at once or how often workflows are started.\n\nTo create a queue, use `NewWorkflowQueue`\n\n```go\nqueue := dbos.NewWorkflowQueue(dbosContext, "example_queue")\n```\n\nYou can then enqueue any workflow using `WithQueue` when calling `RunWorkflow`.\nEnqueuing a function submits it for execution and returns a handle to it.\nQueued tasks are started in first-in, first-out (FIFO) order.\n\n```go\nfunc processTask(ctx dbos.DBOSContext, task string) (string, error) {\n    // Process the task...\n    return fmt.Sprintf("Processed: %s", task), nil\n}\n\nfunc example(dbosContext dbos.DBOSContext, queue dbos.WorkflowQueue) error {\n    // Enqueue a workflow\n    task := "example_task"\n    handle, err := dbos.RunWorkflow(dbosContext, processTask, task, dbos.WithQueue(queue.Name))\n    if err != nil {\n        return err\n    }\n    \n    // Get the result\n    result, err := handle.GetResult()\n    if err != nil {\n        return err\n    }\n    fmt.Println("Task result:", result)\n    return nil\n}\n```\n\n### Queue Example\n\nHere\'s an example of a workflow using a queue to process tasks concurrently:\n\n```go\nfunc taskWorkflow(ctx dbos.DBOSContext, task string) (string, error) {\n    // Process the task...\n    return fmt.Sprintf("Processed: %s", task), nil\n}\n\nfunc queueWorkflow(ctx dbos.DBOSContext, queue dbos.WorkflowQueue) ([]string, error) {\n    // Enqueue each task so all tasks are processed concurrently\n    tasks := []string{"task1", "task2", "task3", "task4", "task5"}\n\n    var handles []dbos.WorkflowHandle[string]\n    for _, task := range tasks {\n        handle, err := dbos.RunWorkflow(ctx, taskWorkflow, task, dbos.WithQueue(queue.Name))\n        if err != nil {\n            return nil, fmt.Errorf("failed to enqueue task %s: %w", task, err)\n        }\n        handles = append(handles, handle)\n    }\n\n    // Wait for each task to complete and retrieve its result\n    var results []string\n    for i, handle := range handles {\n        result, err := handle.GetResult()\n        if err != nil {\n            return nil, fmt.Errorf("task %d failed: %w", i, err)\n        }\n        results = append(results, result)\n    }\n\n    return results, nil\n}\n\nfunc example(dbosContext dbos.DBOSContext, queue dbos.WorkflowQueue) error {\n    handle, err := dbos.RunWorkflow(dbosContext, queueWorkflow, queue)\n    if err != nil {\n        return err\n    }\n\n    results, err := handle.GetResult()\n    if err != nil {\n        return err\n    }\n\n    for _, result := range results {\n        fmt.Println(result)\n    }\n    return nil\n}\n```\n\n### Enqueueing from Another Application\n\nOften, you want to enqueue a workflow from outside your DBOS application.\nFor example, let\'s say you have an API server and a data processing service.\nYou\'re using DBOS to build a durable data pipeline in the data processing service.\nWhen the API server receives a request, it should enqueue the data pipeline for execution on the data processing service.\n\nYou can use the DBOS Client to enqueue workflows from outside your DBOS application by connecting directly to your DBOS application\'s system database.\nSince the DBOS Client is designed to be used from outside your DBOS application, workflow and queue metadata must be specified explicitly.\n\nFor example, this code enqueues the `dataPipeline` workflow on the `pipelineQueue` queue with a `ProcessInput` argument:\n\n```go\ntype ProcessInput struct {\n    TaskID string\n    Data   string\n}\n\ntype ProcessOutput struct {\n    Result string\n    Status string\n}\n\nconfig := dbos.ClientConfig{\n    DatabaseURL: os.Getenv("DBOS_SYSTEM_DATABASE_URL"),\n}\nclient, err := dbos.NewClient(context.Background(), config)\nif err != nil {\n    log.Fatal(err)\n}\ndefer client.Shutdown(5 * time.Second)\n\nhandle, err := dbos.Enqueue[ProcessInput, ProcessOutput](\n    client, \n    "pipelineQueue",\n    "dataPipeline",\n    ProcessInput{TaskID: "task-123", Data: "data"},\n)\nif err != nil {\n    log.Fatal(err)\n}\n```\n\n\n### Managing Concurrency\n\nYou can control how many workflows from a queue run simultaneously by configuring concurrency limits.\nThis helps prevent resource exhaustion when workflows consume significant memory or processing power.\n\n#### Worker Concurrency\n\nWorker concurrency sets the maximum number of workflows from a queue that can run concurrently on a single DBOS process.\nThis is particularly useful for resource-intensive workflows to avoid exhausting the resources of any process.\nFor example, this queue has a worker concurrency of 5, so each process will run at most 5 workflows from this queue simultaneously:\n\n```go\nqueue := dbos.NewWorkflowQueue(dbosContext, "example_queue",  dbos.WithWorkerConcurrency(5))\n```\n\n#### Global Concurrency\n\nGlobal concurrency limits the total number of workflows from a queue that can run concurrently across all DBOS processes in your application.\nFor example, this queue will have a maximum of 10 workflows running simultaneously across your entire application.\n\n:::warning\nWorker concurrency limits are recommended for most use cases.\nTake care when using a global concurrency limit as any `PENDING` workflow on the queue counts toward the limit, including workflows from previous application versions\n:::\n\n```go\nqueue := dbos.NewWorkflowQueue(dbosContext, "example_queue", dbos.WithGlobalConcurrency(10))\n```\n\n### Rate Limiting\n\nYou can set _rate limits_ for a queue, limiting the number of functions that it can start in a given period.\nRate limits are global across all DBOS processes using this queue.\nFor example, this queue has a limit of 100 workflows with a period of 60 seconds, so it may not start more than 100 workflows in 60 seconds:\n\n```go\nqueue := dbos.NewWorkflowQueue(dbosContext, "example_queue", \n    dbos.WithRateLimiter(&dbos.RateLimiter{\n        Limit:  100,\n        Period: 60.0, // 60 seconds\n    }))\n```\n\nRate limits are especially useful when working with a rate-limited API, such as many LLM APIs.\n\n\n### Deduplication\n\nYou can set a deduplication ID for an enqueued workflow using `WithDeduplicationID` when calling `RunWorkflow`.\nAt any given time, only one workflow with a specific deduplication ID can be enqueued in the specified queue.\nIf a workflow with a deduplication ID is currently enqueued or actively executing (status `ENQUEUED` or `PENDING`), subsequent workflow enqueue attempts with the same deduplication ID in the same queue will return an error.\n\nFor example, this is useful if you only want to have one workflow active at a time per user&mdash;set the deduplication ID to the user\'s ID.\n\n**Example syntax:**\n\n```go\nfunc taskWorkflow(ctx dbos.DBOSContext, task string) (string, error) {\n    // Process the task...\n    return "completed", nil\n}\n\nfunc example(dbosContext dbos.DBOSContext, queue dbos.WorkflowQueue) error {\n    task := "example_task"\n    deduplicationID := "user_12345" // Use user ID for deduplication\n    \n    handle, err := dbos.RunWorkflow(\n        dbosContext, taskWorkflow, task,\n        dbos.WithQueue(queue.Name),\n        dbos.WithDeduplicationID(deduplicationID))\n    if err != nil {\n        // Handle deduplication error or other failures\n        return fmt.Errorf("failed to enqueue workflow: %w", err)\n    }\n    \n    result, err := handle.GetResult()\n    if err != nil {\n        return fmt.Errorf("workflow failed: %w", err)\n    }\n    \n    fmt.Printf("Workflow completed: %s\\n", result)\n    return nil\n}\n```\n\n### Priority\n\nYou can set a priority for an enqueued workflow using `WithPriority` when calling `RunWorkflow`.\nWorkflows with the same priority are dequeued in **FIFO (first in, first out)** order. Priority values can range from `1` to `2,147,483,647`, where **a low number indicates a higher priority**.\nIf using priority, you must set `WithPriorityEnabled` on your queue.\n\n:::tip\nWorkflows without assigned priorities have the highest priority and are dequeued before workflows with assigned priorities.\n:::\n\nTo use priorities in a queue, you must enable it when creating the queue:\n\n```go\nqueue := dbos.NewWorkflowQueue(dbosContext, "example_queue", dbos.WithPriorityEnabled())\n```\n\n**Example syntax:**\n\n```go\nfunc taskWorkflow(ctx dbos.DBOSContext, task string) (string, error) {\n    // Process the task...\n    return "completed", nil\n}\n\nfunc example(dbosContext dbos.DBOSContext, queue dbos.WorkflowQueue) error {\n    task := "example_task"\n    priority := uint(10) // Lower number = higher priority\n    \n    handle, err := dbos.RunWorkflow(dbosContext, taskWorkflow, task,\n        dbos.WithQueue(queue.Name),\n        dbos.WithPriority(priority))\n    if err != nil {\n        return err\n    }\n    \n    result, err := handle.GetResult()\n    if err != nil {\n        return fmt.Errorf("workflow failed: %w", err)\n    }\n    \n    fmt.Printf("Workflow completed: %s\\n", result)\n    return nil\n}\n```\n\n\n# Reference\n\nA DBOS Context is at the center of a DBOS-enabled application. Use it to register workflows, queues and perform workflow management tasks.\n\n`DBOSContext` extends Go\'s `context.Context` interface and carries essential state across workflow execution. Workflows and steps receive a new `DBOSContext` spun out of the root `DBOSContext` you manage. In addition, a `DBOSContext` can be used to set workflow timeouts.\n\n## Lifecycle\n### Initialization\n\nYou can create a DBOS context using `NewDBOSContext`, which takes a `Config` object where `AppName` and one of `DatabaseURL` or `SystemDBPool` are mandatory.\n\n```go\nfunc NewDBOSContext(ctx context.Context, inputConfig Config) (DBOSContext, error)\n```\n\n```go\ntype Config struct {\n    AppName            string        // Application name for identification (required)\n    DatabaseURL        string        // DatabaseURL is a PostgreSQL connection string to your system database. Either this or SystemDBPool is required.\n    SystemDBPool       *pgxpool.Pool // SystemDBPool is a connection pool DBOS can use to access your system database. Optional but takes precedence over DatabaseURL if both are provided.\n    DatabaseSchema     string        // Database schema name (defaults to "dbos")\n    Logger             *slog.Logger  // Custom logger instance (defaults to a new slog logger)\n    AdminServer        bool          // Enable Transact admin HTTP server (disabled by default)\n    AdminServerPort    int           // Port for the admin HTTP server (default: 3001)\n    ConductorURL       string        // DBOS conductor service URL (optional)\n    ConductorAPIKey    string        // DBOS conductor API key (optional)\n    ApplicationVersion string        // Application version (optional)\n    ExecutorID         string        // Executor ID (optional)\n}\n```\n\nFor example:\n```go\ndbosContext, err := dbos.NewDBOSContext(context.Background(), dbos.Config{\n    AppName:     "dbos-starter",\n    DatabaseURL: os.Getenv("DBOS_SYSTEM_DATABASE_URL"),\n})\nif err != nil {\n    panic(err)\n}\n```\n\nThe newly created DBOSContext must be launched with `Launch()` before use and should be shut down with Shutdown() at program termination.\n\n### launch\n\n```go\ndbos.Launch(ctx DBOSContext) error\n```\n\nLaunch the following resources managed by a `DBOSContext`:\n- A system database connection pool\n- A workflow scheduler\n- A workflow queue runner\n- (Optionally) an admin server\n- (Optionally) a Conductor connection\n\nIn addition, `Launch()` may perform workflow recovery.\n`Launch()` should be called by your program during startup before running any workflows.\n\n### Shutdown\n```go\ndbos.Shutdown(ctx DBOSContext, timeout time.Duration)\n```\n\nGracefully shutdown the DBOS runtime, waiting for workflows to complete and cleaning up resources. When you shutdown a `DBOSContext`, the underlying `context.Context` will be cancelled, which signals all DBOS resources they should stop executing, including workflows and steps.\n\n**Parameters:**\n- **timeout**: The time to wait for DBOS resources to gracefully terminate.\n\n## Context management\n\n### WithTimeout\n\n```go\nfunc WithTimeout(ctx DBOSContext, timeout time.Duration) (DBOSContext, context.CancelFunc)\n```\n\n`WithTimeout` returns a copy of the DBOS context with a timeout. The returned context will be canceled after the specified duration. See workflow timeouts for usage.\n\n### WithoutCancel\n\n```go\nfunc WithoutCancel(ctx DBOSContext) DBOSContext\n```\n\n`WithoutCancel` returns a copy of the DBOS context that is not canceled when the parent context is canceled. This is useful to detach child workflows from their parent\'s timeout.\n\n## Context metadata\n### GetApplicationVersion\n\n```go\nfunc GetApplicationVersion() string\n```\n\n`GetApplicationVersion` returns the application version for this context.\n\n### GetExecutorID\n\n```go\nfunc GetExecutorID() string\n```\n\n`GetExecutorID` returns the executor ID for this context.\n\n\n## DBOS Methods\n\n### GetEvent\n\n```go\nfunc GetEventR any (R, error)\n```\n\nRetrieve the latest value of an event published by the workflow identified by `targetWorkflowID` to the key `key`.\nIf the event does not yet exist, wait for it to be published, an error if the wait times out.\n\n**Parameters:**\n- **ctx**: The DBOS context.\n- **targetWorkflowID**: The identifier of the workflow whose events to retrieve.\n- **key**: The key of the event to retrieve.\n- **timeout**: A timeout. If the wait times out, return an error.\n\n\n### SetEvent\n\n```go\nfunc SetEventP any error\n```\nCreate and associate with this workflow an event with key `key` and value `value`.\nIf the event already exists, update its value.\nCan only be called from within a workflow.\n\n**Parameters:**\n- **ctx**: The DBOS context.\n- **key**: The key of the event.\n- **message**: The value of the event. Must be serializable.\n\n\n### Send\n\n```go\nfunc SendP any error\n```\nSend a message to the workflow identified by `destinationID`.\nMessages can optionally be associated with a topic.\n\n**Parameters:**\n- **ctx**: The DBOS context.\n- **destinationID**: The workflow to which to send the message.\n- **message**: The message to send. Must be serializable.\n- **topic**: A topic with which to associate the message. Messages are enqueued per-topic on the receiver.\n\n### Recv\n\n```go\nfunc RecvR any (R, error)\n```\n\nReceive and return a message sent to this workflow.\nCan only be called from within a workflow.\nMessages are dequeued first-in, first-out from a queue associated with the topic.\nCalls to `recv` wait for the next message in the queue, returning an error if the wait times out.\n\n**Parameters:**\n- **ctx**: The DBOS context.\n- **topic**: A topic queue on which to wait.\n- **timeoutSeconds**: A timeout in seconds. If the wait times out, return an error.\n\n### Sleep\n\n```go\nfunc Sleep(ctx DBOSContext, duration time.Duration) (time.Duration, error)\n```\n\nSleep for the given duration.\nMay only be called from within a workflow.\nThis sleep is durable&mdash;it records its intended wake-up time in the database so if it is interrupted and recovers, it still wakes up at the intended time.\n\n**Parameters:**\n- **ctx**: The DBOS context.\n- **duration**: The duration to sleep.\n\n### RetrieveWorkflow\n\n```go\nfunc RetrieveWorkflowR any (*workflowPollingHandle[R], error)\n```\n\nRetrieve the handle of a workflow.\n\n**Parameters**:\n- **ctx**: The DBOS context.\n- **workflowID**: The ID of the workflow whose handle to retrieve.\n\n## Workflow Management Methods\n\n### ListWorkflows\n\n```go\nfunc ListWorkflows(ctx DBOSContext, opts ...ListWorkflowsOption) ([]WorkflowStatus, error)\n```\n\nRetrieve a list of `WorkflowStatus` of all workflows matching specified criteria.\n\n**Example usage:**\n\n```go\n// List all successful workflows from the last 24 hours\nworkflows, err := dbos.ListWorkflows(ctx,\n    dbos.WithStatus([]dbos.WorkflowStatusType{dbos.WorkflowStatusSuccess}),\n    dbos.WithStartTime(time.Now().Add(-24*time.Hour)),\n    dbos.WithLimit(100))\nif err != nil {\n    log.Fatal(err)\n}\n\n// List workflows by specific IDs without loading input/output data\nworkflows, err := dbos.ListWorkflows(ctx,\n    dbos.WithWorkflowIDs([]string{"workflow1", "workflow2"}),\n    dbos.WithLoadInput(false),\n    dbos.WithLoadOutput(false))\nif err != nil {\n    log.Fatal(err)\n}\n```\n\n#### WithAppVersion\n\n```go\nfunc WithAppVersion(appVersion string) ListWorkflowsOption\n```\n\nRetrieve workflows tagged with this application version.\n\n\n#### WithEndTime\n\n```go\nfunc WithEndTime(endTime time.Time) ListWorkflowsOption\n```\n\nRetrieve workflows started before this timestamp.\n\n#### WithLimit\n\n```go\nfunc WithLimit(limit int) ListWorkflowsOption\n```\n\nRetrieve up to this many workflows.\n\n#### WithLoadInput\n\n```go\nfunc WithLoadInput(loadInput bool) ListWorkflowsOption\n```\n\nWithLoadInput controls whether to load workflow input data (default: true).\n\n#### WithLoadOutput\n\n```go\nfunc WithLoadOutput(loadOutput bool) ListWorkflowsOption\n```\n\nWithLoadOutput controls whether to load workflow output data (default: true). \n\n#### WithName\n\n```go\nfunc WithName(name string) ListWorkflowsOption\n```\n\nFilter workflows by the specified workflow function name.\n\n#### WithOffset\n\n```go\nfunc WithOffset(offset int) ListWorkflowsOption\n```\n\nSkip this many workflows from the results returned (for pagination).\n\n#### WithSortDesc\n\n```go\nfunc WithSortDesc(sortDesc bool) ListWorkflowsOption\n```\n\nSort the results in descending (true) or ascending (false) order by workflow start time.\n\n#### WithStartTime\n\n```go\nfunc WithStartTime(startTime time.Time) ListWorkflowsOption\n```\n\nRetrieve workflows started after this timestamp.\n\n#### WithStatus\n\n```go\nfunc WithStatus(status []WorkflowStatusType) ListWorkflowsOption\n```\n\nFilter workflows by status. Multiple statuses can be specified.\n\n#### WithUser\n\n```go\nfunc WithUser(user string) ListWorkflowsOption\n```\n\nFilter workflows run by this authenticated user.\n\n#### WithWorkflowIDs\n\n```go\nfunc WithWorkflowIDs(workflowIDs []string) ListWorkflowsOption\n```\n\nFilter workflows by specific workflow IDs.\n\n#### WithWorkflowIDPrefix\n\n```go\nfunc WithWorkflowIDPrefix(prefix string) ListWorkflowsOption\n```\n\nFilter workflows whose IDs start with the specified prefix.\n\n#### WithQueuesOnly\n\n```go\nfunc WithQueuesOnly() ListWorkflowsOption\n```\n\nReturn only workflows that are currently in a queue (queue name is not null, status is `ENQUEUED` or `PENDING`).\n\n### GetWorkflowSteps\n\n```go\nfunc GetWorkflowSteps(ctx DBOSContext, workflowID string) ([]StepInfo, error)\n```\n\nGetWorkflowSteps retrieves the execution steps of a workflow.\nThis is a list of `StepInfo` objects, with the following structure:\n\n```go\ntype StepInfo struct {\n    StepID          int    // The sequential ID of the step within the workflow\n    StepName        string // The name of the step function\n    Output          any    // The output returned by the step (if any)\n    Error           error  // The error returned by the step (if any)\n    ChildWorkflowID string  // If the step starts or retrieves the result of a workflow, its ID\n}\n```\n\n**Parameters:**\n- **ctx**: The DBOS context.\n- **workflowID**: The ID of the workflow to cancel.\n\n### CancelWorkflow\n\n```go\nfunc CancelWorkflow(ctx DBOSContext, workflowID string) error\n```\n\nCancel a workflow. This sets its status to `CANCELLED`, removes it from its queue (if it is enqueued) and preempts its execution (interrupting it at the beginning of its next step).\n\n**Parameters:**\n- **ctx**: The DBOS context.\n- **workflowID**: The ID of the workflow to cancel.\n\n### ResumeWorkflow\n\n```go\nfunc ResumeWorkflowR any (*WorkflowHandle[R], error)\n```\n\nResume a workflow. This immediately starts it from its last completed step. You can use this to resume workflows that are cancelled or have exceeded their maximum recovery attempts. You can also use this to start an enqueued workflow immediately, bypassing its queue.\n\n**Parameters:**\n- **ctx**: The DBOS context.\n- **workflowID**: The ID of the workflow to resume.\n\n### ForkWorkflow\n\n```go\nfunc ForkWorkflowR any (WorkflowHandle[R], error)\n```\n\nStart a new execution of a workflow from a specific step. The input step ID (`startStep`) must match the step number of the step returned by workflow introspection. The specified `startStep` is the step from which the new workflow will start, so any steps whose ID is less than `startStep` will not be re-executed.\n\n**Parameters:**\n- **ctx**: The DBOS context.\n- **input**: A `ForkWorkflowInput` struct where `OriginalWorkflowID` is mandatory.\n\n```go\ntype ForkWorkflowInput struct {\n    OriginalWorkflowID string // Required: The UUID of the original workflow to fork from\n    ForkedWorkflowID   string // Optional: Custom workflow ID for the forked workflow (auto-generated if empty)\n    StartStep          uint   // Optional: Step to start the forked workflow from (default: 0)\n    ApplicationVersion string // Optional: Application version for the forked workflow (inherits from original if empty)\n}\n```\n\n### Workflow Status\n\nSome workflow introspection and management methods return a `WorkflowStatus`.\nThis object has the following definition:\n\n```go\ntype WorkflowStatus struct {\n    ID                 string             `json:"workflow_uuid"`       // Unique identifier for the workflow\n    Status             WorkflowStatusType `json:"status"`              // Current execution status\n    Name               string             `json:"name"`                // Function name of the workflow\n    AuthenticatedUser  *string            `json:"authenticated_user"`  // User who initiated the workflow (if applicable)\n    AssumedRole        *string            `json:"assumed_role"`        // Role assumed during execution (if applicable)\n    AuthenticatedRoles *string            `json:"authenticated_roles"` // Roles available to the user (if applicable)\n    Output             any                `json:"output"`              // Workflow output (available after completion)\n    Error              error              `json:"error"`               // Error information (if status is ERROR)\n    ExecutorID         string             `json:"executor_id"`         // ID of the executor running this workflow\n    CreatedAt          time.Time          `json:"created_at"`          // When the workflow was created\n    UpdatedAt          time.Time          `json:"updated_at"`          // When the workflow status was last updated\n    ApplicationVersion string             `json:"application_version"` // Version of the application that created this workflow\n    ApplicationID      string             `json:"application_id"`      // Application identifier\n    Attempts           int                `json:"attempts"`            // Number of execution attempts\n    QueueName          string             `json:"queue_name"`          // Queue name (if workflow was enqueued)\n    Timeout            time.Duration      `json:"timeout"`             // Workflow timeout duration\n    Deadline           time.Time          `json:"deadline"`            // Absolute deadline for workflow completion\n    StartedAt          time.Time          `json:"started_at"`          // When the workflow execution actually started\n    DeduplicationID    string             `json:"deduplication_id"`    // Deduplication identifier (if applicable)\n    Input              any                `json:"input"`               // Input parameters passed to the workflow\n    Priority           int                `json:"priority"`            // Execution priority (lower numbers have higher priority)\n}\n```\n\n#### WorkflowStatusType\n\nThe `WorkflowStatusType` represents the execution status of a workflow:\n\n```go\ntype WorkflowStatusType string\n\nconst (\n    WorkflowStatusPending                     WorkflowStatusType = "PENDING"                        // Workflow is running or ready to run\n    WorkflowStatusEnqueued                    WorkflowStatusType = "ENQUEUED"                       // Workflow is queued and waiting for execution\n    WorkflowStatusSuccess                     WorkflowStatusType = "SUCCESS"                        // Workflow completed successfully\n    WorkflowStatusError                       WorkflowStatusType = "ERROR"                          // Workflow completed with an error\n    WorkflowStatusCancelled                   WorkflowStatusType = "CANCELLED"                      // Workflow was cancelled (manually or due to timeout)\n    WorkflowStatusMaxRecoveryAttemptsExceeded WorkflowStatusType = "MAX_RECOVERY_ATTEMPTS_EXCEEDED" // Workflow exceeded maximum retry attempts\n)\n```\n\n## DBOS Variables\n\n### GetWorkflowID\n\n```go\nfunc GetWorkflowID(ctx DBOSContext) (string, error)\n```\n\nReturn the ID of the current workflow, if in a workflow. Returns an error if not called from within a workflow context.\n\n**Parameters:**\n- **ctx**: The DBOS context.\n\n### GetStepID\n\n```go\nfunc GetStepID(ctx DBOSContext) (string, error)\n```\n\nReturn the unique ID of the current step within a workflow. Returns an error if not called from within a step context.\n\n**Parameters:**\n- **ctx**: The DBOS context.\n\n\nWorkflow queues allow you to ensure that workflow functions will be run, without starting them immediately.\nQueues are useful for controlling the number of workflows run in parallel, or the rate at which they are started.\n\nAll queues should be created before DBOS is launched.\n\n### NewWorkflowQueue\n\n```go\nfunc NewWorkflowQueue(dbosCtx DBOSContext, name string, options ...queueOption) WorkflowQueue\n```\n\nNewWorkflowQueue creates a new workflow queue with the specified name and configuration options.\nQueues must be created before DBOS is launched.\nYou can enqueue a workflow using the `WithQueue` parameter of `RunWorkflow`.\n\n**Parameters:**\n- **dbosCtx**: The DBOSContext.\n- **name**: The name of the queue.  Must be unique among all queues in the application.\n- **options**: Functional options for the queue, documented below.\n\n**Example Syntax:**\n\n```go\nqueue := dbos.NewWorkflowQueue(ctx, "email-queue",\n    dbos.WithWorkerConcurrency(5),\n    dbos.WithRateLimiter(&dbos.RateLimiter{\n        Limit:  100,\n        Period: 60 * time.Second, // 100 workflows per minute\n    }),\n    dbos.WithPriorityEnabled(),\n)\n\n// Enqueue workflows to this queue:\nhandle, err := dbos.RunWorkflow(ctx, SendEmailWorkflow, emailData, dbos.WithQueue("email-queue"))\n```\n\n#### WithWorkerConcurrency\n\n```go\nfunc WithWorkerConcurrency(concurrency int) queueOption\n```\n\nSet the maximum number of workflows from this queue that may run concurrently within a single DBOS process.\n\n#### WithGlobalConcurrency\n\n```go\nfunc WithGlobalConcurrency(concurrency int) queueOption\n```\n\nSet the maximum number of workflows from this queue that may run concurrently. Defaults to 0 (no limit).\nThis concurrency limit is global across all DBOS processes using this queue.\n\n####  WithMaxTasksPerIteration\n\n```go\nfunc WithMaxTasksPerIteration(maxTasks int) queueOption\n```\n\nSets the maximum number of workflows that can be dequeued in a single iteration.\nThis controls batch sizes for queue processing.\n\n####  WithPriorityEnabled\n\n```go\nfunc WithPriorityEnabled() queueOption\n```\n\nEnable setting priority for workflows on this queue.\n\n####  WithRateLimiter\n\n```go\nfunc WithRateLimiter(limiter *RateLimiter) queueOption\n```\n\n```go\ntype RateLimiter struct {\n    Limit  int     // Maximum number of workflows to start within the period\n    Period time.Duration // Time period for the rate limit\n}\n```\n\nA limit on the maximum number of functions which may be started in a given period.\n\n### RegisterWorkflow\n\n```go\nfunc RegisterWorkflowP any, R any\n```\n\nRegister a function as a DBOS workflow.\nAll workflows must be registered before the context is launched.\n\nWorkflow functions must be compatible with the following signature:\n\n```go\ntype Workflow[P any, R any] func(ctx DBOSContext, input P) (R, error)\n```\n\n**Parameters:**\n- **ctx**: The DBOSContext.\n- **fn**: The workflow function to register.\n- **opts**: Functional options for workflow registration, documented below.\n\n#### WithMaxRetries\n\n```go\nfunc WithMaxRetries(maxRetries int) WorkflowRegistrationOption\n```\n\nConfigure the maximum number of times execution of a workflow may be attempted.\nThis acts as a dead letter queue so that a buggy workflow that crashes its application (for example, by running it out of memory) does not do so infinitely.\nIf a workflow exceeds this limit, its status is set to `MAX_RECOVERY_ATTEMPTS_EXCEEDED` and it may no longer be executed.\n\n#### WithSchedule\n\n```go\nfunc WithSchedule(schedule string) WorkflowRegistrationOption\n```\n\nRegisters the workflow as a scheduled workflow using cron syntax.\nThe schedule string follows standard cron format with second precision.\nScheduled workflows automatically receive a `time.Time` input parameter. \n\n#### WithWorkflowName\n\n```go\nfunc WithWorkflowName(name string) WorkflowRegistrationOption\n```\n\nRegister a workflow with a custom name.\nIf not provided, the name of the workflow function is used.\n\n### RunWorkflow\n\n```go\nfunc RunWorkflowP any, R any (WorkflowHandle[R], error)\n```\n\nExecute a workflow function.\nThe workflow may execute immediately or be enqueued for later execution based on options.\nReturns a WorkflowHandle that can be used to check the workflow\'s status or wait for its completion and retrieve its results.\n\n**Parameters:**\n- **ctx**: The DBOSContext.\n- **fn**: The workflow function to execute.\n- **input** The input to the workflow function.\n- **opts**: Functional options for workflow execution, documented below.\n\n**Example Syntax**:\n\n```go\nfunc workflow(ctx dbos.DBOSContext, input string) (string, error) {\n    return "success", err\n}\n\nfunc example(input string) error {\n    handle, err := dbos.RunWorkflow(dbosContext, workflow, input)\n    if err != nil {\n        return err\n    }\n    result, err := handle.GetResult()\n    if err != nil {\n        return err\n    }\n    fmt.Println("Workflow result:", result)\n    return nil\n}\n```\n\n#### WithWorkflowID\n\n```go\nfunc WithWorkflowID(id string) WorkflowOption\n```\n\nRun the workflow with a custom workflow ID.\nIf not specified, a UUID workflow ID is generated.\n\n#### WithQueue\n\n```go\nfunc WithQueue(queueName string) WorkflowOption\n```\n\nEnqueue the workflow to the specified queue instead of executing it immediately.\nQueued workflows will be dequeued and executed according to the queue\'s configuration.\n\n#### WithDeduplicationID\n\n```go\nfunc WithDeduplicationID(id string) WorkflowOption\n```\n\nSet a deduplication ID for this workflow.\nShould be used alongside `WithQueue`.\nAt any given time, only one workflow with a specific deduplication ID can be enqueued in a given queue.\nIf a workflow with a deduplication ID is currently enqueued or actively executing (status `ENQUEUED` or `PENDING`), subsequent workflow enqueue attempt with the same deduplication ID in the same queue will raise an exception.\n\n#### WithPriority\n\n```go\nfunc WithPriority(priority uint) WorkflowOption\n```\n\nSet a queue priority for the workflow.\nShould be used alongside `WithQueue`.\nWorkflows with the same priority are dequeued in **FIFO (first in, first out)** order.\nPriority values can range from `1` to `2,147,483,647`, where **a low number indicates a higher priority**. \nWorkflows without assigned priorities have the highest priority and are dequeued before workflows with assigned priorities.\n\n#### WithApplicationVersion\n\n```go\nfunc WithApplicationVersion(version string) WorkflowOption\n```\n\nSet the application version for this workflow, overriding the version in DBOSContext.\n\n#### WithAuthenticatedUser\n\n```go\nfunc WithAuthenticatedUser(user string) WorkflowOption\n```\n\nAssociate the workflow execution with a user name. Useful to define workflow identity.\n\n### RunAsStep\n\n```go\nfunc RunAsStepR any (R, error)\n```\n\nExecute a function as a step in a durable workflow.\n\n**Parameters:**\n- **ctx**: The DBOSContext.\n- **fn**: The step to execute, typically wrapped in an anonymous function. Syntax shown below.\n- **opts**: Functional options for step execution, documented below.\n\n**Example Syntax:**\n\nAny Go function can be a step as long as it outputs one gob-encodable value and an error.\nTo pass inputs into a function being called as a step, wrap it in an anonymous function as shown below:\n\n```go\nfunc step(ctx context.Context, input string) (string, error) {\n    output := ...\n    return output\n}\n\nfunc workflow(ctx dbos.DBOSContext, input string) (string, error) {\n    output, err := dbos.RunAsStep(\n        ctx, \n        func(stepCtx context.Context) (string, error) {\n            return step(stepCtx, input)\n        }\n    )\n}\n```\n\n#### WithStepName\n\n```go\nfunc WithStepName(name string) StepOption\n```\n\nSet a custom name for a step.\n\n#### WithStepMaxRetries\n\n```go\nfunc WithStepMaxRetries(maxRetries int) StepOption\n```\n\nSet the maximum number of times this step is automatically retired on failure.\nA value of 0 (the default) indicates no retries.\n\n#### WithMaxInterval\n\n```go\nfunc WithMaxInterval(interval time.Duration) StepOption\n```\n\nWithMaxInterval sets the maximum delay between retries. Default value is 5s.\n\n#### WithBackoffFactor\n\n```go\nfunc WithBackoffFactor(factor float64) StepOption\n```\n\nWithBackoffFactor sets the exponential backoff multiplier between retries. Default value is 2.0. \n\n#### WithBaseInterval\n\n```go\nfunc WithBaseInterval(interval time.Duration) StepOption\n```\n\nWithBaseInterval sets the initial delay between retries. Default value is 100ms. \n\n### WorkflowHandle\n\n```go\ntype WorkflowHandle[R any] interface {\n    GetResult() (R, error)\n    GetStatus() (WorkflowStatus, error)\n    GetWorkflowID() string\n}\n```\n\nWorkflowHandle provides methods to interact with a running or completed workflow.\nThe type parameter `R` represents the expected return type of the workflow.\nHandles can be used to wait for workflow completion, check status, and retrieve results. \n\n#### WorkflowHandle.GetResult\n\n```go\nWorkflowHandle.GetResult(opts ...GetResultOption) (R, error)\n```\n\nWait for the workflow to complete and return its result.\n\n#### WorkflowHandle.GetStatus\n\n```go\nWorkflowHandle.GetStatus() (WorkflowStatus, error)\n```\n\nRetrieve the WorkflowStatus of the workflow.\n\n#### WorkflowHandle.GetWorkflowID\n\n```go\nWorkflowHandle.GetWorkflowID() string\n```\n\nRetrieve the ID of the workflow.\n\n\n`Client` provides a programmatic way to interact with your DBOS application from external code.\n`Client` includes methods similar to `DBOSContext` that can be used outside of a DBOS application.\n\n:::note[]\n`Client` is included in the `dbos` package, the same package that is used by DBOS applications.\nWhere DBOS applications use the `DBOSContext` methods,\nexternal applications use `Client` methods instead.\n:::\n\n```go\ntype Client interface {\n    Enqueue(queueName, workflowName string, input any, opts ...EnqueueOption) (WorkflowHandle[any], error)\n    ListWorkflows(opts ...ListWorkflowsOption) ([]WorkflowStatus, error)\n    Send(destinationID string, message any, topic string) error\n    GetEvent(targetWorkflowID, key string, timeout time.Duration) (any, error)\n    RetrieveWorkflow(workflowID string) (WorkflowHandle[any], error)\n    CancelWorkflow(workflowID string) error\n    ResumeWorkflow(workflowID string) (WorkflowHandle[any], error)\n    ForkWorkflow(input ForkWorkflowInput) (WorkflowHandle[any], error)\n    GetWorkflowSteps(workflowID string) ([]StepInfo, error)\n    Shutdown(timeout time.Duration)\n}\n```\n\n### Constructor\n\n```go\nfunc NewClient(ctx context.Context, config ClientConfig) (Client, error)\n```\n\n**Parameters:**\n- `ctx`: A context for initialization operations\n- `config`: A `ClientConfig` object with connection and application settings\n\n```go\ntype ClientConfig struct {\n    DatabaseURL        string        // DatabaseURL is a PostgreSQL connection string. Either this or SystemDBPool is required.\n    SystemDBPool       *pgxpool.Pool // SystemDBPool is a custom System Database Pool. It\'s optional and takes precedence over DatabaseURL if both are provided.\n    DatabaseSchema string            // Database schema name (defaults to "dbos")\n    Logger             *slog.Logger  // Optional custom logger\n}\n```\n\n**Returns:**\n- A new `Client` instance or an error if initialization fails\n\n**Example syntax:**\n\nThis DBOS client connects to the system database specified in the configuration:\n\n```go\nconfig := dbos.ClientConfig{\n    DatabaseURL: os.Getenv("DBOS_SYSTEM_DATABASE_URL"),\n}\nclient, err := dbos.NewClient(context.Background(), config)\nif err != nil {\n    log.Fatal(err)\n}\ndefer client.Shutdown(5 * time.Second)\n```\n\nA client manages a connection pool to the DBOS system database. Calling `Shutdown` on a client will release the connection pool.\n\n\n### Shutdown\n\n```go\nShutdown(timeout time.Duration)\n```\n\nGracefully shuts down the client and releases the system database connection pool.\n\n**Parameters:**\n- `timeout`: Maximum time to wait for graceful shutdown\n\n## Workflow Interaction Methods\n\n### Enqueue\n\n```go\nfunc Enqueue[P any, R any](\n    c Client, \n    queueName string,\n    workflowName string, \n    input P, \n    opts ...EnqueueOption\n) (WorkflowHandle[R], error)\n```\n\nEnqueue a workflow for processing and return a handle to it, similar to RunWorkflow with the WithQueue option.\nReturns a WorkflowHandle.\n\nWhen enqueuing a workflow from the DBOS client, you must specify the name of the workflow to enqueue (rather than passing a workflow function as with `RunWorkflow`.)\n\nRequired parameters:\n\n* `c`: The DBOS client instance\n* `queueName`: The name of the queue on which to enqueue the workflow\n* `workflowName`: The name of the workflow function being enqueued\n* `input`: The input to pass to the workflow\n\nOptional configuration via `EnqueueOption`:\n\n* `WithEnqueueWorkflowID(id string)`: The unique ID for the enqueued workflow. \nIf left undefined, DBOS Client will generate a UUID. \nPlease see Workflow IDs and Idempotency for more information.\n* `WithEnqueueApplicationVersion(version string)`: The version of your application that should process this workflow. \nIf left undefined, it will use the current application version.\nPlease see Managing Application Versions for more information.\n* `WithEnqueueTimeout(timeout time.Duration)`: Set a timeout for the enqueued workflow. When the timeout expires, the workflow **and all its children** are cancelled (except if the child\'s context has been made uncancellable using `WithoutCancel`). The timeout does not begin until the workflow is dequeued and starts execution.\n* `WithEnqueueDeduplicationID(id string)`: At any given time, only one workflow with a specific deduplication ID can be enqueued in the specified queue. If a workflow with a deduplication ID is currently enqueued or actively executing (status `ENQUEUED` or `PENDING`), subsequent workflow enqueue attempts with the same deduplication ID in the same queue will fail.\n* `WithEnqueuePriority(priority uint)`: The priority of the enqueued workflow in the specified queue. Workflows with the same priority are dequeued in **FIFO (first in, first out)** order. Priority values can range from `1` to `2,147,483,647`, where **a low number indicates a higher priority**. Workflows without assigned priorities have the highest priority and are dequeued before workflows with assigned priorities.\n\n**Example syntax:**\n\n```go\ntype ProcessInput struct {\n    TaskID string\n    Data   string\n}\n\ntype ProcessOutput struct {\n    Result string\n    Status string\n}\n\nhandle, err := dbos.Enqueue[ProcessInput, ProcessOutput](\n    client, \n    "process_queue",\n    "ProcessWorkflow",\n    ProcessInput{TaskID: "task-123", Data: "data"},\n    dbos.WithEnqueueTimeout(30 * time.Minute),\n    dbos.WithEnqueuePriority(5),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\nresult, err := handle.GetResult()\nif err != nil {\n    log.Printf("Workflow failed: %v", err)\n} else {\n    log.Printf("Result: %+v", result)\n}\n```\n\n### RetrieveWorkflow\n\n```go\nRetrieveWorkflow(workflowID string) (WorkflowHandle[any], error)\n```\n\nRetrieve the handle of a workflow with identity `workflowID`.\nSimilar to `RetrieveWorkflow`.\n\n**Parameters:**\n- `workflowID`: The identifier of the workflow whose handle to retrieve\n\n**Returns:**\n- The WorkflowHandle of the workflow whose ID is `workflowID`\n\n### Send\n\n```go\nSend(destinationID string, message any, topic string) error\n```\n\nSends a message to a specified workflow. Similar to `Send`.\n\n**Parameters:**\n- `destinationID`: The workflow to which to send the message\n- `message`: The message to send. Must be serializable\n- `topic`: A topic with which to associate the message. Messages are enqueued per-topic on the receiver\n\n### GetEvent\n\n```go\nGetEvent(targetWorkflowID, key string, timeout time.Duration) (any, error)\n```\n\nRetrieve the latest value of an event published by the workflow identified by `targetWorkflowID` to the key `key`.\nIf the event does not yet exist, wait for it to be published, returning an error if the wait times out.\nSimilar to `GetEvent`.\n\n**Parameters:**\n- `targetWorkflowID`: The identifier of the workflow whose events to retrieve\n- `key`: The key of the event to retrieve\n- `timeout`: A timeout duration. If the wait times out, return an error\n\n**Returns:**\n- The value of the event published by `targetWorkflowID` with name `key`, or an error if the wait times out\n\n## Workflow Management Methods\n\n### ListWorkflows\n\n```go\nListWorkflows(opts ...ListWorkflowsOption) ([]WorkflowStatus, error)\n```\n\nRetrieve a list of `WorkflowStatus` of all workflows matching specified criteria.\nSimilar to `ListWorkflows`.\n\n**Options:**\nOptions are provided via `ListWorkflowsOption` functions. See `ListWorkflows` for available options.\n\n:::warning\nThe client `ListWorkflows` method does not include workflow inputs and outputs in its results.\n:::\n\n### GetWorkflowSteps\n\n```go\nGetWorkflowSteps(workflowID string) ([]StepInfo, error)\n```\n\nList the steps of a given workflow. Returned entries do not include step outputs.\n\n### CancelWorkflow\n\n```go\nCancelWorkflow(workflowID string) error\n```\n\nCancel a workflow.\nThis sets its status to `CANCELLED`, removes it from its queue (if it is enqueued) and preempts its execution (interrupting it at the beginning of its next step).\nSimilar to `CancelWorkflow`.\n\n### ResumeWorkflow\n\n```go\nResumeWorkflow(workflowID string) (WorkflowHandle[any], error)\n```\n\nResume a workflow.\nThis immediately starts it from its last completed step.\nYou can use this to resume workflows that are cancelled or have exceeded their maximum recovery attempts.\nYou can also use this to start an enqueued workflow immediately, bypassing its queue.\nSimilar to `ResumeWorkflow`.\n\n### ForkWorkflow\n\n```go\nForkWorkflow(input ForkWorkflowInput) (WorkflowHandle[any], error)\n```\n\nSimilar to `ForkWorkflow`.\n'})})]})}function f(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>a});var o=t(6540);const r={},i=o.createContext(r);function s(n){const e=o.useContext(i);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),o.createElement(i.Provider,{value:e},n.children)}}}]);