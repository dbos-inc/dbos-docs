"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[7123],{4077:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"java/tutorials/upgrading-workflows","title":"Upgrading Workflow Code","description":"A challenge encountered when operating long-running durable workflows in production is how to deploy breaking changes without disrupting in-progress workflows.","source":"@site/docs/java/tutorials/upgrading-workflows.md","sourceDirName":"java/tutorials","slug":"/java/tutorials/upgrading-workflows","permalink":"/java/tutorials/upgrading-workflows","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":65,"frontMatter":{"sidebar_position":65,"title":"Upgrading Workflow Code","toc_max_heading_level":3},"sidebar":"tutorialSidebar","previous":{"title":"Workflow Management","permalink":"/java/tutorials/workflow-management"},"next":{"title":"Scheduled Workflows","permalink":"/java/tutorials/scheduled-workflows"}}');var t=o(4848),a=o(8453);const s={sidebar_position:65,title:"Upgrading Workflow Code",toc_max_heading_level:3},i=void 0,c={},l=[{value:"Patching",id:"patching",level:2},{value:"Deprecating and Removing Patches",id:"deprecating-and-removing-patches",level:3},{value:"How Patching Works",id:"how-patching-works",level:3},{value:"Versioning",id:"versioning",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["A challenge encountered when operating long-running durable workflows in production is ",(0,t.jsx)(n.strong,{children:"how to deploy breaking changes without disrupting in-progress workflows."}),"\nA breaking change to a workflow is one that changes which steps are run, or the order in which the steps are run.\nIf a breaking change was made to a workflow and that workflow is replayed by the recovery system, the checkpoints created by the previous version of the code may not match the steps called by the workflow in the new version of the code, causing recovery to fail."]}),"\n",(0,t.jsxs)(n.p,{children:["DBOS supports two strategies for safely upgrading workflow code: ",(0,t.jsx)(n.strong,{children:"patching"})," and ",(0,t.jsx)(n.strong,{children:"versioning"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"patching",children:"Patching"}),"\n",(0,t.jsxs)(n.p,{children:["In patching, the result of a call to ",(0,t.jsx)(n.a,{href:"/java/reference/workflows-steps#patch",children:(0,t.jsx)(n.code,{children:"DBOS.patch()"})})," is used to conditionally execute the new code.\n",(0,t.jsx)(n.code,{children:"DBOS.patch()"})," returns ",(0,t.jsx)(n.code,{children:"true"})," for new calls (those executing after the breaking change) and ",(0,t.jsx)(n.code,{children:"false"})," for old calls (those that executed before the breaking change).\nTherefore, if ",(0,t.jsx)(n.code,{children:"DBOS.patch()"})," returns ",(0,t.jsx)(n.code,{children:"true"}),", the workflow should follow the new code path, otherwise it must follow the prior codepath."]}),"\n",(0,t.jsx)(n.p,{children:"To use patching, you must enable it in the configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'var config = DBOSConfig.defaults("my-app-name").withEnablePatching();\n'})}),"\n",(0,t.jsx)(n.p,{children:"For example, let's say our original workflow is:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@Workflow\npublic int workflow() {\n  DBOS.runStep(() -> foo(), "foo");\n  DBOS.runStep(() -> bar(), "bar");\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["We want to replace the call to ",(0,t.jsx)(n.code,{children:"foo()"})," with a call to ",(0,t.jsx)(n.code,{children:"baz()"}),".\nThis is a breaking change because it changes what steps run.\nWe can make this breaking change safely using a patch:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@Workflow\npublic int workflow() {\n  if (DBOS.patch("use-baz")) {\n    DBOS.runStep(() -> baz(), "baz");\n  } else {\n    DBOS.runStep(() -> foo(), "foo");\n  }\n  \n  DBOS.runStep(() -> bar(), "bar");\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Now, new workflows will run ",(0,t.jsx)(n.code,{children:"baz()"}),", while old workflows will reexecute ",(0,t.jsx)(n.code,{children:"foo()"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"deprecating-and-removing-patches",children:"Deprecating and Removing Patches"}),"\n",(0,t.jsx)(n.p,{children:"Patches add complexity and runtime overhead; fortunately they don't need to stay in your code forever.\nOnce all workflows that started before you deployed the patch are complete, you can safely remove patches from your code."}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["You can use the ",(0,t.jsx)(n.a,{href:"/java/tutorials/workflow-management#listing-workflows",children:"list workflows APIs"})," to see what workflows are still active."]})}),"\n",(0,t.jsxs)(n.p,{children:["First, you must deprecate the patch with ",(0,t.jsx)(n.a,{href:"/java/reference/methods#deprecatepatch",children:(0,t.jsx)(n.code,{children:"DBOS.deprecatePatch()"})}),"\n",(0,t.jsx)(n.code,{children:"DBOS.deprecatePatch"})," must be used for a transition period prior to fully removing the patch, as it allows coexistence with any ongoing workflows that used ",(0,t.jsx)(n.code,{children:"DBOS.patch()"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"For example, here's how to deprecate the patch above:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@Workflow\npublic int workflow() {\n  if (DBOS.deprecatePatch("use-baz")) {\n    DBOS.runStep(() -> baz(), "baz");\n  }\n  \n  DBOS.runStep(() -> bar(), "bar");\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Then, when all workflows that started before you deprecated the patch are complete, you can remove the patch entirely:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@Workflow\npublic int workflow() {\n  DBOS.runStep(() -> baz(), "baz");\n  DBOS.runStep(() -> bar(), "bar");\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If any mistakes happen during the process (a breaking change is not patched, or a patch is deprecated or removed prematurely), the workflow will throw a ",(0,t.jsx)(n.code,{children:"DBOSUnexpectedStepError"})," pointing to the step where the problem occurred."]}),"\n",(0,t.jsx)(n.h3,{id:"how-patching-works",children:"How Patching Works"}),"\n",(0,t.jsxs)(n.p,{children:["Under the hood, when you call ",(0,t.jsx)(n.code,{children:"DBOS.patch()"}),' from a workflow, it attempts to insert a "patch marker" at its current point in your workflow history (this is a new row in the ',(0,t.jsx)(n.code,{children:"operation_outputs"})," table in your database).\nIf it successfully inserts the patch marker or if the patch marker is already present, then the workflow should take the patch codepath.\nIf there is already a record present in this point in your workflow history and it is not a patch marker, then the workflow must be old (it already continued past this point with old code), and ",(0,t.jsx)(n.code,{children:"DBOS.patch()"})," returns ",(0,t.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["When you deprecate a patch with ",(0,t.jsx)(n.code,{children:"DBOS.deprecatePatch()"}),", new workflows no longer insert patch markers into their workflow history.\nHowever, if a workflow contains the patch marker in its history, it continues past that patch marker, safely ignoring it.\nOnce all workflows with patch markers are complete, the patch may be safely removed."]}),"\n",(0,t.jsx)(n.h2,{id:"versioning",children:"Versioning"}),"\n",(0,t.jsxs)(n.p,{children:["When using versioning, DBOS ",(0,t.jsx)(n.strong,{children:"versions"})," applications and workflows, and only continues workflow execution with the same application version that started the workflow.\nAll workflows are tagged with the application version on which they started.\nBy default, application version is automatically computed from a hash of workflow source code.\nHowever, you can set your own version through configuration."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'var config = DBOSConfig.defaults("my-app-name").withAppVersion("1.0.0");\n'})}),"\n",(0,t.jsx)(n.p,{children:"When DBOS tries to recover workflows, it only recovers workflows whose version matches the current application version.\nThis prevents recovery of workflows that depend on different code."}),"\n",(0,t.jsxs)(n.p,{children:["When using versioning, we recommend ",(0,t.jsx)(n.strong,{children:"blue-green"})," code upgrades:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When deploying a new version of your code, launch new processes running your new code version, but retain some processes running your old code version."}),"\n",(0,t.jsx)(n.li,{children:'Direct new traffic to your new processes while your old processes "drain" and complete all workflows of the old code version.'}),"\n",(0,t.jsxs)(n.li,{children:["Then, once all workflows of the old version are complete (you can use ",(0,t.jsx)(n.a,{href:"/java/reference/methods#dboslistworkflows",children:(0,t.jsx)(n.code,{children:"DBOS.listWorkflows"})})," to check), you can retire the old code version."]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>i});var r=o(6540);const t={},a=r.createContext(t);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);