"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[860],{5335:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>u});const o=JSON.parse('{"id":"explanations/why-dbos-agents","title":"Why DBOS for Agents","description":"DBOS provides lightweight durable workflows for your AI agents.","source":"@site/docs/explanations/why-dbos-agents.md","sourceDirName":"explanations","slug":"/explanations/why-dbos-agents","permalink":"/explanations/why-dbos-agents","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":30,"frontMatter":{"sidebar_position":30,"title":"Why DBOS for Agents","hide_table_of_contents":false},"sidebar":"tutorialSidebar","previous":{"title":"Comparing DBOS and Temporal","permalink":"/explanations/comparing-temporal"},"next":{"title":"Troubleshooting & FAQ","permalink":"/faq"}}');var a=t(4848),i=t(8453);const r={sidebar_position:30,title:"Why DBOS for Agents",hide_table_of_contents:!1},s=void 0,l={},u=[{value:"Debugging Unexpected Agent Behavior",id:"debugging-unexpected-agent-behavior",level:3},{value:"Reliable Human-in-the-Loop",id:"reliable-human-in-the-loop",level:3},{value:"Distributing Work",id:"distributing-work",level:3}];function c(e){const n={a:"a",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["DBOS provides lightweight durable workflows for your AI agents.\nYou install the open-source library and annotate workflows and steps in your agent, either ",(0,a.jsx)(n.a,{href:"/python/integrating-dbos",children:"directly"})," or through integrations with agent frameworks like ",(0,a.jsx)(n.a,{href:"https://ai.pydantic.dev/durable_execution/dbos/",children:"Pydantic AI"})," or ",(0,a.jsx)(n.a,{href:"https://github.com/dbos-inc/dbos-crewai",children:"CrewAI"}),".\nThis usally requires changing only a couple lines of code.\nThen, when your agent runs, DBOS checkpoints its workflows and steps to a database, creating a durable record of its progress that it can use to automatically recover your agents from any failures."]}),"\n",(0,a.jsx)(n.p,{children:"This durability helps solve many tough problems you encounter when building agents or operating them in production.\nHere's how:"}),"\n",(0,a.jsx)(n.h3,{id:"debugging-unexpected-agent-behavior",children:"Debugging Unexpected Agent Behavior"}),"\n",(0,a.jsxs)(n.p,{children:["One of the most common problems you encounter building and operating agents is failures due to ",(0,a.jsx)(n.strong,{children:"unexpected agent behavior"}),".\nFor example, an agent might:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Return a malformed structured output, causing a tool call to fail."}),"\n",(0,a.jsx)(n.li,{children:"Invoke the wrong tool or the right tool with the wrong inputs, causing the tool to fail."}),"\n",(0,a.jsx)(n.li,{children:"Generate an undesirable or inappropriate text output, with potentially business-critical consequences."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"These behaviors are especially hard to diagnose in a complex or long-running agent\u2014if an agent runs for two hours then fails unexpectedly, it's difficult to reproduce the exact set of conditions that caused the failure and test a fix."}),"\n",(0,a.jsx)(n.p,{children:"Durable workflows help by making it easier to observe the root cause of the failure, deterministically reproduce the failure, and test or apply fixes.\nBecause workflows checkpoint the outcome of each step of your workflow, you can review these checkpoints to see the cause of the failure and audit every step that led to it.\nFor example, you might see that your agent failed because of a validation error caused by a malformed structured output:"}),"\n",(0,a.jsx)("img",{src:t(3645).A,alt:"Failing Agent",width:"750",className:"custom-img"}),"\n",(0,a.jsxs)(n.p,{children:["Once you've identified the cause of a failure, you can use the ",(0,a.jsx)(n.strong,{children:"workflow fork"})," operation to reproduce it.\nFork restarts a workflow from a completed step, using checkpointed information to deterministically reproduce the state of the workflow up to that step.\nThus, you can rerun the misbehaving step under the exact conditions that originally caused the misbehavior."]}),"\n",(0,a.jsx)(n.p,{children:"Once you can reproduce a failure in a development environment, it becomes much easier to fix.\nYou can add additional logging or telemetry to the misbehaving step to identify the root cause.\nThen, when you have a fix, you can reproduce the failure with the fix in place to test if it works.\nFor example, if you hypothesize that the malformed output was caused by an error in the prompt, you can fix the prompt, rerun the failed step, and watch it complete successfully:"}),"\n",(0,a.jsx)("img",{src:t(9841).A,alt:"Successful Agent",width:"750",className:"custom-img"}),"\n",(0,a.jsx)(n.h3,{id:"reliable-human-in-the-loop",children:"Reliable Human-in-the-Loop"}),"\n",(0,a.jsxs)(n.p,{children:["Many agents need a ",(0,a.jsx)(n.strong,{children:"human in the loop"})," for decisions that are too important to fully trust an LLM.\nHowever, it's not easy to design an agent that waits for human feedback.\nThe key issue is ",(0,a.jsx)(n.strong,{children:"time"}),": a human might take hours or days to respond to an agent, so the agent must be able to reliably wait for a long time (during which the server might be restarted, software might be upgraded, etc.)."]}),"\n",(0,a.jsxs)(n.p,{children:["Durable workflows help because they provide tools like ",(0,a.jsx)(n.strong,{children:"durable notifications"}),".\nFor example, you can add a line of code to your agent that tells it to wait hours or days for a notification:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"approval: Optional[HumanResponseRequest] = DBOS.recv(timeout_seconds=TIMEOUT)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Because the workflow's progress is checkpointed and both the deadline and notification are stored in your database, this can safely wait for a long time.\nAnything can happen while your agent is waiting (its server can restart, its code can be upgraded, etc.) and it will recover and keep waiting until the notification arrives or the deadline is reached."}),"\n",(0,a.jsxs)(n.p,{children:["If you're interested in building human-in-the-loop agents, check out the ",(0,a.jsx)(n.a,{href:"/python/examples/agent-inbox",children:"agent inbox"})," example, which shows how to use durable notifications to add human-in-the-loop to agents and how to use workflow introspection to monitor and display which agents are waiting for which human inputs."]}),"\n",(0,a.jsx)(n.h3,{id:"distributing-work",children:"Distributing Work"}),"\n",(0,a.jsxs)(n.p,{children:["Often AI applications and agents need to ",(0,a.jsx)(n.strong,{children:"distribute work"})," and run many parallel tasks across many servers.\nFor example, a document ingestion pipeline using Retrieval-Augmented Generation (RAG) to power an agent must be able to index tens of thousands of documents concurrently.\nA deep research agent searching the Internet must be able to to concurrently scrape hundreds of websites."]}),"\n",(0,a.jsxs)(n.p,{children:["Workflows help by providing a ",(0,a.jsx)(n.strong,{children:"durable queue"})," abstraction to reliably distribute work.\nA workflow can enqueue any number of tasks for concurrent processing.\nFor example, a document ingestion pipeline can enqueue workflows to process each document in a batch:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'queue = Queue("indexing_queue")\n\n@DBOS.workflow()\ndef index_documents(urls):\n    handles: List[WorkflowHandle] = []\n    # Enqueue each document for indexing\n    for url in urls:\n        handle = queue.enqueue(index_document, url)\n        handles.append(handle)\n    # Wait for all documents to finish indexing, count the total number of indexed pages\n    outputs = []\n    for handle in handles:\n        outputs.append(handle.get_result())\n    return outputs\n'})}),"\n",(0,a.jsx)(n.p,{children:"The enqueued workflows can be dequeued and executed by any of your application's servers.\nIf your application is resource intensive or uses rate-limited APIs, you can use queues to rate-limit or control the concurrency of your workflows.\nFor example, you can specify that no more than 10 workflows should run concurrently on a single server:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'queue = Queue("indexing_queue", worker_concurrency=10)\n'})}),"\n",(0,a.jsx)(n.p,{children:"Because queues are backed by durable workflows, they can automatically recover from any failure: if a server restarts or has a network hiccup partway through a multi-hour run of your pipeline on a batch of 10K documents, your pipeline will recover from the last indexed document instead of restarting from the beginning and redoing expensive work."}),"\n",(0,a.jsxs)(n.p,{children:["If you're interested in building distributed AI agents or data pipelines, check out the ",(0,a.jsx)(n.a,{href:"/python/examples/document-detective",children:"document ingestion example"}),", which shows best practices for building durable distributed applications."]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},3645:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/agent-fail-49a58cf3ea2d5b1b288c60399ab6924a.png"},9841:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/agent-succeed-f9719f720be725a722c9822476979f0f.png"},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var o=t(6540);const a={},i=o.createContext(a);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);