"use strict";(self.webpackChunkdbos_docs=self.webpackChunkdbos_docs||[]).push([[7904],{2926:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>a,contentTitle:()=>s,default:()=>u,frontMatter:()=>c,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"production/workflow-recovery","title":"Workflow Recovery","description":"When the execution of a durable workflow is interrupted (for example, if its executor is restarted, interrupted, or crashes), another executor must recover the workflow and resume its execution.","source":"@site/docs/production/workflow-recovery.md","sourceDirName":"production","slug":"/production/workflow-recovery","permalink":"/production/workflow-recovery","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":50,"frontMatter":{"sidebar_position":50,"title":"Workflow Recovery"},"sidebar":"tutorialSidebar","previous":{"title":"Workflow Management","permalink":"/production/workflow-management"},"next":{"title":"Deploying With Docker","permalink":"/production/hosting-with-docker"}}');var n=t(4848),i=t(8453);const c={sidebar_position:50,title:"Workflow Recovery"},s=void 0,a={},d=[{value:"Managing Recovery",id:"managing-recovery",level:2},{value:"Recovery On A Single Server",id:"recovery-on-a-single-server",level:3},{value:"Recovery in a Distributed Setting",id:"recovery-in-a-distributed-setting",level:3},{value:"Recovery With Conductor",id:"recovery-with-conductor",level:3}];function l(e){const o={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.p,{children:"When the execution of a durable workflow is interrupted (for example, if its executor is restarted, interrupted, or crashes), another executor must recover the workflow and resume its execution.\nTo prevent duplicate work, it is important to detect interruptions promptly and to recover each workflow only once.\nThis guide describes how to manage workflow recovery in a production environment."}),"\n",(0,n.jsx)(o.h2,{id:"managing-recovery",children:"Managing Recovery"}),"\n",(0,n.jsx)(o.h3,{id:"recovery-on-a-single-server",children:"Recovery On A Single Server"}),"\n",(0,n.jsxs)(o.p,{children:["If hosting an application on a single server without Conductor, each time you restart your application's process, DBOS recovers all workflows that were executing before the restart (all ",(0,n.jsx)(o.code,{children:"PENDING"})," workflows)."]}),"\n",(0,n.jsx)(o.h3,{id:"recovery-in-a-distributed-setting",children:"Recovery in a Distributed Setting"}),"\n",(0,n.jsx)(o.p,{children:"When self-hosting in a distributed setting without Conductor, it is important to manage workflow recovery so that when an executor crashes, restarts, or is shut down, its workflows are recovered.\nYou should assign each executor running a DBOS application an executor ID through DBOS configuration.\nEach workflow is tagged with the ID of the executor that started it.\nWhen an application with an executor ID restarts, it only recovers pending workflows assigned to that executor ID."}),"\n",(0,n.jsx)(o.h3,{id:"recovery-with-conductor",children:"Recovery With Conductor"}),"\n",(0,n.jsxs)(o.p,{children:["If your application is connected to ",(0,n.jsx)(o.a,{href:"/production/conductor",children:"DBOS Conductor"}),", workflow recovery is automatic.\nWhen Conductor detects that an executor is unhealthy, it automatically signals another executor to recover its workflows."]}),"\n",(0,n.jsxs)(o.p,{children:["When an executor disconnects from Conductor, its status is changed to ",(0,n.jsx)(o.code,{children:"DISCONNECTED"})," while Conductor waits for it to reconnect.\nIf it has not reconnected after a grace period, its status is changed to ",(0,n.jsx)(o.code,{children:"DEAD"})," and Conductor signals another executor of a compatible application version to recover its workflows.\nAfter recovery is confirmed, the executor is deleted."]})]})}function u(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,n.jsx)(o,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,o,t)=>{t.d(o,{R:()=>c,x:()=>s});var r=t(6540);const n={},i=r.createContext(n);function c(e){const o=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function s(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:c(e.components),r.createElement(i.Provider,{value:o},e.children)}}}]);